<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/hadleysu/gitblog</id><title>RSS feed of hadleysu's gitblog</title><updated>2023-10-17T13:50:29.946872+00:00</updated><link href="https://github.com/hadleysu/gitblog"/><link href="https://raw.githubusercontent.com/hadleysu/gitblog/main/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator><entry><id>https://github.com/hadleysu/gitblog/issues/5</id><title>设计模式</title><updated>2023-10-17T13:50:30.256074+00:00</updated><content type="html"><![CDATA[<h1>设计模式</h1>
<ul>
<li>
<a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a><ul>
<li><a href="#%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95">学习方法</a></li>
<li>
<a href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">第一部分：基础知识</a><ul>
<li>
<a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0">设计模式概述</a><ul>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5">设计模式从何而来</a></li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">设计模式是什么</a></li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">设计模式有什么用</a></li>
</ul>
</li>
<li>
<a href="#uml%E7%B1%BB%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">UML类图相关知识与面向对象设计原则</a><ul>
<li><a href="#uml%E7%B1%BB%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">UML类图相关知识</a></li>
<li><a href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">类之间的关系</a></li>
<li><a href="#7%E4%B8%AA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">7个面向对象设计原则</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%9E%8B">第二部分：创建型模型</a></li>
</ul>
</li>
</ul>
<p>书籍：设计模式的艺术</p>
<h2>学习方法</h2>
<p>在学习每个设计模式时至少应该掌握如下几点：这个设计模式的意图是什么，它要解决一个什么问题，什么时候可以使用它；它是如何解决问题的，掌握它的结构图，记住它的关键代码；能够想到至少两个它的应用实例，一个生活中的，一个软件中的；这个模式的优缺点是什么，在使用时要注意什么。</p>
<h2>第一部分：基础知识</h2>
<h3>设计模式概述</h3>
<ul>
<li>设计模式从何而来？</li>
<li>设计模式是什么？</li>
<li>设计模式有什么用？</li>
</ul>
<h4>设计模式从何而来</h4>
<p>建筑学</p>
<h4>设计模式是什么</h4>
<p>设计模式是软件设计过程中常见问题的典型解决方案。</p>
<h4>设计模式有什么用</h4>
<p>设计模式提供了一种通用语言，可以帮助您的团队更有效地沟通。可以避免做一些重复性的工作，有助于提高设计和开发效率。</p>
<h3>UML类图相关知识与面向对象设计原则</h3>
<ul>
<li>UML类图相关知识</li>
<li>7个面向对象设计原则</li>
</ul>
<h4>UML类图相关知识</h4>
<p>UML（Unified Modeling Language，统一建模语言）。<br />
UML结构主要包括以下几个部分：</p>
<ul>
<li>视图（View）：UML视图用于从不同的角度来表示待建模系统。包括用户视图、结构视图、行为视图、实现视图和环境视图。</li>
<li>图（Diagram）：UML图是描述UML视图内容的图形。13种图，分别是/用例图（Use Case Diagram）/、/类图（Class Diagram）、对象图（Object Diagram）、包图（Package Diagram）、组合结构图（Composite Structure Diagram）/、/状态图（State Diagram）、活动图（Activity Diagram）、顺序图（Sequence Diagram）、通信图（Communication Diagram）、定时图（Timing Diagram）、交互概览图（Interaction Overview Diagram）/、/组件图（Component Diagram）/和/部署图（Deployment Diagram）/，通过它们之间的相互结合可提供待建模系统的所有视图。</li>
<li>模型元素（Model Element）：模型元素是指UML图中所使用的一些概念，它们对应于普通的面向对象概念，如类、对象、消息以及这些概念之间的关系，如关联关系、依赖关系、泛化关系等。</li>
<li>通用机制（General Mechanism）：UML提供的通用机制为模型元素提供额外的注释、信息和语义，这些通用机制也提供了扩展机制，允许用户对UML进行扩展，如定义新的建模元素等等。</li>
</ul>
<h4>类之间的关系</h4>
<p>关联关系</p>
<ul>
<li>双向关联</li>
<li>单向关联</li>
<li>自关联</li>
<li>多重性关联（表示两个关联对象在数量上的对应关系）</li>
<li>聚合关系（表示整体与部分的关系）</li>
<li>组合关系（也表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期）</li>
</ul>
<p>依赖关系</p>
<ul>
<li>在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。</li>
</ul>
<p>泛化关系</p>
<ul>
<li>也就是继承关系，用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。在代码实现时，使用面向对象的继承机制来实现泛化关系，如在Java语言中使用extends关键字</li>
</ul>
<h4>7个面向对象设计原则</h4>
<h2>第二部分：创建型模型</h2>
]]></content><link href="https://github.com/hadleysu/gitblog/issues/5" rel="alternate"/><category term="技术相关"/><published>2023-10-16T14:19:29+00:00</published></entry><entry><id>https://github.com/hadleysu/gitblog/issues/4</id><title>python编程从入门到实践笔记</title><updated>2023-10-17T13:50:30.412708+00:00</updated><content type="html"><![CDATA[<h1>python编程从入门到实践笔记<!-- omit in toc --></h1>
<ul>
<li><a href="#is-python-interpreted-or-compiled-yes">Is Python interpreted or compiled? Yes.</a></li>
<li>
<a href="#2-%E5%8F%98%E9%87%8F%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2 变量和简单的数据类型</a><ul>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
<li><a href="#%E6%95%B0">数</a></li>
<li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li>
</ul>
</li>
<li>
<a href="#3-%E5%88%97%E8%A1%A8%E7%AE%80%E4%BB%8B">3 列表简介</a><ul>
<li><a href="#%E5%88%97%E8%A1%A8">列表</a></li>
<li><a href="#%E7%AE%A1%E7%90%86%E5%88%97%E8%A1%A8--sort--sorted--len-">管理列表 ( sort() , sorted() , len() )</a></li>
<li><a href="#%E4%BD%BF%E5%88%97%E8%A1%A8%E6%97%B6%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E9%94%99%E8%AF%AF">使⽤列表时避免索引错误</a></li>
</ul>
</li>
<li>
<a href="#4-%E6%93%8D%E4%BD%9C%E5%88%97%E8%A1%A8">4 操作列表</a><ul>
<li><a href="#%E9%81%8D%E5%8E%86%E6%95%B4%E4%B8%AA%E5%88%97%E8%A1%A8for">遍历整个列表（for）</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E7%BC%A9%E8%BF%9B%E9%94%99%E8%AF%AF">避免缩进错误</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E5%80%BC%E5%88%97%E8%A1%A8--list--range--">创建数值列表 ( list ( range() ) )</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%88%97%E8%A1%A8%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%E5%88%87%E7%89%87">使用列表的一部分（切片）</a></li>
<li><a href="#%E5%85%83%E7%BB%84">元组</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F">设置代码格式</a></li>
</ul>
</li>
<li>
<a href="#5-if-%E8%AF%AD%E5%8F%A5">5 if 语句</a><ul>
<li><a href="#%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F">条件测试（布尔表达式）</a></li>
<li><a href="#if-%E8%AF%AD%E5%8F%A5-if-else-%E8%AF%AD%E5%8F%A5-if-elif-else-%E8%AF%AD%E5%8F%A5">if 语句/ if-else 语句/ if-elif-else 语句</a></li>
<li><a href="#%E4%BD%BF-if-%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E5%88%97%E8%A1%A8">使⽤ if 语句处理列表</a></li>
</ul>
</li>
<li>
<a href="#6-%E5%AD%97%E5%85%B8">6 字典</a><ul>
<li><a href="#%E5%AD%97%E5%85%B8%E5%AE%9A%E4%B9%89--key--value--key--value--">字典定义（ { key : value , key : value } ）</a></li>
<li><a href="#%E4%BD%BF%E5%AD%97%E5%85%B8">使⽤字典</a></li>
<li><a href="#%E9%81%8D%E5%8E%86%E5%AD%97%E5%85%B8">遍历字典</a></li>
<li><a href="#%E5%B5%8C%E5%A5%97">嵌套</a></li>
</ul>
</li>
<li>
<a href="#7-%E6%88%B7%E8%BE%93%E5%92%8C-while-%E5%BE%AA%E7%8E%AF">7 ⽤户输⼊和 while 循环</a><ul>
<li><a href="#%E4%BD%BF-input-%E6%9D%A5%E8%AE%A9%E6%88%B7%E6%8F%90%E4%BE%9B%E4%BF%A1%E6%81%AF">使⽤ input() 来让⽤户提供信息</a></li>
<li><a href="#%E6%8E%A7%E5%88%B6-while-%E5%BE%AA%E7%8E%AF%E6%B5%81%E7%A8%8B%E7%9A%84%E5%BC%8F">控制 while 循环流程的⽅式</a></li>
<li><a href="#%E4%BD%BF-while-%E5%BE%AA%E7%8E%AF%E5%A4%84%E7%90%86%E5%88%97%E8%A1%A8%E5%92%8C%E5%AD%97%E5%85%B8">使⽤ while 循环处理列表和字典</a></li>
</ul>
</li>
<li>
<a href="#8-%E5%87%BD%E6%95%B0">8 函数</a><ul>
<li><a href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%AE%9E%E5%8F%82%E5%BD%A2%E5%8F%82">定义函数、实参形参</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%AE%9E%E5%8F%82">如何传递实参</a></li>
<li><a href="#%E8%BF%94%E5%9B%9E%E5%80%BC">返回值</a></li>
<li><a href="#%E4%BC%A0%E9%80%92%E5%88%97%E8%A1%A8">传递列表</a></li>
<li><a href="#%E4%BC%A0%E9%80%92%E4%BB%BB%E6%84%8F%E6%95%B0%E9%87%8F%E7%9A%84%E5%AE%9E%E5%8F%82-%E5%BD%A2%E5%8F%82--%E5%BD%A2%E5%8F%82">传递任意数量的实参 （*形参 / **形参）</a></li>
<li><a href="#%E5%B0%86%E5%87%BD%E6%95%B0%E5%AD%98%E5%82%A8%E5%9C%A8%E6%A8%A1%E5%9D%97%E4%B8%AD%E5%86%8D%E5%B0%86%E6%A8%A1%E5%9D%97%E5%AF%BC%E4%B8%BB%E7%A8%8B%E5%BA%8F">将函数存储在模块中，再将模块导⼊主程序</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97">函数编写指南</a></li>
</ul>
</li>
<li>
<a href="#9-%E7%B1%BB">9 类</a><ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%B1%BB%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B">创建和使⽤类创建实例</a></li>
<li><a href="#%E7%BB%99%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8C%87%E5%AE%9A%E9%BB%98%E8%AE%A4%E5%80%BC%E4%BF%AE%E6%94%B9%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC">给类的属性指定默认值，修改实例的属性的值</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li>
<li><a href="#%E5%AF%BC%E7%B1%BB">导⼊类</a></li>
<li><a href="#python-%E6%A0%87%E5%87%86%E5%BA%93">Python 标准库</a></li>
<li><a href="#%E7%B1%BB%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A0%BC">类的编程⻛格</a></li>
</ul>
</li>
<li>
<a href="#10-%E4%BB%B6%E5%92%8C%E5%BC%82%E5%B8%B8">10 ⽂件和异常</a><ul>
<li><a href="#%E8%AF%BB%E5%8F%96%E4%BB%B6-path%E5%AF%B9%E8%B1%A1--read_text-">读取⽂件（ path对象 . read_text() ）</a></li>
<li><a href="#%E5%86%99%E4%BB%B6-path%E5%AF%B9%E8%B1%A1--write_text-">写⼊⽂件（ path对象 . write_text() ）</a></li>
<li>
<a href="#%E5%BC%82%E5%B8%B8">异常</a><ul>
<li><a href="#%E4%BD%BF-try-except-%E4%BB%A3%E7%A0%81%E5%9D%97">使⽤ try-except 代码块</a></li>
<li><a href="#else-%E4%BB%A3%E7%A0%81%E5%9D%97">else 代码块</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E6%9C%89">常见的异常类型有</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E6%A8%A1%E5%9D%97-json-%E6%9D%A5%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE">使⽤模块 json 来存储数据</a></li>
<li><a href="#%E9%87%8D%E6%9E%84">重构</a></li>
</ul>
</li>
<li>
<a href="#11-%E4%BD%BF-pytest-%E5%B7%A5%E5%85%B7%E5%BA%93%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">11 使⽤ pytest 工具库测试代码</a><ul>
<li><a href="#%E4%BD%BF-pip-%E5%AE%89%E8%A3%85-pytest">使⽤ pip 安装 pytest</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0">测试函数</a></li>
<li><a href="#%E8%BF%90%E6%B5%8B%E8%AF%95">运⾏测试</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E7%B1%BB">测试类</a></li>
<li><a href="#%E4%BD%BF%E5%A4%B9%E5%85%B7">使⽤夹具</a></li>
</ul>
</li>
</ul>
<h2><a href="https://nedbatchelder.com/blog/201803/is_python_interpreted_or_compiled_y0-es.html">Is Python interpreted or compiled? Yes.</a></h2>
<h2>2 变量和简单的数据类型</h2>
<h3>变量</h3>
<ul>
<li>
变量(variable)：变量是可以被赋值的标签，也可以说变量指向特定的值(value)。<ul>
<li>变量的命名：变量名只能包含字⺟、数字和下划线 。变量名能以字⺟或下划线打头，但不能以数字打头。变量名不能包含空格，但能使⽤下划线来分隔其中的单词。</li>
<li>注意：应使⽤⼩写的 Python 变量名。全大写定义常量。</li>
</ul>
</li>
</ul>
<h3>字符串</h3>
<ul>
<li>
字符串(string)：。在 Python 中，⽤引号引起的都是字符串，其中的引号可以是单引号，也可以是双引号.<ul>
<li>
<p>使⽤⽅法修改字符串的⼤⼩写:</p>
<pre><code class="language-python">name = &quot;ada lovelace&quot;
print(name.title()) # title() ⽅法以⾸字⺟⼤写的⽅式显⽰每个单词
name = &quot;Ada Lovelace&quot;
print(name.upper()) # upper() 方法以全大写显示字符串
print(name.lower()) # lower() 方法以全小写显示字符串
</code></pre>
</li>
<li>
<p>f 字符串：将要插⼊的变量放在花括号内</p>
<pre><code class="language-python">first_name = &quot;ada&quot;
last_name = &quot;lovelace&quot;
full_name = f&quot;{first_name} {last_name}&quot;
print(full_name)
print(f&quot;Hello, {full_name.title()}!&quot;)
# 这种字符串称为 f 字符串。f 是 format（设置格式）的简写，因为 Python 通过把花括号内的变量替换为其值来设置字符串的格式。
</code></pre>
</li>
<li>
<p>使⽤制表符或换⾏符来添加空⽩</p>
<pre><code class="language-python"># 制表符 \t ; 换行符 \n ;
&gt;&gt;&gt; print(&quot;Languages:\n\tPython\n\tC\n\tJavaScript&quot;)
Languages:
    Python
    C
    JavaScript
</code></pre>
</li>
<li>
<p>删除空⽩</p>
<pre><code class="language-python"># rstrip() lstrip() strip()分别为删除字符串右端的空⽩、删除字符串左端的空⽩、同时删除字符串两端的空⽩
&gt;&gt;&gt; favorite_language = &#x27; python &#x27;
&gt;&gt;&gt; favorite_language.rstrip()
&#x27; python&#x27;
&gt;&gt;&gt; favorite_language.lstrip()
&#x27;python &#x27;
&gt;&gt;&gt; favorite_language.strip()
&#x27;python&#x27;
</code></pre>
</li>
<li>
<p>删除前缀</p>
<pre><code class="language-python"># removeprefix() ⽅法
&gt;&gt;&gt; nostarch_url = &#x27;https://nostarch.com&#x27;
&gt;&gt;&gt; nostarch_url.removeprefix(&#x27;https://&#x27;)
&#x27;nostarch.com&#x27;
# 如果想保留删除前缀后的值，既可将其重新赋给原来的变量，也可将其赋给另⼀个变量
&gt;&gt;&gt; simple_url = nostarch_url.removeprefix(&#x27;https://&#x27;)
</code></pre>
</li>
</ul>
</li>
</ul>
<h3>数</h3>
<ul>
<li>
<p>整数(integer)</p>
<pre><code class="language-python"># Python 使⽤两个乘号（**）表⽰乘⽅运算
&gt;&gt;&gt; 3 ** 2
9
</code></pre>
</li>
<li>
<p>浮点数(float)</p>
<pre><code class="language-python"># 将任意两个数相除，结果总是浮点数，即便这两个数都是整数且能整除：
&gt;&gt;&gt; 4/2
2.0
# 在 Python 中，⽆论是哪种运算，只要有操作数是浮点数，默认得到的就总是浮点数，即便结果原本为整数。
&gt;&gt;&gt; 1 + 2.0
3.0
&gt;&gt;&gt; 2 * 3.0
6.0
&gt;&gt;&gt; 3.0 ** 2
9.0
</code></pre>
</li>
<li>
<p>数中的下划线</p>
<pre><code class="language-python"># 为在存储这种数时，Python 会忽略其中的下划线。在对数字位分组时，即便不是将每三位分成⼀组，也不会影响最终的值。
&gt;&gt;&gt; universe_age = 14_000_000_000
&gt;&gt;&gt; print(universe_age)
14000000000
# 这种表⽰法既适⽤于整数，也适⽤于浮点数。
</code></pre>
</li>
<li>
<p>常数(constant)：是在程序的整个⽣命周期内都保持不变的变量。其变量名全⼤写。</p>
<pre><code class="language-python">MAX_CONNECTIONS = 5000
</code></pre>
</li>
</ul>
<h3>注释</h3>
<ul>
<li>注释(comment)：注释⽤井号（#）标识。批量注释CTRL + /</li>
</ul>
<h2>3 列表简介</h2>
<h3>列表</h3>
<ul>
<li>
<p>列表(list)：由⼀系列按特定顺序排列的元素组成。在 Python 中，⽤⽅括号（[]）表⽰列表，⽤逗号分隔其中的元素。</p>
<ul>
<li>
<p>Python 为访问最后⼀个列表元素提供了⼀种特殊语法。通过将索引指定为-1，可让 Python 返回最后⼀个列表元素。</p>
<pre><code class="language-python">bicycles = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;]
print(bicycles[-1])
# 这些代码返回 &#x27;specialized&#x27;。
</code></pre>
</li>
<li>
<p>这种语法很有⽤，因为你经常需要在不知道列表⻓度的情况下访问最后的元素。这种约定也适⽤于其他负数索引，例如，索引 -2 返回倒数第⼆个列表元素，索引 -3 返回倒数第三个列表元素，依此类推。</p>
</li>
</ul>
</li>
<li>
<p>修改、添加和删除元素</p>
<ul>
<li>
<p>修改列表元素</p>
<pre><code class="language-python">motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]
print(motorcycles)
motorcycles[0] = &#x27;ducati&#x27;
print(motorcycles)
</code></pre>
</li>
<li>
<p>在列表中添加元素</p>
<ul>
<li>
<p>在列表末尾添加元素</p>
<pre><code class="language-python"># 在列表中添加新元素时，最简单的⽅式是将元素追加（append）到列表末尾。
motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]
print(motorcycles)
motorcycles.append(&#x27;ducati&#x27;)
print(motorcycles)
# append() ⽅法让动态地创建列表易如反掌。例如，你可以先创建⼀个空列表，再使⽤⼀系列函数调⽤ append() 添加元素。
motorcycles = []
motorcycles.append(&#x27;honda&#x27;)
motorcycles.append(&#x27;yamaha&#x27;)
motorcycles.append(&#x27;suzuki&#x27;)
print(motorcycles)
</code></pre>
</li>
<li>
<p>在列表中插⼊元素</p>
<pre><code class="language-python"># 使⽤ insert() ⽅法可在列表的任意位置添加新元素。
motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]
motorcycles.insert(0, &#x27;ducati&#x27;)
print(motorcycles)
#这种操作将列表中的每个既有元素都右移⼀个位置。
[&#x27;ducati&#x27;, &#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]
</code></pre>
</li>
</ul>
</li>
<li>
<p>从列表中删除元素</p>
<ul>
<li>
<p>使⽤ del 语句删除元素</p>
<pre><code class="language-python">#如果知道要删除的元素在列表中的位置，可使⽤ del 语句
#使⽤ del 可删除任意位置的列表元素，只需要知道其索引即可。
motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]
print(motorcycles)
del motorcycles[1]
print(motorcycles)
</code></pre>
</li>
<li>
<p>使⽤ pop() ⽅法删除元素</p>
<pre><code class="language-python"># pop() ⽅法删除列表末尾的元素，并让你能够接着使⽤它。每当你使⽤ pop() 时，被弹出的元素就不再在列表中了。
motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]
print(motorcycles)
popped_motorcycle = motorcycles.pop()
print(motorcycles)
print(popped_motorcycle)
# 输出表明，列表末尾的值 &#x27;suzuki&#x27; 已删除，它现在被赋给了变量popped_motorcycle
[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]
[&#x27;honda&#x27;, &#x27;yamaha&#x27;]
suzuki
</code></pre>
</li>
<li>
<p>删除列表中任意位置的元素</p>
<pre><code class="language-python"># 也可以使⽤ pop() 删除列表中任意位置的元素，只需要在括号中指定要删除的元素的索引即可。
motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]
first_owned = motorcycles.pop(0)
print(f&quot;The first motorcycle I owned was a {first_owned.title()}.&quot;)
# ⾸先弹出列表中的第⼀款摩托⻋，然后打印⼀条有关这辆摩托⻋的消息。
The first motorcycle I owned was a Honda.
</code></pre>
<p>如果不确定该使⽤ del 语句还是 pop() ⽅法，下⾯是⼀个简单的判断标准：如果要从列表中删除⼀个元素，且不再以任何⽅式使⽤它，就使⽤ del 语句；如果要在删除元素后继续使⽤它，就使⽤ pop() ⽅法。</p>
</li>
<li>
<p>根据值删除元素</p>
<pre><code class="language-python"># 有时候，你不知道要从列表中删除的值在哪个位置。如果只知道要删除的元素的值，可使⽤ remove() ⽅法。
motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;, &#x27;ducati&#x27;]
print(motorcycles)
motorcycles.remove(&#x27;ducati&#x27;)
print(motorcycles)
# remove() ⽅法让 Python 确定 &#x27;ducati&#x27; 出现在列表的什么地⽅，并将该元素删除：
[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;, &#x27;ducati&#x27;]
[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]
# 注意：remove() ⽅法只删除第⼀个指定的值。如果要删除的值可能在列表中出现多次，就需要使⽤循环，确保将每个值都删除。这将在第 7 章介绍。
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>管理列表 ( sort() , sorted() , len() )</h3>
<ul>
<li>
<p>使⽤ sort() ⽅法对列表进⾏永久排序</p>
<pre><code class="language-python">cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]
cars.sort()
print(cars)
# sort() ⽅法能永久地修改列表元素的排列顺序。现在，汽⻋是按字⺟顺序排列的，再也⽆法恢复到原来的排列顺序：
[&#x27;audi&#x27;, &#x27;bmw&#x27;, &#x27;subaru&#x27;, &#x27;toyota&#x27;]
# 还可以按与字⺟顺序相反的顺序排列列表元素，只需向 sort() ⽅法传递参数 reverse=True 即可。下⾯的⽰例将汽⻋列表按与字⺟顺序相反的顺序排列：
cars.sort(reverse=True)
# 同样，对列表元素排列顺序的修改也是永久的：
[&#x27;toyota&#x27;, &#x27;subaru&#x27;, &#x27;bmw&#x27;, &#x27;audi&#x27;]
</code></pre>
</li>
<li>
<p>使⽤ sorted() 函数对列表进⾏临时排序</p>
<pre><code class="language-python"># 要保留列表元素原来的排列顺序，并以特定的顺序呈现它们，可使⽤sorted() 函数。
cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]
❶ print(&quot;Here is the original list:&quot;)
print(cars)
❷ print(&quot;\nHere is the sorted list:&quot;)
print(sorted(cars))
❸ print(&quot;\nHere is the original list again:&quot;)
print(cars)
# 注意，在调⽤ sorted() 函数后，列表元素的排列顺序并没有变:
Here is the original list:
[&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]
Here is the sorted list:
[&#x27;audi&#x27;, &#x27;bmw&#x27;, &#x27;subaru&#x27;, &#x27;toyota&#x27;]
Here is the original list again:
[&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]
# 如果要按与字⺟顺序相反的顺序显⽰列表，也可向 sorted() 函数传递参数 reverse=True。
# 注意：在并⾮所有的值都是全⼩写的时，按字⺟顺序排列列表要复杂⼀些。在确定排列顺序时，有多种解读⼤写字⺟的⽅式，此时要指定准确的排列顺序，可能会⽐这⾥所做的更加复杂。然⽽，⼤多数排序⽅式是以本节介绍的知识为基础的。
</code></pre>
</li>
<li>
<p>反向打印列表</p>
<pre><code class="language-python"># 要反转列表元素的排列顺序，可使⽤ reverse() ⽅法。
cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]
print(cars)
cars.reverse()
print(cars)
#请注意，reverse() 不是按与字⺟顺序相反的顺序排列列表元素，只是反转列表元素的排列顺序：
[&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]
[&#x27;subaru&#x27;, &#x27;toyota&#x27;, &#x27;audi&#x27;, &#x27;bmw&#x27;]
# reverse() ⽅法会永久地修改列表元素的排列顺序，但可随时恢复到原来的排列顺序，只需对列表再次调⽤ reverse() 即可。
</code></pre>
</li>
<li>
<p>确定列表的⻓度</p>
<pre><code class="language-python"># 使⽤ len() 函数可快速获悉列表的⻓度。
&gt;&gt;&gt; cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]
&gt;&gt;&gt; len(cars)
4
# 注意：Python 在计算列表元素数时从 1 开始，因此你在确定列表⻓度时应该不会遇到差⼀错误。
</code></pre>
</li>
</ul>
<h3>使⽤列表时避免索引错误</h3>
<ul>
<li>仅当列表为空时，这种访问最后⼀个元素的⽅式才会导致错误：</li>
</ul>
<pre><code class="language-python">motorcycles = []
print(motorcycles[-1])
# 列表 motorcycles 不包含任何元素，因此 Python 返回⼀条索引错误消息：
Traceback (most recent call last):
  File &quot;motorcyles.py&quot;, line 3, in &lt;module&gt;
    print(motorcycles[-1])
          ~~~~~~~~~~~^^^^
IndexError: list index out of range
</code></pre>
<ul>
<li><em>注意</em>：在发⽣索引错误却找不到解决办法时，请尝试将列表或其⻓度打印出来。列表可能与你以为的截然不同，在程序对其进⾏了动态处理时尤其如此。查看列表或其包含的元素数，可帮助你排查这种逻辑错误。</li>
</ul>
<h2>4 操作列表</h2>
<h3>遍历整个列表（for）</h3>
<ul>
<li>
<p>for循环。在 for 循环中，想包含多少⾏代码都可以。在代码⾏ for magician inmagicians 后⾯，每⾏缩进的代码都是循环的⼀部分，将针对列表中的每个值执⾏⼀次。因此，可对列表中的每个值执⾏任意多的操作。</p>
<pre><code class="language-python">magicians = [&#x27;alice&#x27;, &#x27;david&#x27;, &#x27;carolina&#x27;]
for magician in magicians:
    print(f&quot;{magician.title()}, that was a great trick!&quot;)
    print(f&quot;I can&#x27;t wait to see your next trick,{magician.title()}.\n&quot;)

print(&quot;Thank you, everyone. That was a great magic show!&quot;)
</code></pre>
</li>
<li>
<p>在for 循环后⾯，没有缩进的代码都只执⾏⼀次，不会重复执⾏。</p>
</li>
</ul>
<h3>避免缩进错误</h3>
<ul>
<li>位于 for 语句后⾯且属于循环组成部分的代码⾏，⼀定要缩进。为避免意外的缩进错误，请只缩进需要缩进的代码。</li>
<li>不要遗漏<em>冒号</em>。for 语句末尾的冒号告诉 Python，下⼀⾏是循环的第⼀⾏。</li>
</ul>
<h3>创建数值列表 ( list ( range() ) )</h3>
<ul>
<li>
<p>range() 函数。Python 函数 range() 能⽣成⼀系列的数。可以传一个参数、两个参数、三个参数。</p>
<pre><code class="language-python">for value in range(1, 3):
    print(value)
# range() 函数让 Python 从指定的第⼀个值开始数，并在到达指定的第⼆个值时停⽌，因此输出不包含第⼆个值（这⾥为 3）。
1
2
# 在使⽤ range() 时，如果输出不符合预期，请尝试将指定的值加 1 或减 1。
#在调⽤ range() 函数时，也可只指定⼀个参数，这样它将从 0 开始，例如，range(6) 返回数 0〜5（含）。
</code></pre>
</li>
<li>
<p>使⽤ range() 创建数值列表  </p>
<p>要创建数值列表，可使⽤ list() 函数将 range() 的结果直接转换为列表。如果将 range() 作为 list() 的参数，输出将是⼀个数值列表。</p>
<pre><code class="language-python">numbers = list(range(1, 6))
print(numbers)
# 结果如下：
[1, 2, 3, 4, 5]
# 在使⽤ range() 函数时，还可指定步⻓。为此，可以给这个函数指定第三个参数，Python 将根据这个步⻓来⽣成数。
# 例如，下⾯的代码打印 1〜10 的偶数：
even_numbers = list(range(2, 11, 2))
print(even_numbers)
# 在这个⽰例中，range() 函数从 2 开始数，然后不断地加 2，直到达到或超过终值（11）。因此输出如下：
[2, 4, 6, 8, 10]
# 如何将前 10 个整数的平⽅加⼊⼀个列表：
squares = []
for value in range(1,11):
    squares.append(value**2)
print(squares)
</code></pre>
</li>
<li>
<p>对数值列表执⾏简单的统计计算  </p>
<p>max(),min(),sum(),找出数值列表中的最⼤值、最⼩值和总和.</p>
<pre><code class="language-python">&gt;&gt;&gt; digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
&gt;&gt;&gt; min(digits)
0
&gt;&gt;&gt; max(digits)
9
&gt;&gt;&gt; sum(digits)
45
</code></pre>
</li>
<li>
<p>列表推导式（list comprehension）  </p>
<p>列表推导式将 for 循环和创建新元素的代码合并成⼀⾏，并⾃动追加新元素。<br />
要使⽤这种语法，⾸先指定⼀个描述性的列表名，如 squares。然后指定⼀个左⽅括号，并定义⼀个表达式，⽤于⽣成要存储到列表中的值。在这个⽰例中，表达式为 value** 2，它计算平⽅值。接下来，编写⼀个 for循环，⽤于给表达式提供值，再加上右⽅括号。在这个⽰例中，for 循环为 for value in range(1,11)，它将值1〜10 提供给表达式value * * 2。请注意，这⾥的 for 语句末尾没有冒号。</p>
<pre><code class="language-python">squares = [value**2 for value in range(1, 11)]
print(squares)
# 结果:
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</code></pre>
</li>
</ul>
<h3>使用列表的一部分（切片）</h3>
<ul>
<li>
<p>切片（slice）  </p>
<p>切片就是列表中的部分元素。要创建切⽚，可指定要使⽤的第⼀个元素和最后⼀个元素的索引。与range() 函数⼀样，Python 在到达指定的第⼆个索引之前的元素时停⽌。要输出列表中的前三个元素，需要指定索引 0 和 3，这将返回索引分别为0、1 和 2 的元素。</p>
<pre><code class="language-python">players = [&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]
print(players[0:3])
# 这些代码打印该列表的⼀个切⽚。输出也是⼀个列表，其中包含前三名队员：
[&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;]
# 可以⽣成列表的任意⼦集。例如，如果要提取列表的第⼆、第三和第四个元素，可将起始索引指定为 1，并将终⽌索引指定为 4：
players = [&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]
print(players[1:4])
# 在⽣成的切⽚中，第⼀个元素为 &#x27;martina&#x27;，最后⼀个元素为&#x27;florence&#x27;：
[&#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;]
# 如果没有指定第⼀个索引，Python 将⾃动从列表开头开始：
players = [&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]
print(players[:4])
# 由于没有指定起始索引，Python 从列表开头开始提取：
[&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;]
# 要让切⽚终⽌于列表末尾，也可使⽤类似的语法。例如，如果要提取从第三个元素到列表末尾的所有元素，可将起始索引指定为 2，并省略终⽌索引：
players = [&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]
print(players[2:])
# Python 返回从第三个元素到列表末尾的所有元素：
[&#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]
# 负数索引返回与列表末尾有相应距离的元素，因此可以输出列表末尾的任意切⽚。如果要输出名单上最后三名队员的名字，可使⽤切⽚ players[-3:]：
players = [&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]
print(players[-3:])
</code></pre>
<p>注意：可在表⽰切⽚的⽅括号内指定第三个值。这个值告诉 Python 在指定范围内每隔多少元素提取⼀个。</p>
</li>
<li>
<p>遍历切片  </p>
<p>如果要遍历列表的部分元素，可在 for 循环中使⽤切⽚。</p>
<pre><code class="language-python">players = [&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]
print(&quot;Here are the first three players on my team:&quot;)
❶for player in players[:3]:
    print(player.title())
# ❶处的代码没有遍历整个队员列表，只遍历前三名队员：
Here are the first three players on my team:
Charles
Martina
Michael
</code></pre>
</li>
<li>
<p>复制列表  </p>
<p>要复制列表，可以创建⼀个包含整个列表的切⽚，⽅法是同时省略起始索引和终⽌索引（[:]）。这让 Python 创建⼀个起始于第⼀个元素、终⽌于最后⼀个元素的切⽚，即复制整个列表。</p>
<pre><code class="language-python">my_foods = [&#x27;pizza&#x27;, &#x27;falafel&#x27;, &#x27;carrot cake&#x27;]
❶ friend_foods = my_foods[:]
❷ my_foods.append(&#x27;cannoli&#x27;)
❸ friend_foods.append(&#x27;ice cream&#x27;)
###########################################
# 这是⾏不通的：
friend_foods = my_foods
my_foods.append(&#x27;cannoli&#x27;)
friend_foods.append(&#x27;ice cream&#x27;)
# 上面❶将my_foods的切片赋给friend_foods，所以❷修改的是my_foods列表，❸修改的是friend_foods列表即my_foods的切片。
# 而不使用切片，直接将my_foods赋值给friend_foods，意味着friend_foods和my_foods一起关联my_foods列表，因此这两个变量指向同⼀个列表。
</code></pre>
</li>
</ul>
<h3>元组</h3>
<ul>
<li>
<p>元组（tuple）  </p>
<p>Python将不能修改的值称为不可变的，⽽不可变的列表称为元组（tuple）。如果需要存储⼀组在程序的整个⽣命周期内都不变的值，就可以使⽤元组。<br />
元组看起来很像列表，但使⽤<em>圆括号</em>⽽不是⽅括号来标识。定义元组后，就可使⽤索引来访问其元素，就像访问列表元素⼀样。</p>
<pre><code class="language-python">dimensions = (200, 50)
print(dimensions[0])
print(dimensions[1])
# ⾸先定义元组 dimensions，为此使⽤了圆括号⽽不是⽅括号。接下来，分别打印该元组的各个元素，使⽤的语法与访问列表元素时使⽤的语法相同
</code></pre>
<p>试图修改元组的操作是被禁⽌的,一旦修改将导致Python 返回类型错误的消息。</p>
<pre><code class="language-python">dimensions = (200, 50)
dimensions[0] = 250
# 在代码试图修改矩形的尺⼨时，Python 会报错。
</code></pre>
<p><em>注意</em>：严格地说，元组是由逗号标识的，圆括号只是让元组看起来更整洁、更清晰。如果你要定义只包含⼀个元素的元组，必须在这个元素后⾯加上逗号：</p>
<pre><code class="language-python">my_t = (3,)
# 创建只包含⼀个元素的元组通常没有意义，但⾃动⽣成的元组有可能只有⼀个元素。
</code></pre>
</li>
<li>
<p>fot循环遍历元组中的所有值</p>
<pre><code class="language-python">dimensions = (200, 50)
for dimension in dimensions:
    print(dimension)
</code></pre>
</li>
<li>
<p>修改元组变量  </p>
<p>虽然不能修改元组的元素，但可以给表⽰元组的变量赋值。例如，要修改前述矩形的尺⼨，可重新定义整个元组：</p>
<pre><code class="language-python">dimensions = (200, 50)
dimensions = (400, 100)
# 将⼀个新元组关联到变量 dimensions,Python 没有引发任何错误，因为给元组变量重新赋值是合法的
</code></pre>
</li>
</ul>
<h3>设置代码格式</h3>
<ul>
<li>
<p>Python Enhancement Proposal，PEP(Python 增强提案)  </p>
</li>
<li>
<p>缩进  </p>
<p>PEP 8 建议每级缩进都使⽤ 4 个空格。在编写Python代码时，混用Tab键和空格可能会导致错误。如果混合使⽤了制表符和空格，可将⽂件中的所有制表符都转换为空格，⼤多数编辑器提供了这样的功能。</p>
</li>
<li>
<p>行长  </p>
<p>建议每⾏不超过 80 个字符。注释的⾏⻓不超过 72 个字符。</p>
</li>
<li>
<p>空行  </p>
<p>将程序的不同部分分开，可使⽤空⾏。</p>
</li>
</ul>
<h2>5 if 语句</h2>
<h3>条件测试（布尔表达式）</h3>
<ul>
<li>布尔表达式的结果要么为 True，要么为 False。  </li>
<li>
检查是否相等 ==<ul>
<li>在 Python 中检查是否相等时是区分⼤⼩写的。</li>
</ul>
</li>
<li>检查是否不等 !=</li>
<li>数值⽐较 == / != / &lt; / &lt;= / &gt; / &gt;=</li>
<li>检查多个条件时的且或 and / or</li>
<li>检查特定的值是否在列表中 in</li>
<li>检查特定的值是否不在列表中 not in</li>
</ul>
<h3>if 语句/ if-else 语句/ if-elif-else 语句</h3>
<ul>
<li>
<p>if 语句/ if-else 语句/ if-elif-else 语句</p>
<ul>
<li>if-elif-else 语句中可以使⽤多个 elif 代码块</li>
<li>Python 并不要求 if-elif 结构后⾯必须有 else 代码块。可省略 else 代码块。</li>
</ul>
<pre><code class="language-python">age = 12
if age &lt; 4:
price = 0
elif age &lt; 18:
price = 25
else:
price = 40
print(f&quot;Your admission cost is ${price}.&quot;)
</code></pre>
</li>
</ul>
<h3>使⽤ if 语句处理列表</h3>
<ul>
<li>
<p>检查特殊元素</p>
<pre><code class="language-python">requested_toppings = [&#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;]
for requested_topping in requested_toppings:
    if requested_topping == &#x27;green peppers&#x27;:
        print(&quot;Sorry, we are out of green peppers right now.&quot;)
    else:
        print(f&quot;Adding {requested_topping}.&quot;)
</code></pre>
</li>
<li>
<p>确定列表⾮空</p>
<pre><code class="language-python">requested_toppings = []
if requested_toppings:
    for requested_topping in requested_toppings:
        print(f&quot;Adding {requested_topping}.&quot;)
    print(&quot;\nFinished making your pizza!&quot;)
else:
    print(&quot;Are you sure you want a plain pizza?&quot;)
# 这⾥的列表为空，因此输出如下——询问顾客是否确实要点原味⽐萨：
Are you sure you want a plain pizza?
</code></pre>
<ul>
<li>在 if 语句中将列表名⽤作条件表达式时，Python将在列表⾄少包含⼀个元素时返回 True，在列表为空时返回 False 。</li>
<li><strong>对于数值 0、空值 None、单引号空字符串 ''、双引号空字符串 &quot;&quot;、空列表 []、空元组 ()、空字典 {}，Python 都会返回 False。</strong></li>
</ul>
</li>
<li>
<p>使⽤多个列表</p>
<pre><code class="language-python">available_toppings = [&#x27;mushrooms&#x27;, &#x27;olives&#x27;, &#x27;green peppers&#x27;,&#x27;pepperoni&#x27;, &#x27;pineapple&#x27;, &#x27;extra cheese&#x27;]
requested_toppings = [&#x27;mushrooms&#x27;, &#x27;french fries&#x27;, &#x27;extra cheese&#x27;]

for requested_topping in requested_toppings:
    if requested_topping in available_toppings:
       print(f&quot;Adding {requested_topping}.&quot;)
    else:
       print(f&quot;Sorry, we don&#x27;t have {requested_topping}.&quot;)
print(&quot;\nFinished making your pizza!&quot;)
# 输出
Adding mushrooms.
Sorry, we don&#x27;t have french fries.
Adding extra cheese.
Finished making your pizza!
</code></pre>
</li>
</ul>
<h2>6 字典</h2>
<h3>字典定义（ { key : value , key : value } ）</h3>
<ul>
<li>在 Python 中，字典（dictionary）是⼀系列<strong>键值对</strong>。每个<strong>键</strong>都与⼀个值关联，可以使⽤键来访问与之关联的值。与键相关联的值可以是数、字符串、列表乃⾄字典。事实上，可将任意 Python 对象⽤作字典中的值。</li>
<li>在 Python 中，字典⽤放在<strong>花括号</strong>（{}）中的⼀系列键值对表⽰。</li>
<li><strong>键值对</strong>包含两个相互关联的值。当你指定键时，Python 将返回与之关联的值。键和值之间⽤<strong>冒号</strong>分隔，⽽键值对之间⽤<strong>逗号</strong>分隔。在字典中，你想存储多少个键值对都可以。</li>
</ul>
<pre><code class="language-python">alien_0 = {&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5}
</code></pre>
<h3>使⽤字典</h3>
<ul>
<li>
<p>访问字典中的值</p>
<pre><code class="language-python"># 要获取与键关联的值，可指定字典名并把键放在后⾯的⽅括号内，如下所⽰：
alien_0 = {&#x27;color&#x27;: &#x27;green&#x27;}
print(alien_0[&#x27;color&#x27;])
green
</code></pre>
</li>
<li>
<p>添加键值对</p>
<pre><code class="language-python"># 字典是⼀种动态结构，可随时在其中添加键值对。要添加键值对，可依次指定字典名、⽤⽅括号括起来的键和与该键关联的值。
alien_0 = {&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5}
print(alien_0)
alien_0[&#x27;x_position&#x27;] = 0
alien_0[&#x27;y_position&#x27;] = 25
print(alien_0)
# 字典会保留定义时的元素排列顺序。如果将字典打印出来或遍历其元素，将发现元素的排列顺序与其添加顺序相同。
{&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5}
{&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5, &#x27;x_position&#x27;: 0, &#x27;y_position&#x27;: 25}
</code></pre>
</li>
<li>
<p>创建⼀个空字典</p>
<pre><code class="language-python">alien_0 = {}
alien_0[&#x27;color&#x27;] = &#x27;green&#x27;
alien_0[&#x27;points&#x27;] = 5
</code></pre>
</li>
<li>
<p>修改字典中的值</p>
<pre><code class="language-python"># 要修改字典中的值，可依次指定字典名、⽤⽅括号括起来的键和与该键关联的新值。
alien_0 = {&#x27;color&#x27;: &#x27;green&#x27;}
alien_0[&#x27;color&#x27;] = &#x27;yellow&#x27;
</code></pre>
</li>
<li>
<p>删除键值对</p>
<pre><code class="language-python">#对于字典中不再需要的信息，可使⽤ del 语句将相应的键值对彻底删除。在使⽤ del 语句时，必须指定字典名和要删除的键。
alien_0 = {&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5}
del alien_0[&#x27;points&#x27;]
print(alien_0)
# 注意：删除的键值对永远消失了。
{&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5}
{&#x27;color&#x27;: &#x27;green&#x27;}
</code></pre>
</li>
<li>
<p>由类似的对象组成的字典</p>
<pre><code class="language-python"># 当确定需要使⽤多⾏来定义字典时，先在输⼊左花括号后按回⻋键，再在下⼀⾏缩进 4 个空格，指定第⼀个键值对，并在它后⾯加上⼀个逗号。
favorite_languages = {
    &#x27;jen&#x27;: &#x27;python&#x27;,
    &#x27;sarah&#x27;: &#x27;c&#x27;,
    &#x27;edward&#x27;: &#x27;rust&#x27;,
    &#x27;phil&#x27;: &#x27;python&#x27;,
    }
# 定义好字典后，在最后⼀个键值对的下⼀⾏添加⼀个右花括号，并且也缩进 4 个空格，使其与字典中的键对⻬。
# ⼀种不错的做法是，在最后⼀个键值对后⾯也加上逗号，为以后添加键值对做好准备。
</code></pre>
</li>
<li>
<p>使⽤ get() 来访问值</p>
<ul>
<li>
<p>如果指定的键有可能不存在，应考虑使⽤ get() ⽅法，⽽不要使⽤⽅括号表⽰法，因为会报错。</p>
</li>
<li>
<p>get() ⽅法在指定的键不存在时返回⼀个默认值。get() ⽅法的第⼀个参数⽤于指定键，是必不可少的；第⼆个参数为当指定的键不存在时要返回的值，是可选的。</p>
</li>
<li>
<p>注意：在调⽤ get() 时，如果没有指定第⼆个参数且指定的键不存在，Python 将返回值 None，这个特殊的值表⽰没有相应的值。这并⾮错误，None 只是⼀个表⽰所需值不存在的特殊值，第 8 章将介绍它的其他⽤途。</p>
<pre><code class="language-python">alien_0 = {&#x27;color&#x27;: &#x27;green&#x27;, &#x27;speed&#x27;: &#x27;slow&#x27;}
point_value = alien_0.get(&#x27;points&#x27;, &#x27;No point value assigned.&#x27;)
print(point_value)
# 如果字典中有键 &#x27;points&#x27;，将获得与之关联的值；如果没有，将获得指定的默认值。虽然这⾥没有键 &#x27;points&#x27;，但是我们将获得⼀条清晰的消息，不会引发错误：
No point value assigned.
</code></pre>
</li>
</ul>
</li>
</ul>
<h3>遍历字典</h3>
<ul>
<li>
<p>遍历所有的键值对 ( items() )<br />
字典名.items()，这个⽅法返回⼀个键值对列表。  </p>
<pre><code class="language-python">favorite_languages = {
    &#x27;jen&#x27;: &#x27;python&#x27;,
    &#x27;sarah&#x27;: &#x27;c&#x27;,
    &#x27;edward&#x27;: &#x27;rust&#x27;,
    &#x27;phil&#x27;: &#x27;python&#x27;,
    }
for name, language in favorite_languages.items():
    print(f&quot;{name.title()}&#x27;s favorite language is {language.title()}.&quot;)
# 这些代码让 Python 遍历字典中的每个键值对，并将键赋给变量 name，将值赋给变量 language。
Jen&#x27;s favorite language is Python.
Sarah&#x27;s favorite language is C.
Edward&#x27;s favorite language is Rust.
Phil&#x27;s favorite language is Python.
</code></pre>
</li>
<li>
<p>遍历字典中的所有键 ( keys() )</p>
<pre><code class="language-python">favorite_languages = {
    &#x27;jen&#x27;: &#x27;python&#x27;,
    &#x27;sarah&#x27;: &#x27;c&#x27;,
    &#x27;edward&#x27;: &#x27;rust&#x27;,
    &#x27;phil&#x27;: &#x27;python&#x27;,
    }
for name in favorite_languages.keys():
    print(name.title())
# keys() ⽅法并⾮只能⽤于遍历：实际上，它会返回⼀个列表，其中包含字典中的所有键。
if &#x27;erin&#x27; not in favorite_languages.keys():
    print(&quot;Erin, please take our poll!&quot;)
# 输出
Erin, please take our poll!
</code></pre>
</li>
<li>
<p>按特定的顺序遍历字典中的所有键 ( sorted() )</p>
<pre><code class="language-python">favorite_languages = {
      &#x27;jen&#x27;: &#x27;python&#x27;,
      &#x27;sarah&#x27;: &#x27;c&#x27;,
      &#x27;edward&#x27;: &#x27;rust&#x27;,
      &#x27;phil&#x27;: &#x27;python&#x27;,
      }
for name in sorted(favorite_languages.keys()):
    print(f&quot;{name.title()}, thank you for taking the poll.&quot;)
# 对⽅法 dictionary.keys() 的结果调⽤了 sorted() 函数。这让 Python 获取字典中的所有键，并在遍历前对这个列表进⾏排序。输出表明，按字⺟顺序显⽰了所有被调查者的名字：
Edward, thank you for taking the poll.
Jen, thank you for taking the poll.
Phil, thank you for taking the poll.
Sarah, thank you for taking the poll.
</code></pre>
</li>
<li>
<p>遍历字典中的所有值 ( values() ，set() )</p>
<pre><code class="language-python">favorite_languages = {
    &#x27;jen&#x27;: &#x27;python&#x27;,
    &#x27;sarah&#x27;: &#x27;c&#x27;,
    &#x27;edward&#x27;: &#x27;rust&#x27;,
    &#x27;phil&#x27;: &#x27;python&#x27;,
    }
for language in favorite_languages.values():
    print(language.title())
# 这条 for 语句提取字典中的每个值，并将它们依次赋给变量 language。
Python
C
Rust
Python
# 这种做法提取字典中所有的值，⽽没有考虑值是否有重复。这种做法提取字典中所有的值，⽽没有考虑值是否有重复。
for language in set(favorite_languages.values()):
    print(language.title())
# 通过将包含重复元素的列表传⼊ set()，可让 Python 找出列表中独⼀⽆⼆的元素，并使⽤这些元素来创建⼀个集合。
Python
C
Rust
</code></pre>
<ul>
<li>
<p>注意：可以使⽤⼀对花括号直接创建集合，并在其中⽤逗号分隔元素：</p>
<pre><code class="language-python">&gt;&gt;&gt; languages = {&#x27;python&#x27;, &#x27;rust&#x27;, &#x27;python&#x27;, &#x27;c&#x27;}
&gt;&gt;&gt; languages
{&#x27;rust&#x27;, &#x27;python&#x27;, &#x27;c&#x27;}
</code></pre>
</li>
<li>
<p>集合和字典很容易混淆，因为它们都是⽤⼀对花括号定义的。当花括号内没有键值对时，定义的很可能是集合。</p>
</li>
<li>
<p>不同于列表和字典，集合不会以特定的顺序存储元素（集合本质上是无序的）。</p>
</li>
</ul>
</li>
</ul>
<h3>嵌套</h3>
<ul>
<li>
<p>字典列表</p>
<pre><code class="language-python"># 创建⼀个⽤于存储外星⼈的空列表
aliens = []
# 创建 30 个绿⾊的外星⼈
# range() 函数返回⼀个数字序列，告诉 Python 要重复这个循环多少次。
for alien_number in range(30):
    new_alien = {&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5, &#x27;speed&#x27;: &#x27;slow&#x27;}
    aliens.append(new_alien)
# 使⽤⼀个切⽚来打印前 5 个外星⼈。
for alien in aliens[:5]:
    print(alien)
# 显⽰创建了多少个外星⼈
print(f&quot;Total number of aliens: {len(aliens)}&quot;)
</code></pre>
</li>
<li>
<p>在字典中存储列表  </p>
<p>每当需要在字典中将⼀个键关联到多个值时，都可以在字典中嵌套⼀个列表。</p>
<pre><code class="language-python"># 在这⾥，与每个名字关联的值都是⼀个列表。请注意，有些⼈喜欢的语⾔只有⼀种，⽽有些⼈喜欢的不⽌⼀种。
favorite_languages = {
    &#x27;jen&#x27;: [&#x27;python&#x27;, &#x27;rust&#x27;],
    &#x27;sarah&#x27;: [&#x27;c&#x27;],
    &#x27;edward&#x27;: [&#x27;rust&#x27;, &#x27;go&#x27;],
    &#x27;phil&#x27;: [&#x27;python&#x27;, &#x27;haskell&#x27;],
    }
for name, languages in favorite_languages.items():
    print(f&quot;\n{name.title()}&#x27;s favorite languages are:&quot;)
    for language in languages:
        print(f&quot;\t{language.title()}&quot;)
# 注意：列表和字典的嵌套层级不应太多。
</code></pre>
</li>
<li>
<p>在字典中存储字典</p>
<pre><code class="language-python">users = {
    &#x27;aeinstein&#x27;: {
        &#x27;first&#x27;: &#x27;albert&#x27;,
        &#x27;last&#x27;: &#x27;einstein&#x27;,
        &#x27;location&#x27;: &#x27;princeton&#x27;,
        },
    &#x27;mcurie&#x27;: {
        &#x27;first&#x27;: &#x27;marie&#x27;,
        &#x27;last&#x27;: &#x27;curie&#x27;,
        &#x27;location&#x27;: &#x27;paris&#x27;,
        },
    }
for username, user_info in users.items():
    print(f&quot;\nUsername: {username}&quot;)
    full_name = f&quot;{user_info[&#x27;first&#x27;]} {user_info[&#x27;last&#x27;]}&quot;
    location = user_info[&#x27;location&#x27;]
    print(f&quot;\tFull name: {full_name.title()}&quot;)
    print(f&quot;\tLocation: {location.title()}&quot;)
# 输出

Username: aeinstein
    Full name: Albert Einstein
    Location: Princeton

Username: mcurie
    Full name: Marie Curie
    Location: Paris
# ⾸先定义⼀个名为 users 的字典，其中包含两个键：⽤户名&#x27;aeinstein&#x27; 和 &#x27;mcurie&#x27;。与每个键关联的值都是⼀个字典，其中包含⽤户的名、姓和居住地。然后，遍历字典 users，让 Python 依次将每个键赋给变量 username，并依次将与当前键相关联的字典赋给变量 user_info。在循环内部，将⽤户名打印出来了。接下来，开始访问内部的字典。变量user_info 包含⽤户信息字典，⽽该字典包含三个键：&#x27;first&#x27;、&#x27;last&#x27; 和 &#x27;location&#x27;。对于每个⽤户，都使⽤这些键来⽣成整洁的姓名和居住地，然后打印有关⽤户的简要信息
</code></pre>
</li>
</ul>
<h2>7 ⽤户输⼊和 while 循环</h2>
<h3>使⽤ input() 来让⽤户提供信息</h3>
<ul>
<li>
<p>input() 函数让程序暂停运⾏，等待⽤户输⼊⼀些⽂本。获取⽤户输⼊后，Python 将其赋给⼀个变量，以便使⽤。</p>
<pre><code class="language-python">message = input(&quot;Tell me something, and I will repeat it back to you: &quot;)
print(message)
# input() 函数接受⼀个参数，即要向⽤户显⽰的提⽰（prompt），让⽤户知道该输⼊什么样的信息。
</code></pre>
</li>
<li>
<p>使⽤ int() 来获取数值输⼊（如何处理⽂本和数的输⼊）</p>
<p>在使⽤ input() 函数时，Python 会将⽤户输⼊解读为字符串。<br />
在将数值输⼊⽤于计算和⽐较前，务必将其转换为数值表⽰。</p>
<pre><code class="language-python">height = input(&quot;How tall are you, in inches? &quot;)
height = int(height)
if height &gt;= 48:
 print(&quot;\nYou&#x27;re tall enough to ride!&quot;)
else:
 print(&quot;\nYou&#x27;ll be able to ride when you&#x27;re a little older.&quot;)
# 在⽐较前，height = int(height) 将输⼊转换成了数值表⽰。
# 如果输⼊的数⼤于或等于 48，就指出⽤户满⾜⾝⾼条件：
How tall are you, in inches? 71
You&#x27;re tall enough to ride!
</code></pre>
</li>
<li>
<p>求模运算符 ( % )  </p>
<p>它将两个数相除并返回余数。求模运算符不会指出⼀个数是另⼀个数的多少倍，只指出余数是多少。</p>
<pre><code class="language-python">&gt;&gt;&gt; 4 % 3
1
&gt;&gt;&gt; 5 % 3
2
&gt;&gt;&gt; 6 % 3
0
&gt;&gt;&gt; 7 % 3
1
</code></pre>
<p>如果⼀个数可被另⼀个数整除，余数就为 0，因此求模运算将返回 0。可利⽤这⼀点来判断⼀个数是奇数还是偶数：</p>
<pre><code class="language-python">number = input(&quot;Enter a number, and I&#x27;ll tell you if it&#x27;s even or odd: &quot;)
number = int(number)
if number % 2 == 0:
    print(f&quot;\nThe number {number} is even.&quot;)
else:
    print(f&quot;\nThe number {number} is odd.&quot;)

</code></pre>
</li>
</ul>
<h3>控制 while 循环流程的⽅式</h3>
<ul>
<li>
<p>使⽤标志（flag）</p>
<p><strong>注意：python 中 True 和 False 要开头大写</strong></p>
<pre><code class="language-python"># 这个变量称为标志（flag），充当程序的交通信号灯。可以让程序在标志为 True 时继续运⾏，并在任何事件导致标志的值为 False 时让程序停⽌运⾏。
prompt = &quot;\nTell me something, and I will repeat it back to you:&quot;
prompt += &quot;\nEnter &#x27;quit&#x27; to end the program. &quot;
active = True
while active:
    message = input(prompt)
    if message == &#x27;quit&#x27;:
        active = False
    else:
        print(message)
</code></pre>
</li>
<li>
<p>使⽤ break 退出循环</p>
<pre><code class="language-python"># 在所有 Python 循环中都可使⽤ break 语句。例如，可使⽤break 语句来退出遍历列表或字典的 for 循环。
prompt = &quot;\nPlease enter the name of a city you have visited:&quot;
prompt += &quot;\n(Enter &#x27;quit&#x27; when you are finished.) &quot;
while True:
    city = input(prompt)
    if city == &#x27;quit&#x27;:
        break
    else:
        print(f&quot;I&#x27;d love to go to {city.title()}!&quot;)

</code></pre>
</li>
<li>
<p>在循环中使⽤ continue</p>
<pre><code class="language-python"># 执⾏ continue 语句，让 Python 忽略余下的代码，并返回循环的开头。
# 打印1-10奇数
current_number = 0
while current_number &lt; 10:
    current_number += 1
    if current_number % 2 == 0:
        continue
    print(current_number)
</code></pre>
</li>
</ul>
<h3>使⽤ while 循环处理列表和字典</h3>
<ul>
<li>
<p>for 循环是⼀种遍历列表的有效⽅式，但不应该在 for 循环中修改列表，否则将导致 Python 难以跟踪其中的元素。要在遍历列表的同时修改它，可使⽤ while 循环。</p>
<pre><code class="language-python"># 错误操作一
a = [1, 2, 4, 4, 5]
for i, v in enumerate(a):
    if v == 4:
        del a[i]
# 结果为 
a = [1, 2, 4, 5]
# 这是因为 Python 的 for 循环存在自动填充，即在循环中自动填充列表中的下一个元素，如果在循环中修改列表的值，可能会引发错误。
# 由于在遍历的过程中，删除了其中一个元素，导致后面的元素整体前移，导致有个元素成了漏网之鱼。
a  0 1 2 3 4   --&gt;     0 1 2 3
   1 2 4 4 5   --&gt;     1 2 4 5
</code></pre>
<pre><code class="language-python"># 错误操作二
a = [1, 2, 4, 4, 5]
for i in range(len(a)):
    if a[i] == 4:
        del a[i]
# 直接报错
IndexError: list index out of range
i 最大取值为4，但删除操作后的列表长度为4，最大下标为3，所以报错 list index out of range
</code></pre>
<pre><code class="language-python"># 正确操作
a = [1, 2, 4, 4, 5]
i = 0
while i &lt; len(a):
    if a[i] == 4:
        del a[i]
    else:
        i += 1
</code></pre>
</li>
<li>
<p>在列表之间移动元素</p>
<pre><code class="language-python"># ⾸先，创建⼀个待验证⽤户列表
# 和⼀个⽤于存储已验证⽤户的空列表
unconfirmed_users = [&#x27;alice&#x27;, &#x27;brian&#x27;, &#x27;candace&#x27;]
confirmed_users = []
# 验证每个⽤户，直到没有未验证⽤户为⽌
# 将每个经过验证的⽤户都移到已验证⽤户列表中
# while 循环将不断地运⾏，直到列表 unconfirmed_users 变成空的。
while unconfirmed_users:
    current_user = unconfirmed_users.pop()
    print(f&quot;Verifying user: {current_user.title()}&quot;)
    confirmed_users.append(current_user)
# 显⽰所有的已验证⽤户
print(&quot;\nThe following users have been confirmed:&quot;)
for confirmed_user in confirmed_users:
    print(confirmed_user.title())
# 输出
Verifying user: Candace
Verifying user: Brian
Verifying user: Alice
The following users have been confirmed:
Candace
Brian
Alice
</code></pre>
</li>
<li>
<p>删除为特定值的所有列表元素</p>
<pre><code class="language-python">pets = [&#x27;dog&#x27;, &#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;goldfish&#x27;, &#x27;cat&#x27;, &#x27;rabbit&#x27;, &#x27;cat&#x27;]
print(pets)
while &#x27;cat&#x27; in pets:
    pets.remove(&#x27;cat&#x27;)
print(pets)
# 输出
[&#x27;dog&#x27;, &#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;goldfish&#x27;, &#x27;cat&#x27;, &#x27;rabbit&#x27;, &#x27;cat&#x27;]
[&#x27;dog&#x27;, &#x27;dog&#x27;, &#x27;goldfish&#x27;, &#x27;rabbit&#x27;]
</code></pre>
</li>
<li>
<p>使⽤⽤户输⼊填充字典</p>
<pre><code class="language-python"># 可以使⽤ while 循环提⽰⽤户输⼊任意多的信息。下⾯创建⼀个调查程序，其中的循环在每次执⾏时都提⽰输⼊被调查者的名字和回答。我们将收集到的数据存储在⼀个字典中，以便将回答与被调查者关联起来：
responses = {}
# 设置⼀个标志，指出调查是否继续
polling_active = True
while polling_active:
    # 提⽰输⼊被调查者的名字和回答
    name = input(&quot;\nWhat is your name? &quot;)
    response = input(&quot;Which mountain would you like to climb someday? &quot;)
    # 将回答存储在字典中
    responses[name] = response
    # 看看是否还有⼈要参与调查
    repeat = input(&quot;Would you like to let another person respond? (yes/no) &quot;)
    if repeat == &#x27;no&#x27;:
        polling_active = False
# 调查结束，显⽰结果
print(&quot;\n--- Poll Results ---&quot;)
for name, response in responses.items():
    print(f&quot;{name} would like to climb {response}.&quot;)
# 输出

What is your name? Eric
Which mountain would you like to climb someday? Denali
Would you like to let another person respond? (yes/no) yes
What is your name? Lynn
Which mountain would you like to climb someday? Devil&#x27;s Thumb
Would you like to let another person respond? (yes/no) no
--- Poll Results ---
Eric would like to climb Denali.
Lynn would like to climb Devil&#x27;s Thumb.
</code></pre>
</li>
</ul>
<h2>8 函数</h2>
<h3>定义函数、实参形参</h3>
<ul>
<li>
<p>函数（function）是带名字的代码块，⽤于完成具体的⼯作。要执⾏函数定义的特定任务，可调⽤（call）该函数。</p>
</li>
<li>
<p>使⽤关键字 def 定义函数。这是函数定义，向 Python 指出了函数名，还可以在括号内指出函数为完成任务需要什么样的信息。最后，定义以冒号结尾。</p>
</li>
<li>
<p>紧跟在 def greet_user(): 后⾯的所有缩进⾏构成了函数体。第⼆⾏的⽂本是称为⽂档字符串（docstring）的注释，描述了函数是做什么的。Python 在为程序中的函数⽣成⽂档时，会查找紧跟在函数定义后的字符串。这些字符串通常前后分别⽤三个双引号引起，能够包含多⾏。</p>
</li>
<li>
<p>函数调⽤让 Python 执⾏函数中的代码。要调⽤函数，可依次指定函数名以及⽤括号括起的必要信息。</p>
<pre><code class="language-python">def greet_user(username):
    &quot;&quot;&quot;显⽰简单的问候语&quot;&quot;&quot;
    print(f&quot;Hello, {username.title()}!&quot;)
greet_user(&#x27;jesse&#x27;)
# 输出
Hello, Jesse!
</code></pre>
</li>
<li>
<p>在 greet_user() 函数的定义中，变量 username 是⼀个形参（parameter），即函数完成⼯作所需的信息。在代码greet_user('jesse') 中，值 'jesse' 是⼀个实参（argument），即在调⽤函数时传递给函数的信息。</p>
</li>
</ul>
<h3>如何传递实参</h3>
<ul>
<li>
<p>位置实参</p>
<pre><code class="language-python">def describe_pet(animal_type, pet_name):
    &quot;&quot;&quot;显⽰宠物的信息&quot;&quot;&quot;
    print(f&quot;\nI have a {animal_type}.&quot;)
    print(f&quot;My {animal_type}&#x27;s name is {pet_name. title()}.&quot;)
describe_pet(&#x27;hamster&#x27;, &#x27;harry&#x27;)
describe_pet(&#x27;dog&#x27;, &#x27;willie&#x27;)
# 位置实参的顺序很重要
</code></pre>
</li>
<li>
<p>关键字实参</p>
<pre><code class="language-python">def describe_pet(animal_type, pet_name):
    &quot;&quot;&quot;显⽰宠物的信息&quot;&quot;&quot;
    print(f&quot;\nI have a {animal_type}.&quot;)
    print(f&quot;My {animal_type}&#x27;s name is {pet_name.title()}.&quot;)
# 下⾯两个函数调⽤是等效的 
describe_pet(animal_type=&#x27;hamster&#x27;, pet_name=&#x27;harry&#x27;)
describe_pet(pet_name=&#x27;harry&#x27;, animal_type=&#x27;hamster&#x27;)
# 注意：在使⽤关键字实参时，务必准确地指定函数定义中的形参名。
</code></pre>
</li>
<li>
<p>默认值</p>
<p>在编写函数时，可以给每个形参指定默认值。如果在调⽤函数中给形参提供了实参，Python 将使⽤指定的实参值；否则，将使⽤形参的默认值。因此，给形参指定默认值后，可在函数调⽤中省略相应的实参。使⽤默认值不仅能简化函数调⽤，还能清楚地指出函数的典型⽤法。</p>
<pre><code class="language-python">def describe_pet(pet_name, animal_type=&#x27;dog&#x27;):
 &quot;&quot;&quot;显⽰宠物的信息&quot;&quot;&quot;
 print(f&quot;\nI have a {animal_type}.&quot;)
 print(f&quot;My {animal_type}&#x27;s name is {pet_name.title()}.&quot;)
describe_pet(pet_name=&#x27;willie&#x27;)
describe_pet(&#x27;willie&#x27;)
describe_pet(pet_name=&#x27;harry&#x27;, animal_type=&#x27;hamster&#x27;)
</code></pre>
<p>注意：当使⽤默认值时，必须在形参列表中先列出没有默认值的形参，再列出有默认值的形参。这让 Python 依然能够正确地解读位置实参。</p>
</li>
<li>
<p>等效的函数调⽤</p>
<pre><code class="language-python">def describe_pet(pet_name, animal_type=&#x27;dog&#x27;):
# 下⾯对这个函数的所有调⽤都可⾏：

# ⼀条名为 Willie 的⼩狗
describe_pet(&#x27;willie&#x27;)
describe_pet(pet_name=&#x27;willie&#x27;)
# ⼀只名为 Harry 的仓⿏
describe_pet(&#x27;harry&#x27;, &#x27;hamster&#x27;)
describe_pet(pet_name=&#x27;harry&#x27;, animal_type=&#x27;hamster&#x27;)
describe_pet(animal_type=&#x27;hamster&#x27;, pet_name=&#x27;harry&#x27;)
</code></pre>
</li>
</ul>
<h3>返回值</h3>
<ul>
<li>
<p>返回简单的值</p>
<pre><code class="language-python">def get_formatted_name(first_name, last_name):
    &quot;&quot;&quot;返回标准格式的姓名&quot;&quot;&quot;
    full_name = f&quot;{first_name} {last_name}&quot;
    return full_name.title()
musician = get_formatted_name(&#x27;jimi&#x27;, &#x27;hendrix&#x27;)
print(musician)
</code></pre>
</li>
<li>
<p>让实参变成可选的</p>
<p>可以使⽤默认值来让实参变成可选的。</p>
<pre><code class="language-python">def get_formatted_name(first_name, last_name, middle_name=&#x27;&#x27;):
    &quot;&quot;&quot;返回标准格式的姓名&quot;&quot;&quot;
    if middle_name:  # Python 将⾮空字符串解读为 True
        full_name = f&quot;{first_name} {middle_name} {last_name}&quot;
    else:
        full_name = f&quot;{first_name} {last_name}&quot;
    return full_name.title()

musician = get_formatted_name(&#x27;jimi&#x27;, &#x27;hendrix&#x27;)
print(musician)
musician = get_formatted_name(&#x27;john&#x27;, &#x27;hooker&#x27;, &#x27;lee&#x27;)
print(musician)
</code></pre>
</li>
<li>
<p>返回字典</p>
<pre><code class="language-python">def build_person(first_name, last_name, age=None):
    &quot;&quot;&quot;返回⼀个字典，其中包含有关⼀个⼈的信息&quot;&quot;&quot;
    person = {&#x27;first&#x27;: first_name, &#x27;last&#x27;: last_name}
    if age:
        person[&#x27;age&#x27;] = age
    return person

musician = build_person(&#x27;jimi&#x27;, &#x27;hendrix&#x27;, age=27)
print(musician)
</code></pre>
<ul>
<li>在函数定义中，新增了⼀个可选形参 age，其默认值被设置为特殊值 None（表⽰变量没有值）。可将 None 视为占位值。在条件测试中，None 相当于 False.</li>
</ul>
</li>
</ul>
<h3>传递列表</h3>
<ul>
<li>
<p>在函数中修改列表</p>
<pre><code class="language-python">def print_models(unprinted_designs, completed_models):
    &quot;&quot;&quot;
    模拟打印每个设计，直到没有未打印的设计为⽌
    打印每个设计后，都将其移到列表 completed_models 中
    &quot;&quot;&quot;
    while unprinted_designs:
        current_design = unprinted_designs.pop()
        print(f&quot;Printing model: {current_design}&quot;)
        completed_models.append(current_design)

def show_completed_models(completed_models):
    &quot;&quot;&quot;显⽰打印好的所有模型&quot;&quot;&quot;
    print(&quot;\nThe following models have been printed:&quot;)
    for completed_model in completed_models:
        print(completed_model)

unprinted_designs = [&#x27;phone case&#x27;, &#x27;robot pendant&#x27;, &#x27;dodecahedron&#x27;]
completed_models = []

print_models(unprinted_designs, completed_models)
show_completed_models(completed_models)
</code></pre>
</li>
<li>
<p>禁⽌函数修改列表（ 切片 [ : ] ）</p>
<p>有时候，需要禁⽌函数修改列表。可向函数传递列表的副本⽽不是原始列表。这样，函数所做的任何修改都只影响副本，⽽丝毫不影响原始列表。</p>
<pre><code class="language-python"># 要将列表的副本传递给函数，可以像下⾯这样做：
function_name(list_name[:])
# 切⽚表⽰法 [:] 创建列表的副本。
print_models(unprinted_designs[:], completed_models)
# 在上面的例子中，如果不想清空未打印的设计列表，可像下⾯这样调⽤ print_models()
</code></pre>
<p>虽然向函数传递列表的副本可保留原始列表的内容，但除⾮有充分的理由，否则还是应该将原始列表传递给函数。这是因为，让函数使⽤现成的列表可避免花时间和内存创建副本，从⽽提⾼效率，在处理⼤型列表时尤其如此。</p>
</li>
</ul>
<h3>传递任意数量的实参 （*形参 / **形参）</h3>
<pre><code class="language-python"># 下⾯的函数只有⼀个形参 *toppings，不管调⽤语句提供了多少实参，这个形参都会将其收⼊囊中。
def make_pizza(*toppings):
    &quot;&quot;&quot;打印顾客点的所有配料&quot;&quot;&quot;
    print(toppings)
make_pizza(&#x27;pepperoni&#x27;)
make_pizza(&#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)
# 形参名 *toppings 中的星号让 Python 创建⼀个名为 toppings 的元组，该元组包含函数收到的所有值。

</code></pre>
<ul>
<li>
<p>结合使⽤位置实参和任意数量的实参  </p>
<p>如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python 先匹配位置实参和关键字实参，再将余下的实参都收集到最后⼀个形参中。</p>
<pre><code class="language-python">def make_pizza(size, *toppings):
    &quot;&quot;&quot;概述要制作的⽐萨&quot;&quot;&quot;
    print(f&quot;\nMaking a {size}-inch pizza with the following toppings:&quot;)
    for topping in toppings:
        print(f&quot;- {topping}&quot;)

make_pizza(16, &#x27;pepperoni&#x27;)
make_pizza(12, &#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)
</code></pre>
<p>注意：你经常会看到通⽤形参名 *args，它也这样收集任意数量的位置实参。</p>
</li>
<li>
<p>使⽤任意数量的关键字实参</p>
<pre><code class="language-python">def build_profile(first, last, **user_info):
    &quot;&quot;&quot;创建⼀个字典，其中包含我们知道的有关⽤户的⼀切&quot;&quot;&quot;
  ❶ user_info[&#x27;first_name&#x27;] = first
    user_info[&#x27;last_name&#x27;] = last
    return user_info
user_profile = build_profile(&#x27;albert&#x27;, &#x27;einstein&#x27;,
                             location=&#x27;princeton&#x27;,
                             field=&#x27;physics&#x27;)
print(user_profile)
# 输出
{&#x27;location&#x27;: &#x27;princeton&#x27;, &#x27;field&#x27;: &#x27;physics&#x27;,
&#x27;first_name&#x27;: &#x27;albert&#x27;, &#x27;last_name&#x27;: &#x27;einstein&#x27;}
</code></pre>
<p>你需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键值对——调⽤语句提供了多少就接受多少。  </p>
<p>形参 **user_info 中的两个星号让 Python 创建⼀个名为 user_info 的字典，该字典包含函数收到的其他所有名对。</p>
<p>注意：你经常会看到形参名 **kwargs，它⽤于收集任意数量的关键字实参。</p>
</li>
</ul>
<h3>将函数存储在模块中，再将模块导⼊主程序</h3>
<ul>
<li>
<p>导⼊整个模块  </p>
<p>只需编写⼀条 import 语句并在其中指定模块名，就可在程序中使⽤该模块中的所有函数。如果使⽤这种 import 语句导⼊了名为 module_name.py 的整个模块，就可使⽤下⾯的语法来使⽤其中的任意⼀个函数。</p>
<pre><code class="language-python">import module_name
module_name.function_name()
</code></pre>
<p>要让函数是可导⼊的，得先创建模块。模块是扩展名为 .py 的⽂件，包含要导⼊程序的代码。下⾯来创建⼀个包含 make_pizza() 函数的模块。</p>
<p>pizza.py</p>
<pre><code class="language-python">def make_pizza(size, *toppings):
    &quot;&quot;&quot;概述要制作的⽐萨&quot;&quot;&quot;
    print(f&quot;\nMaking a {size}-inch pizza with the following toppings:&quot;)
    for topping in toppings:
        print(f&quot;- {topping}&quot;)
</code></pre>
<p>making_pizzas.py</p>
<pre><code class="language-python">import pizza

pizza.make_pizza(16, &#x27;pepperoni&#x27;)
pizza.make_pizza(12, &#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)

</code></pre>
<p>当 Python 读取这个⽂件时，代码⾏ import pizza 会让 Python 打开⽂件pizza.py，并将其中的所有函数都复制到这个程序中。</p>
</li>
<li>
<p>导⼊模块中的特定函数</p>
<pre><code class="language-python">from module_name import function_name
</code></pre>
<p>⽤逗号分隔函数名，可根据需要从模块中导⼊任意数量的函数：</p>
<pre><code class="language-python">from module_name import function_0, function_1, function_2
</code></pre>
<pre><code class="language-python">from pizza import make_pizza
make_pizza(16, &#x27;pepperoni&#x27;)
make_pizza(12, &#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)
</code></pre>
<p>如果使⽤这种语法，在调⽤函数时则⽆须使⽤句点。由于在 import 语句中显式地导⼊了 make_pizza() 函数，因此在调⽤时只需指定其名称即可。</p>
</li>
<li>
<p>使⽤ as 给函数指定别名（alias）</p>
<pre><code class="language-python">from module_name import function_name as fn
</code></pre>
<p>如果要导⼊的函数的名称太⻓或者可能与程序中既有的名称冲突，可指定简短⽽独⼀⽆⼆的别名。</p>
<pre><code class="language-python">from pizza import make_pizza as mp
mp(16, &#x27;pepperoni&#x27;)
mp(12, &#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)
</code></pre>
</li>
<li>
<p>使⽤ as 给模块指定别名</p>
<pre><code class="language-python">import module_name as mn
</code></pre>
<pre><code class="language-python">import pizza as p
p.make_pizza(16, &#x27;pepperoni&#x27;)
p.make_pizza(12, &#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)
</code></pre>
</li>
<li>
<p>导⼊模块中的所有函数（ * ）</p>
<pre><code class="language-python">from pizza import *
make_pizza(16, &#x27;pepperoni&#x27;)
make_pizza(12, &#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)
</code></pre>
<p>import 语句中的星号让 Python 将模块 pizza 中的每个函数都复制到这个程序⽂件中。由于导⼊了每个函数，可通过名称来调⽤每个函数，⽆须使⽤点号（dot notation）。<br />
最好不要用这种发放导入。最佳的做法是，要么只导⼊需要使⽤的函数，要么导⼊整个模块并使⽤点号。</p>
</li>
</ul>
<h3>函数编写指南</h3>
<ul>
<li>
<p>应给函数指定描述性名称，且只使⽤⼩写字⺟和下划线。。在给模块命名时也应遵循上述约定。</p>
</li>
<li>
<p>每个函数都应包含简要阐述其功能的注释。该注释应紧跟在函数定义后⾯，并采⽤⽂档字符串的格式。</p>
</li>
<li>
<p>在给形参指定默认值时，等号两边不要有空格：</p>
<pre><code class="language-python">def function_name(parameter_0, parameter_1=&#x27;default value&#x27;)

</code></pre>
</li>
<li>
<p>函数调⽤中的关键字实参也应遵循这种约定：</p>
<pre><code class="language-python">function_name(value_0, parameter_1=&#x27;value&#x27;)
</code></pre>
</li>
<li>
<p>如果形参很多，导致函数定义的⻓度超过了 79 个
字符，可在函数定义中输⼊左括号后按回⻋键，并在下⼀⾏连按两次制表符键，从⽽将形参列表和只缩进⼀层的函数体区分开来。</p>
<pre><code class="language-python">def function_name(
        parameter_0, parameter_1, parameter_2,
        parameter_3, parameter_4, parameter_5):
    function body...
</code></pre>
</li>
<li>
<p>如果程序或模块包含多个函数，可使⽤两个空⾏将相邻的函数分开。</p>
</li>
<li>
<p>所有的 import 语句都应放在⽂件开头。</p>
</li>
</ul>
<h2>9 类</h2>
<h3>创建和使⽤类创建实例</h3>
<pre><code class="language-python"># 使⽤属性在类中存储信息，编写⽅法让类具备所需的⾏为
class Dog:
    &quot;&quot;&quot;⼀次模拟⼩狗的简单尝试&quot;&quot;&quot;
    def __init__(self, name, age):
    &quot;&quot;&quot;初始化属性 name 和 age&quot;&quot;&quot;
        self.name = name
        self.age = age
    def sit(self):
    &quot;&quot;&quot;模拟⼩狗收到命令时坐下&quot;&quot;&quot;
        print(f&quot;{self.name} is now sitting.&quot;)
    def roll_over(self):
    &quot;&quot;&quot;模拟⼩狗收到命令时打滚&quot;&quot;&quot;
        print(f&quot;{self.name} rolled over!&quot;)

# 创建实例
my_dog = Dog(&#x27;Willie&#x27;, 6)
# 访问属性 my_dog.name
print(f&quot;My dog&#x27;s name is {my_dog.name}.&quot;)
print(f&quot;My dog is {my_dog.age} years old.&quot;)
# 调⽤⽅法
my_dog.sit()
my_dog.roll_over()
# 创建多个实例
my_dog = Dog(&#x27;Willie&#x27;, 6)
your_dog = Dog(&#x27;Lucy&#x27;, 3)
</code></pre>
<pre><code class="language-python">__init__() ⽅法  

1.  __init__() 是⼀个特殊⽅法，每当你根据 Dog 类创建新实例时，Python 都会⾃动运⾏它。  
2.  在这个⽅法的名称中，开头和末尾各有两个下划线。  
3.  这个⽅法的定义中，形参 self 必不可少，⽽且必须位于其他形参的前⾯。  
4.  当 Python 调⽤这个⽅法来创建 Dog 实例时，将⾃动传⼊实参 self。每个与实例相关联的⽅法调⽤都会⾃动传递实参 self，该实参是⼀个指向实例本⾝的引⽤，让实例能够访问类中的属性和⽅法。  
5.  在 __init__() ⽅法内定义的两个变量都有前缀 self 。以self 为前缀的变量可供类中的所有⽅法使⽤，可以通过类的任意实例来访问。像这样可通过实例访问的变量称为属性（attribute）。
</code></pre>
<h3>给类的属性指定默认值，修改实例的属性的值</h3>
<ul>
<li>
<p>给属性指定默认值</p>
<pre><code class="language-python"># 有些属性⽆须通过形参来定义，可以在 __init__() ⽅法中为其指定默认值
class Car:
    def __init__(self, make, model, year):
    &quot;&quot;&quot;初始化描述汽⻋的属性&quot;&quot;&quot;
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0
</code></pre>
</li>
<li>
<p>修改实例的属性的值</p>
<ul>
<li>
<p>直接修改属性的值</p>
<pre><code class="language-python">class Car:
    --snip--

my_new_car = Car(&#x27;audi&#x27;, &#x27;a4&#x27;, 2024)

my_new_car.odometer_reading = 23
</code></pre>
</li>
<li>
<p>通过⽅法修改属性的值</p>
<pre><code class="language-python">class Car:
    --snip--
    def update_odometer(self, mileage):
        &quot;&quot;&quot;将⾥程表读数设置为指定的值&quot;&quot;&quot;
        self.odometer_reading = mileage

my_new_car = Car(&#x27;audi&#x27;, &#x27;a4&#x27;, 2024)
my_new_car.update_odometer(23)
</code></pre>
</li>
<li>
<p>通过⽅法让属性的值递增</p>
<pre><code class="language-python">class Car:
    --snip--
    def update_odometer(self, mileage):
    --snip--
    def increment_odometer(self, miles):
        &quot;&quot;&quot;让⾥程表读数增加指定的量&quot;&quot;&quot;
        self.odometer_reading += miles
</code></pre>
</li>
</ul>
</li>
</ul>
<h3>继承</h3>
<p>当⼀个类继承（inheritance）另⼀个类时，将⾃动获得后者的所有属性和⽅法。原有的类称为⽗类（parent class），⽽新类称为⼦类（child class）。⼦类不仅继承了⽗类的所有属性和⽅法，还可定义⾃⼰的属性和⽅法</p>
<ul>
<li>
<p>⼦类的 init() ⽅法</p>
<pre><code class="language-python">class Car:
    &quot;&quot;&quot;⼀次模拟汽⻋的简单尝试&quot;&quot;&quot;

    def __init__(self, make, model, year):
        &quot;&quot;&quot;初始化描述汽⻋的属性&quot;&quot;&quot;
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_descriptive_name(self):
        &quot;&quot;&quot;返回格式规范的描述性名称&quot;&quot;&quot;
        long_name = f&quot;{self.year} {self.make} {self.model}&quot;
        return long_name.title()

    def read_odometer(self):
        &quot;&quot;&quot;打印⼀个句⼦，指出汽⻋的⾏驶⾥程&quot;&quot;&quot;
        print(f&quot;This car has {self.odometer_reading} miles on it.&quot;)

    def update_odometer(self, mileage):
        &quot;&quot;&quot;将⾥程表读数设置为给定的值&quot;&quot;&quot;
        if mileage &gt;= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print(&quot;You can&#x27;t roll back an odometer!&quot;)

    def increment_odometer(self, miles):
        &quot;&quot;&quot;让⾥程表读数增加给定的量&quot;&quot;&quot;
        self.odometer_reading += miles

class ElectricCar(Car):
    &quot;&quot;&quot;电动汽⻋的独特之处&quot;&quot;&quot;

    def __init__(self, make, model, year):
        &quot;&quot;&quot;初始化⽗类的属性&quot;&quot;&quot;
        super().__init__(make, model, year)

my_leaf = ElectricCar(&#x27;nissan&#x27;, &#x27;leaf&#x27;, 2024)
print(my_leaf.get_descriptive_name()) 
</code></pre>
<ul>
<li>在创建⼦类时，⽗类必须包含在当前⽂件中，且位于⼦类前⾯。</li>
<li>定义⼦类 ElectricCar。在定义⼦类时，必须在括号内指定⽗类的名称。</li>
<li>super() 是⼀个特殊的函数，让你能够调⽤⽗类的⽅法.⽗类也称为超类（superclass）。</li>
</ul>
</li>
<li>
<p>给⼦类定义属性和⽅法</p>
<pre><code class="language-python"># 下⾯添加⼀个电动汽⻋特有的属性（电池）
class Car:
    --snip--

class ElectricCar(Car):
    &quot;&quot;&quot;电动汽⻋的独特之处&quot;&quot;&quot;
    def __init__(self, make, model, year):
        &quot;&quot;&quot;
        先初始化⽗类的属性，再初始化电动汽⻋特有的属性
        &quot;&quot;&quot;
        super().__init__(make, model, year)
        self.battery_size = 40

    def describe_battery(self):
        &quot;&quot;&quot;打印⼀条描述电池容量的消息&quot;&quot;&quot;
        print(f&quot;This car has a {self.battery_size}-kWh battery.&quot;)

my_leaf = ElectricCar(&#x27;nissan&#x27;, &#x27;leaf&#x27;, 2024)
print(my_leaf.get_descriptive_name())
my_leaf.describe_battery()
</code></pre>
</li>
<li>
<p>重写⽗类中的⽅法</p>
<ul>
<li>在⼦类中定义⼀个与要重写的⽗类⽅法同名的⽅法。这样，Python 将忽略这个⽗类⽅法，只关注你在⼦类中定义的相应⽅法。</li>
</ul>
</li>
<li>
<p>将⼀个类的实例⽤作另⼀个类的属性</p>
<pre><code class="language-python">class Car:
    --snip--

class Battery:
    &quot;&quot;&quot;⼀次模拟电动汽⻋电池的简单尝试&quot;&quot;&quot;
❶    def __init__(self, battery_size=40):
          &quot;&quot;&quot;初始化电池的属性&quot;&quot;&quot;
          self.battery_size = battery_size

❷     def describe_battery(self):
          &quot;&quot;&quot;打印⼀条描述电池容量的消息&quot;&quot;&quot;
          print(f&quot;This car has a {self.battery_size}-kWh battery.&quot;)

class ElectricCar(Car):
    &quot;&quot;&quot;电动汽⻋的独特之处&quot;&quot;&quot;
    def __init__(self, make, model, year):
        &quot;&quot;&quot;
        先初始化⽗类的属性，再初始化电动汽⻋特有的属性
        &quot;&quot;&quot;
        super().__init__(make, model, year)
❸       self.battery = Battery()

 my_leaf = ElectricCar(&#x27;nissan&#x27;, &#x27;leaf&#x27;, 2024)
 print(my_leaf.get_descriptive_name())
 my_leaf.battery.describe_battery()
</code></pre>
<ul>
<li>将⼤型类拆分成多个协同⼯作的⼩类，这种⽅法称为组合（composition）。</li>
<li>在 ElectricCar 类中，添加⼀个名为 self.battery 的属性（⻅❸）。这⾏代码让 Python 创建⼀个新的 Battery 实例（因为没有指定容量，所以为默认值 40），并将该实例赋给属性 self.battery。</li>
<li>每当__init__() ⽅法被调⽤时，都将执⾏该操作，因此现在每个ElectricCar 实例都包含⼀个⾃动创建的 Battery 实例。</li>
</ul>
<pre><code class="language-python">my_leaf.battery.describe_battery()
</code></pre>
<ul>
<li>这⾏代码让 Python 在实例 my_leaf 中查找属性 battery，并对存储在该属性中的 Battery 实例调⽤ describe_battery() ⽅法。</li>
</ul>
</li>
</ul>
<h3>导⼊类</h3>
<ul>
<li>
<p>导⼊单个类</p>
<p>my_car.py</p>
<pre><code class="language-python">from car import Car

my_new_car = Car(&#x27;audi&#x27;, &#x27;a4&#x27;, 2024)
print(my_new_car.get_descriptive_name())

my_new_car.odometer_reading = 23
my_new_car.read_odometer()
</code></pre>
</li>
<li>
<p>从⼀个模块中导⼊多个类  </p>
<p>在⼀个模块中能存储多个类，可根据需要导入所需的类。</p>
<pre><code class="language-python"> from car import Car, ElectricCar
</code></pre>
</li>
<li>
<p>导⼊整个模块  </p>
<p>还可以先导⼊整个模块，再使⽤点号访问需要的类。<br />
由于创建类实例的代码都包含模块名，因此不会与当前⽂件使⽤的任何名称发⽣冲突。</p>
<pre><code class="language-python">import car
# 使⽤语法module_name.classname 访问需要的类
my_mustang = car.Car(&#x27;ford&#x27;, &#x27;mustang&#x27;, 2024)
print(my_mustang.get_descriptive_name())

my_leaf = car.ElectricCar(&#x27;nissan&#x27;, &#x27;leaf&#x27;, 2024)
print(my_leaf.get_descriptive_name())
</code></pre>
</li>
<li>
<p>导⼊模块中的所有类</p>
<pre><code class="language-python"># 不推荐这种导⼊⽅式
from module_name import *
</code></pre>
</li>
<li>
<p>在⼀个模块中导⼊另⼀个模块</p>
<p>在将类存储在多个模块中时，你可能会发现⼀个模块中的类依赖于另⼀个模块中的类。在这种情况下，可在前⼀个模块中导⼊必要的类。</p>
<p>car.py</p>
<pre><code class="language-python">&quot;&quot;&quot;⼀个可⽤于表⽰汽⻋的类&quot;&quot;&quot;
class Car:
    --snip--
</code></pre>
<p>electric_car.py</p>
<pre><code class="language-python">&quot;&quot;&quot;⼀组可⽤于表⽰电动汽⻋的类&quot;&quot;&quot;
from car import Car
class Battery:
    --snip--
class ElectricCar(Car):
    --snip--
# ElectricCar 类需要访问其⽗类 Car，因此直接将 Car 类导⼊该模块。
</code></pre>
<p>my_cars.py</p>
<pre><code class="language-python">from car import Car
from electric_car import ElectricCar

my_mustang = Car(&#x27;ford&#x27;, &#x27;mustang&#x27;, 2024)
print(my_mustang.get_descriptive_name())

my_leaf = ElectricCar(&#x27;nissan&#x27;, &#x27;leaf&#x27;, 2024)
print(my_leaf.get_descriptive_name())
# 输出
2024 Ford Mustang
2024 Nissan Leaf
</code></pre>
</li>
<li>
<p>使⽤别名</p>
<pre><code class="language-python"># 给类指定别名。
from electric_car import ElectricCar as EC

my_leaf = EC(&#x27;nissan&#x27;, &#x27;leaf&#x27;, 2024)
</code></pre>
<pre><code class="language-python"># 给模块指定别名。
import electric_car as ec

my_leaf = ec.ElectricCar(&#x27;nissan&#x27;, &#x27;leaf&#x27;, 2024)
</code></pre>
</li>
</ul>
<h3>Python 标准库</h3>
<p>Python 标准库是⼀组模块，在安装 Python 时已经包含在内。你可以使⽤标准库中的任何函数和类，只需在程序开头添加⼀条简单的 import 语句即可。</p>
<h3>类的编程⻛格</h3>
<ul>
<li>类名应采⽤驼峰命名法，即将类名中的每个单词的⾸字⺟都⼤写，并且不使⽤下划线。</li>
<li>实例名和模块名都采⽤全⼩写格式，并在单词之间加上下划线。</li>
<li>在类中，可以使⽤⼀个空⾏来分隔⽅法；⽽在模块中，可以使⽤两个空⾏来分隔类。</li>
</ul>
<h2>10 ⽂件和异常</h2>
<h3>读取⽂件（ path对象 . read_text() ）</h3>
<pre><code class="language-python"># 读取⽂件的全部内容
from pathlib import Path

path = Path(&#x27;pi_digits.txt&#x27;)
contents = path.read_text()
print(contents)
# 相⽐于原始⽂件，该输出唯⼀不同的地⽅是末尾多了⼀个空⾏。因为 read_text() 在到达⽂件末尾时会返回⼀个空字符串，⽽这个空字符串会被显⽰为⼀个空⾏。
# 要删除这个多出来的空⾏，可对字符串变量 contents 调⽤ rstrip()：
contents = path.read_text().rstrip()
# 这⾏代码先让 Python 对当前处理的⽂件调⽤ read_text() ⽅法，再对read_text() 返回的字符串调⽤ rstrip() ⽅法，然后将整理好的字符串赋给变量 contents。这种做法称为⽅法链式调⽤（method chaining）
</code></pre>
<ul>
<li>
<p>相对⽂件路径让 Python 到相对于当前运⾏的程序所在⽬录的指定位置去查找。</p>
<pre><code class="language-python"># 由于⽂件夹 text_files 位于⽂件夹 python_work 中，因此需要创建⼀个以 text_files 打头并以⽂件名结尾的路径，如下所⽰：
path = Path(&#x27;text_files/filename.txt&#x27;)
# 绝对路径通常⽐相对路径⻓，因为它们以系统的根⽂件夹为起点
path = Path(&#x27;/home/eric/data_files/text_files/filename.txt&#x27;)
</code></pre>
</li>
<li>
<p>访问⽂件中的各⾏</p>
<p>使⽤ splitlines() ⽅法返回⼀个列表，其中包含⽂件中所有的⾏，再使⽤for 循环以每次⼀⾏的⽅式检查⽂件中的各⾏。</p>
<pre><code class="language-python">from pathlib import Path

path = Path(&#x27;pi_digits.txt&#x27;)
contents = path.read_text()
lines = contents.splitlines()
for line in lines:
    print(line)
</code></pre>
</li>
<li>
<p>使⽤⽂件的内容</p>
<pre><code class="language-python">from pathlib import Path

path = Path(&#x27;pi_digits.txt&#x27;)
contents = path.read_text()

lines = contents.splitlines()
pi_string = &#x27;&#x27;
for line in lines:
    pi_string += line

print(pi_string)
print(len(pi_string))
</code></pre>
<ul>
<li>注意：在读取⽂本⽂件时，Python 将其中的所有⽂本都解释为字符串。如果读取的是数，并且要将其作为数值使⽤，就必须使⽤ int()函数将其转换为整数，或者使⽤ float() 函数将其转换为浮点数。</li>
</ul>
</li>
</ul>
<h3>写⼊⽂件（ path对象 . write_text() ）</h3>
<ul>
<li>
<p>写⼊⼀⾏</p>
<pre><code class="language-python">from pathlib import Path
# write_text() ⽅法接受单个实参，即要写⼊⽂件的字符串。
path = Path(&#x27;programming.txt&#x27;)
path.write_text(&quot;I love programming.&quot;)
</code></pre>
<ul>
<li>注意：Python 只能将字符串写⼊⽂本⽂件。如果要将数值数据存储到⽂本⽂件中，必须先使⽤函数 str() 将其转换为字符串格式。</li>
</ul>
</li>
<li>
<p>写⼊多⾏</p>
<pre><code class="language-python">from pathlib import Path
# 可以通过添加空格、制表符和空⾏来设置输出的格式
contents = &quot;I love programming.\n&quot;
contents += &quot;I love creating new games.\n&quot;
contents += &quot;I also love working with data.\n&quot;

path = Path(&#x27;programming.txt&#x27;)
path.write_text(contents)

# 文本文件内容：
I love programming.
I love creating new games.
I also love working with data.
</code></pre>
<ul>
<li>注意：在对 path 对象调⽤ write_text() ⽅法时，务必谨慎。如果指定的⽂件已存在， write_text() 将删除其内容，并将指定的内容写⼊其中。本章后⾯将介绍如何使⽤ pathlib 检查指定的⽂件是否存在。</li>
</ul>
</li>
</ul>
<h3>异常</h3>
<ul>
<li>
<p>Python 使⽤称为异常（exception）的特殊对象来管理程序执⾏期间发⽣的错误。</p>
</li>
<li>
<p>每当发⽣让 Python 不知所措的错误时，它都会创建⼀个异常对象。如果你编写了处理该异常的代码，程序将继续运⾏；如果你未对异常进⾏处理，程序将停⽌，并显⽰⼀个 traceback，其中包含有关异常的报告。</p>
</li>
<li>
<p>异常是使⽤ try-except 代码块处理的。</p>
</li>
<li>
<p>try-except 代码块让 Python执⾏指定的操作，同时告诉 Python 在发⽣异常时应该怎么办。在使⽤try-except 代码块时，即便出现异常，程序也将继续运⾏：显⽰你编写的友好的错误消息，⽽不是令⽤户迷惑的 traceback。</p>
</li>
</ul>
<h4>使⽤ try-except 代码块</h4>
<p>只有可能引发异常的代码才需要放在 try 语句中。except 代码块告诉 Python，如果在尝试运⾏ try 代码块中的代码时引发了指定的异常该怎么办。</p>
<pre><code class="language-python">try:
    print(5/0)
except ZeroDivisionError:
    print(&quot;You can&#x27;t divide by zero!&quot;)
# 这⾥将导致错误的代码⾏ print(5/0) 放在⼀个 try 代码块中。
#如果 try 代码块中的代码运⾏起来没有问题，Python 将跳过 except 代码块；
#如果try 代码块中的代码导致错误，Python 将查找与之匹配的 except 代码块并运⾏其中的代码。
</code></pre>
<h4>else 代码块</h4>
<p>只有 try代码块成功执⾏才需要继续执⾏的代码，都应放到 else 代码块中。</p>
<pre><code class="language-python">--snip--
while True:
    --snip--
    if second_number == &#x27;q&#x27;:
        break
    try:
        answer = int(first_number) / int(second_number)
    except ZeroDivisionError:
        print(&quot;You can&#x27;t divide by 0!&quot;)
    else:
        print(answer)
</code></pre>
<ul>
<li>
<p>静默失败 （ pass ）</p>
<p>出现异常时，虽然仍将执⾏except 代码块中的代码，但什么都不会发⽣。。当这种错误发⽣时，既不会出现 traceback，也没有任何输出。</p>
<pre><code class="language-python">def count_words(path):
    &quot;&quot;&quot;计算⼀个⽂件⼤致包含多少个单词&quot;&quot;&quot;
    try:
        --snip--
    except FileNotFoundError:
        pass
    else:
        --snip--
</code></pre>
</li>
</ul>
<h4>常见的异常类型有</h4>
<ul>
<li>StopIteration - 迭代器没有更多的值</li>
<li>ImportError - 导入模块失败</li>
<li>IndexError - 序列中找不到给定的索引</li>
<li>KeyError - 映射中找不到给定的键</li>
<li>ValueError - 传入无效的参数</li>
<li>TypeError - 对类型无效的操作</li>
<li>FileNotFoundError - 未找到文件</li>
<li>KeyboardInterrupt - 用户中断执行</li>
</ul>
<h3>使⽤模块 json 来存储数据</h3>
<ul>
<li>
<p>模块 json 让你能够将简单的 Python 数据结构转换为 JSON 格式的字符串，并在程序再次运⾏时从⽂件中加载数据。</p>
</li>
<li>
<p>使⽤ json.dumps() 和 json.loads()</p>
<p>number_writer.py</p>
<pre><code class="language-python"># json.dumps() 函数接受⼀个实参，即要转换为 JSON 格式的数据。这个函数返回⼀个字符串，这样你就可将其写⼊数据⽂件了
from pathlib import Path
import json

numbers = [2, 3, 5, 7, 11, 13]

path = Path(&#x27;numbers.json&#x27;)
contents = json.dumps(numbers)
path.write_text(contents)
#输出
[2, 3, 5, 7, 11, 13]
</code></pre>
<p>number_reader.py</p>
</li>
</ul>
<pre><code class="language-python">from pathlib import Path
import json

path = Path(&#x27;numbers.json&#x27;)
contents = path.read_text()
numbers = json.loads(contents)

print(numbers)
#输出
[2, 3, 5, 7, 11, 13]
</code></pre>
<h3>重构</h3>
<p>remember_me.py</p>
<pre><code class="language-python">from pathlib import Path
import json

def greet_user():
    &quot;&quot;&quot;问候⽤户，并指出其名字&quot;&quot;&quot;
    path = Path(&#x27;username.json&#x27;)
    if path.exists():
        contents = path.read_text()
        username = json.loads(contents)
        print(f&quot;Welcome back, {username}!&quot;)
    else:
        username = input(&quot;What is your name? &quot;)
        contents = json.dumps(username)
        path.write_text(contents)
        print(f&quot;We&#x27;ll remember you when you come back, {username}!&quot;)

greet_user()
</code></pre>
<p>remember_me.py 最终版（每个函数都执⾏单⼀⽽清晰的任务）</p>
<pre><code class="language-python">from pathlib import Path
import json

def get_stored_username(path):
    &quot;&quot;&quot;如果存储了⽤户名，就获取它&quot;&quot;&quot;
    --snip--

def get_new_username(path):
    &quot;&quot;&quot;提⽰⽤户输⼊⽤户名&quot;&quot;&quot;
    username = input(&quot;What is your name? &quot;)
    contents = json.dumps(username)
    path.write_text(contents)
    return username

def greet_user():
    &quot;&quot;&quot;问候⽤户，并指出其名字&quot;&quot;&quot;
    path = Path(&#x27;username.json&#x27;)
    username = get_stored_username(path)
    if username:
        print(f&quot;Welcome back, {username}!&quot;)
    else:
        username = get_new_username(path)
        print(f&quot;We&#x27;ll remember you when you come back, {username}!&quot;)

 greet_user()
</code></pre>
<h2>11 使⽤ pytest 工具库测试代码</h2>
<h3>使⽤ pip 安装 pytest</h3>
<ul>
<li>
<p>更新 pip</p>
<pre><code class="language-python">python -m pip install --upgrade pip
# 这个命令的第⼀部分（python -m pip）让 Python 运⾏ pip 模块；
#第⼆部分（install --upgrade）让 pip 更新⼀个已安装的包；
#⽽最后⼀部分（pip）指定要更新哪个第三⽅包。
</code></pre>
<p>可使⽤下⾯的命令更新系统中安装的任何包：</p>
<pre><code class="language-python"> python -m pip install --upgrade package_name
</code></pre>
</li>
<li>
<p>安装 pytest</p>
<pre><code class="language-python">python -m pip install --user pytest
# --user 这个标志让 Python 只为当前⽤户安装指定的包。
</code></pre>
<p>可使⽤下⾯的命令安装众多的第三⽅包：</p>
<pre><code class="language-python"> python -m pip install --user package_name
</code></pre>
<p>注意：如果在执⾏这个命令时遇到⿇烦，可尝试在不指定标志 --user 的情况下再次执⾏它。</p>
</li>
</ul>
<h3>测试函数</h3>
<p>name_function.py</p>
<pre><code class="language-python">def get_formatted_name(first, last):
    &quot;&quot;&quot;⽣成格式规范的姓名&quot;&quot;&quot;
    full_name = f&quot;{first} {last}&quot;
    return full_name.title()
</code></pre>
<p>names.py</p>
<pre><code class="language-python">from name_function import get_formatted_name

print(&quot;Enter &#x27;q&#x27; at any time to quit.&quot;)
while True:
    first = input(&quot;\nPlease give me a first name: &quot;)
    if first == &#x27;q&#x27;:
        break
    last = input(&quot;Please give me a last name: &quot;)
    if last == &#x27;q&#x27;:
        break
    formatted_name = get_formatted_name(first, last)
    print(f&quot;\tNeatly formatted name: {formatted_name}.&quot;)
</code></pre>
<p>测试⽤例（test case）是⼀组单元测试（unit test）。<br />
全覆盖（full coverage）测试⽤例包含⼀整套单元测试，涵盖了各种可能的函数使⽤⽅式。</p>
<p>test_name_function.py（测试）</p>
<pre><code class="language-python"># 编写⼀个测试函数，它会调⽤要测试的函数，并做出有关返回值的断⾔。
# 如果断⾔正确，表⽰测试通过；如果断⾔不正确，表⽰测试未通过。
from name_function import get_formatted_name

def test_first_last_name():
    &quot;&quot;&quot;能够正确地处理像 Janis Joplin 这样的姓名吗？&quot;&quot;&quot;
    formatted_name = get_formatted_name(&#x27;janis&#x27;, &#x27;joplin&#x27;)
    assert formatted_name == &#x27;Janis Joplin&#x27;
</code></pre>
<ul>
<li>测试⽂件的名称很重要，必须以test_打头。当你让 pytest 运⾏测试时，它将查找以 test_打头的⽂件，并运⾏其中的所有测试。</li>
<li>测试函数必须以 test_打头。在测试过程中，pytest 将找出并运⾏所有以 test_ 打头的函数。且函数名要具有描述性。</li>
</ul>
<h3>运⾏测试</h3>
<p>打开⼀个终端窗⼝，并切换到这个测试⽂件所在的⽂件夹。如果你使⽤的是 VS Code，可打开测试⽂件所在的⽂件夹，并使⽤该编辑器内嵌的终端。在终端窗⼝中执⾏命令 pytest，你将看到如下输出：</p>
<pre><code class="language-python">$ pytest
 ========================= test session starts
=========================
❶ platform darwin -- Python 3.x.x, pytest-7.x.x, pluggy-1.x.x
❷ rootdir: /.../python_work/chapter_11
❸ collected 1 item
❹ test_name_function.py . 
[100%]
 ========================== 1 passed in 0.00s
==========================
</code></pre>
<h3>测试类</h3>
<ul>
<li>
<p>测试中常⽤的断⾔语句</p>
<table>
<thead>
<tr>
<th>断⾔</th>
<th>⽤途</th>
</tr>
</thead>
<tbody>
<tr>
<td>assert a == b</td>
<td>断⾔两个值相等</td>
</tr>
<tr>
<td>assert a != b</td>
<td>断⾔两个值不等</td>
</tr>
<tr>
<td>assert a</td>
<td>断⾔ a 的布尔求值为 True</td>
</tr>
<tr>
<td>assert not a</td>
<td>断⾔ a 的布尔求值为 False</td>
</tr>
<tr>
<td>assert element in list</td>
<td>断⾔元素在列表中</td>
</tr>
<tr>
<td>assert element not in list</td>
<td>断⾔元素不在列表中</td>
</tr>
</tbody></table></li>
</ul>
<p>survey.py</p>
<pre><code class="language-python">class AnonymousSurvey:
    &quot;&quot;&quot;收集匿名调查问卷的答案&quot;&quot;&quot;

    def __init__(self, question):
        &quot;&quot;&quot;存储⼀个问题，并为存储答案做准备&quot;&quot;&quot;
        self.question = question
        self.responses = []

    def show_question(self):
        &quot;&quot;&quot;显⽰调查问卷&quot;&quot;&quot;
        print(self.question)

    def store_response(self, new_response):
        &quot;&quot;&quot;存储单份调查答卷&quot;&quot;&quot;
        self.responses.append(new_response)

    def show_results(self):
        &quot;&quot;&quot;显⽰收集到的所有答卷&quot;&quot;&quot;
        print(&quot;Survey results:&quot;)
        for response in self.responses:
        print(f&quot;- {response}&quot;)
</code></pre>
<p>test_survey.py</p>
<pre><code class="language-python">from survey import AnonymousSurvey

def test_store_single_response():
    &quot;&quot;&quot;测试单个答案会被妥善地存储&quot;&quot;&quot;
    question = &quot;What language did you first learn to speak?&quot;
    language_survey = AnonymousSurvey(question)
    language_survey.store_response(&#x27;English&#x27;)
    assert &#x27;English&#x27; in language_survey.responses

def test_store_three_responses():
    &quot;&quot;&quot;测试三个答案会被妥善地存储&quot;&quot;&quot;
    question = &quot;What language did you first learn to speak?&quot;
    language_survey = AnonymousSurvey(question)
    responses = [&#x27;English&#x27;, &#x27;Spanish&#x27;, &#x27;Mandarin&#x27;]

    for response in responses:
        language_survey.store_response(response)

    for response in responses:
        assert response in language_survey.responses
</code></pre>
<p>如果在执⾏命令 pytest 时没有指定任何参数，pytest 将运⾏它在当前⽬录中找到的所有测试。为了专注于⼀个测试⽂件，可将该测试⽂件的名称作为参数传递给 pytest。</p>
<pre><code class="language-python">$ pytest test_survey.py
========================= test session starts =========================
--snip--
test_survey.py .. [100%]
========================== 2 passed in 0.01s ==========================
</code></pre>
<h3>使⽤夹具</h3>
<pre><code class="language-python">import pytest
from survey import AnonymousSurvey

@pytest.fixture
def language_survey():
    &quot;&quot;&quot;⼀个可供所有测试函数使⽤的 AnonymousSurvey 实例&quot;&quot;&quot;
    question = &quot;What language did you first learn to speak?&quot;
    language_survey = AnonymousSurvey(question)
    return language_survey

def test_store_single_response(language_survey):
    &quot;&quot;&quot;测试单个答案会被妥善地存储&quot;&quot;&quot;
    language_survey.store_response(&#x27;English&#x27;)
    assert &#x27;English&#x27; in language_survey.responses

def test_store_three_responses(language_survey):
    &quot;&quot;&quot;测试三个答案会被妥善地存储&quot;&quot;&quot;
    responses = [&#x27;English&#x27;, &#x27;Spanish&#x27;, &#x27;Mandarin&#x27;]
    for response in responses:
        language_survey.store_response(response)

    for response in responses:
        assert response in language_survey.responses
</code></pre>
<ul>
<li>在测试中，夹具（fixture）可帮助我们搭建测试环境。这通常意味着创建供多个测试使⽤的资源。</li>
<li>在 pytest 中，要创建夹具，可编写⼀个使⽤装饰器 @pytest.fixture 装饰的函数。装饰器（decorator）是放在函数定义前⾯的指令。在运⾏函数前，Python 将该指令应⽤于函数，以修改函数代码的⾏为。</li>
<li>当测试函数的⼀个形参与应⽤了装饰器 @pytest.fixture 的函数（夹具）同名时，将⾃动运⾏夹具，并将夹具返回的值传递给测试函数。</li>
<li>在这个⽰例中，language_survey() 函数向 test_store_single_response() 和 test_store_three_responses() 提供了⼀个 language_survey 实例。</li>
<li>在想要使⽤夹具时，可编写⼀个函数来⽣成供多个测试函数使⽤的资源，再对这个函数应⽤装饰器 @pytest.fixture，并让使⽤该资源的每个测试函数都接受⼀个与该函数同名的形参。这样，测试将更简洁，编写和维护起来也将更容易。</li>
</ul>
]]></content><link href="https://github.com/hadleysu/gitblog/issues/4" rel="alternate"/><category term="技术相关"/><published>2023-09-14T08:20:32+00:00</published></entry><entry><id>https://github.com/hadleysu/gitblog/issues/3</id><title>Markdown相关</title><updated>2023-10-17T13:50:30.687796+00:00</updated><content type="html"><![CDATA[<p>资料：</p>
<ul>
<li><a href="https://github.com/google/styleguide/blob/gh-pages/docguide/style.md">Google Markdown  Style Guide</a></li>
<li><a href="https://cirosantilli.com/markdown-style-guide/">Markdown  Style Guide</a></li>
</ul>
<p>VS Code 安装 Extensions:</p>
<ul>
<li>Markdown All in One</li>
<li>markdownlint</li>
</ul>
<p>Markdown All in One 生成TOC:</p>
<ul>
<li>CTRL + shift + p --&gt; Create Table of Contents</li>
<li>生成目录后，每次更新保存后将自动更新目录。</li>
<li>测试</li>
</ul>
]]></content><link href="https://github.com/hadleysu/gitblog/issues/3" rel="alternate"/><category term="技术相关"/><published>2023-09-12T13:49:32+00:00</published></entry><entry><id>https://github.com/hadleysu/gitblog/issues/2</id><title>感谢yihong老师的gitblog项目</title><updated>2023-10-17T13:50:30.835489+00:00</updated><content type="html"><![CDATA[<p>感谢yihong老师的gitblog项目，我可以开启我的写issue博客之旅了。</p>
<p><a href="https://github.com/yihong0618/gitblog">yihong老师的gitblog项目</a>
<a href="https://github.com/yihong0618/gitblog/issues/177">这个博客开源了</a></p>
]]></content><link href="https://github.com/hadleysu/gitblog/issues/2" rel="alternate"/><category term="一些记录"/><published>2023-09-10T13:21:29+00:00</published></entry></feed>