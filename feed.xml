<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/hadleysu/gitblog</id><title>RSS feed of hadleysu's gitblog</title><updated>2024-09-01T15:08:34.497727+00:00</updated><link href="https://github.com/hadleysu/gitblog"/><link href="https://raw.githubusercontent.com/hadleysu/gitblog/main/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><entry><id>https://github.com/hadleysu/gitblog/issues/11</id><title>JavaScript Fundamentals</title><updated>2024-09-01T15:08:34.691494+00:00</updated><content type="html"><![CDATA[<h1>JavaScript Fundamentals</h1>
<ul>
<li>
<a href="#javascript-fundamentals">JavaScript Fundamentals</a><ul>
<li><a href="#what-is-javascript"><strong>WHAT IS JAVASCRIPT?</strong></a></li>
<li><a href="#the-role-of-javascript-in-web-development"><strong>THE ROLE OF JAVASCRIPT IN WEB DEVELOPMENT</strong></a></li>
<li><a href="#what-can-we-do-with-javascript"><strong>WHAT CAN WE DO WITH JAVASCRIPT</strong></a></li>
<li><a href="#javascript-releases"><strong>JAVASCRIPT RELEASES</strong></a></li>
<li>
<a href="#values-and-variables"><strong>Values and Variables</strong></a><ul>
<li><a href="#1-%E6%A6%82%E5%BF%B5"><strong>1. 概念</strong></a></li>
<li><a href="#2-%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%B5%8B%E5%80%BC"><strong>2. 变量的声明与赋值</strong></a></li>
<li><a href="#3-%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><strong>3. 命名规则</strong></a></li>
<li><a href="#4-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><strong>4. 常见错误</strong></a></li>
<li><a href="#5-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><strong>5. 变量作用域</strong></a></li>
<li><a href="#6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><strong>6. 深入理解</strong></a></li>
<li><a href="#7-%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0%E9%A2%98"><strong>7. 相关练习题</strong></a></li>
<li><a href="#8-%E5%A4%8D%E4%B9%A0%E5%B0%8F%E7%BB%93"><strong>8. 复习小结</strong></a></li>
</ul>
</li>
<li>
<a href="#data-types"><strong>Data Types</strong></a><ul>
<li><a href="#1-%E6%A6%82%E5%BF%B5-1"><strong>1. 概念</strong></a></li>
<li><a href="#2-%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bprimitive-data-types"><strong>2. 原始数据类型（Primitive Data Types）</strong></a></li>
<li><a href="#3-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Breference-data-types"><strong>3. 引用数据类型（Reference Data Types）</strong></a></li>
<li><a href="#4-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E6%80%A7"><strong>4. 数据类型的特性</strong></a></li>
<li><a href="#5-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8Bdynamic-typing"><strong>5. 动态类型（Dynamic Typing）</strong></a></li>
<li><a href="#6-%E4%B8%8E-java-%E7%9A%84%E5%AF%B9%E6%AF%94"><strong>6. 与 Java 的对比</strong></a></li>
<li><a href="#7-value-has-type-not-variable-%E7%9A%84%E7%90%86%E8%A7%A3"><strong>7. &quot;Value has type, NOT variable!&quot; 的理解</strong></a></li>
<li><a href="#8-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B"><strong>8. 类型检测</strong></a></li>
<li><a href="#9-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><strong>9. 常见错误</strong></a></li>
<li><a href="#10-%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0%E9%A2%98"><strong>10. 相关练习题</strong></a></li>
<li><a href="#11-%E5%A4%8D%E4%B9%A0%E5%B0%8F%E7%BB%93"><strong>11. 复习小结</strong></a></li>
</ul>
</li>
<li>
<a href="#let-const-and-var"><strong>let, const and var</strong></a><ul>
<li><a href="#1-%E6%A6%82%E5%BF%B5-2"><strong>1. 概念</strong></a></li>
<li><a href="#2-%E4%BD%9C%E7%94%A8%E5%9F%9Fscope"><strong>2. 作用域（Scope）</strong></a></li>
<li><a href="#3-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87hoisting"><strong>3. 变量提升（Hoisting）</strong></a></li>
<li><a href="#4-%E5%8F%AF%E5%8F%98%E6%80%A7%E5%92%8C%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7mutability--immutability"><strong>4. 可变性和不可变性（Mutability / Immutability）</strong></a></li>
<li><a href="#5-%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8-letconst-%E8%BF%98%E6%98%AF-var"><strong>5. 选择使用 <code>let</code>、<code>const</code> 还是 <code>var</code></strong></a></li>
<li><a href="#6-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><strong>6. 注意事项与常见错误</strong></a></li>
<li><a href="#7-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%80%BB%E7%BB%93"><strong>7. 代码示例总结</strong></a></li>
<li><a href="#8-%E5%A4%8D%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93"><strong>8. 复习与总结</strong></a></li>
</ul>
</li>
<li>
<a href="#basic-operators"><strong>Basic Operators</strong></a><ul>
<li><a href="#1-%E6%A6%82%E5%BF%B5-3"><strong>1. 概念</strong></a></li>
<li><a href="#2-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6arithmetic-operators"><strong>2. 算术运算符（Arithmetic Operators）</strong></a></li>
<li><a href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E5%AD%97%E6%B7%B7%E5%90%88%E8%BF%90%E7%AE%97"><strong>3. 字符串与数字混合运算</strong></a></li>
<li><a href="#4-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6assignment-operators"><strong>4. 赋值运算符（Assignment Operators）</strong></a></li>
<li><a href="#5-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6comparison-operators"><strong>5. 比较运算符（Comparison Operators）</strong></a></li>
<li><a href="#6-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6logical-operators"><strong>6. 逻辑运算符（Logical Operators）</strong></a></li>
<li><a href="#7-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%90%E7%AE%97%E7%AC%A6string-operators"><strong>7. 字符串运算符（String Operators）</strong></a></li>
<li><a href="#8-%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E7%AC%A6"><strong>8. 其他常见操作符</strong></a></li>
<li><a href="#9-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7operator-precedence"><strong>9. 运算符优先级（Operator Precedence）</strong></a></li>
<li><a href="#10-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><strong>10. 注意事项与常见错误</strong></a></li>
<li><a href="#11-%E7%BB%83%E4%B9%A0%E9%A2%98%E4%B8%8E%E6%80%BB%E7%BB%93"><strong>11. 练习题与总结</strong></a></li>
</ul>
</li>
<li>
<a href="#operator-precedence"><strong>Operator Precedence</strong></a><ul>
<li><a href="#1-%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><strong>1. 概念介绍</strong></a></li>
<li><a href="#2-%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8"><strong>2. 操作符优先级表</strong></a></li>
<li><a href="#3-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><strong>3. 示例代码</strong></a></li>
<li><a href="#4-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><strong>4. 注意事项</strong></a></li>
<li><a href="#5-%E7%BB%83%E4%B9%A0%E9%A2%98"><strong>5. 练习题</strong></a></li>
<li><a href="#6-%E5%A4%8D%E4%B9%A0%E5%B0%8F%E7%BB%93"><strong>6. 复习小结</strong></a></li>
</ul>
</li>
<li>
<a href="#strings-and-template-literals"><strong>Strings and Template Literals</strong></a><ul>
<li><a href="#1-%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B"><strong>1. 概念简介</strong></a></li>
<li><a href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E4%BD%9C"><strong>2. 字符串的创建和操作</strong></a></li>
<li><a href="#3-%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8Ftemplate-literals"><strong>3. 模板字面量（Template Literals）</strong></a></li>
<li><a href="#4-%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"><strong>4. 常见操作</strong></a></li>
<li><a href="#5-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><strong>5. 注意事项</strong></a></li>
<li><a href="#6-%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0%E9%A2%98"><strong>6. 相关练习题</strong></a></li>
<li><a href="#7-%E5%A4%8D%E4%B9%A0%E5%B0%8F%E7%BB%93"><strong>7. 复习小结</strong></a></li>
</ul>
</li>
<li>
<a href="#taking-decisions-if--else-statements"><strong>Taking Decisions: if / else Statements</strong></a><ul>
<li><a href="#1-%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D-1"><strong>1. 概念介绍</strong></a></li>
<li><a href="#2-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><strong>2. 注意事项</strong></a></li>
<li><a href="#3-%E5%A4%8D%E4%B9%A0%E5%B0%8F%E7%BB%93"><strong>3. 复习小结</strong></a></li>
</ul>
</li>
<li>
<a href="#type-conversion-and-coercion"><strong>Type Conversion and Coercion</strong></a><ul>
<li><a href="#1--%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B"><strong>1.  概念简介</strong></a></li>
<li><a href="#2-type-conversion%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><strong>2. Type Conversion（显式类型转换）</strong></a></li>
<li><a href="#3-type-coercion%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><strong>3. Type Coercion（隐式类型强制转换）</strong></a></li>
<li><a href="#4-%E5%AE%9E%E8%B7%B5%E7%A4%BA%E4%BE%8B"><strong>4. 实践示例</strong></a></li>
<li><a href="#5--%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><strong>5.  注意事项</strong></a></li>
<li><a href="#6-%E7%BB%83%E4%B9%A0%E9%A2%98"><strong>6. 练习题</strong></a></li>
<li><a href="#7-%E5%A4%8D%E4%B9%A0%E5%B0%8F%E7%BB%93-1"><strong>7. 复习小结</strong></a></li>
</ul>
</li>
<li>
<a href="#truthy-and-falsy-values"><strong>Truthy and Falsy Values</strong></a><ul>
<li><a href="#1-%E6%A6%82%E5%BF%B5-4"><strong>1. 概念</strong></a></li>
<li><a href="#2-%E5%B8%B8%E8%A7%81%E7%9A%84-falsy-%E5%80%BC"><strong>2. 常见的 Falsy 值</strong></a></li>
<li><a href="#3-%E5%B8%B8%E8%A7%81%E7%9A%84-truthy-%E5%80%BC"><strong>3. 常见的 Truthy 值</strong></a></li>
<li>
<a href="#4-boolean%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><strong>4. Boolean的隐式转换和使用场景</strong></a><ul>
<li><a href="#when-exactly-does-javascript-do-type-coercion-to-booleans"><strong>When exactly does JavaScript do type coercion to booleans?</strong></a></li>
</ul>
</li>
<li><a href="#5-%E5%AE%9E%E8%B7%B5%E7%A4%BA%E4%BE%8B"><strong>5. 实践示例</strong></a></li>
<li><a href="#6-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><strong>6. 注意事项</strong></a></li>
<li><a href="#7-%E7%BB%83%E4%B9%A0%E9%A2%98"><strong>7. 练习题</strong></a></li>
<li><a href="#8-%E5%A4%8D%E4%B9%A0%E5%B0%8F%E7%BB%93-1"><strong>8. 复习小结</strong></a></li>
<li><a href="#9-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><strong>9. 适用场景</strong></a></li>
</ul>
</li>
<li>
<a href="#equality-operators--vs-"><strong>Equality Operators: == vs. ===</strong></a><ul>
<li><a href="#1-%E6%A6%82%E5%BF%B5-5"><strong>1. 概念</strong></a></li>
<li><a href="#2-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB"><strong>2. 操作符的区别</strong></a></li>
<li><a href="#3-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><strong>3. 适用场景</strong></a></li>
<li><a href="#4-%E5%AE%9E%E8%B7%B5%E7%BB%83%E4%B9%A0"><strong>4. 实践练习</strong></a></li>
<li><a href="#5-%E5%A4%8D%E4%B9%A0%E5%B0%8F%E7%BB%93"><strong>5. 复习小结</strong></a></li>
</ul>
</li>
<li>
<a href="#the-switch-statement"><strong>The switch Statement</strong></a><ul>
<li><a href="#1-%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3"><strong>1. 概念理解</strong></a></li>
<li><a href="#2-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><strong>2. 基本语法</strong></a></li>
<li><a href="#3-%E5%AE%9E%E8%B7%B5%E4%BE%8B%E5%AD%90"><strong>3. 实践例子</strong></a></li>
<li><a href="#4-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><strong>4. 注意事项</strong></a></li>
<li><a href="#5-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><strong>5. 适用场景</strong></a></li>
<li><a href="#6-%E4%B8%8E-ifelse-%E7%9A%84%E5%AF%B9%E6%AF%94"><strong>6. 与 <code>if...else</code> 的对比</strong></a></li>
<li><a href="#7-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><strong>7. 常见错误</strong></a></li>
<li><a href="#8-%E5%A4%8D%E4%B9%A0%E5%B0%8F%E7%BB%93-2"><strong>8. 复习小结</strong></a></li>
</ul>
</li>
<li>
<a href="#the-conditional-ternary-operator"><strong>The Conditional (Ternary) Operator</strong></a><ul>
<li><a href="#1-%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3-1"><strong>1. 概念理解</strong></a></li>
<li><a href="#2-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><strong>2. 基本语法</strong></a></li>
<li><a href="#3-ternary-operator-%E4%B8%8E-template-literals-%E7%9A%84%E7%BB%93%E5%90%88"><strong>3. Ternary Operator 与 Template Literals 的结合</strong></a></li>
<li><a href="#4-statements-%E4%B8%8E-expressions-%E7%9A%84%E5%8C%BA%E5%88%AB"><strong>4. Statements 与 Expressions 的区别</strong></a></li>
<li><a href="#5-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><strong>5. 常见错误</strong></a></li>
<li><a href="#6-%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0%E9%A2%98-1"><strong>6. 相关练习题</strong></a></li>
<li><a href="#7-%E5%A4%8D%E4%B9%A0%E5%B0%8F%E7%BB%93-2"><strong>7. 复习小结</strong></a></li>
</ul>
</li>
<li>
<a href="#activating-strict-mode"><strong>Activating Strict Mode</strong></a><ul>
<li><a href="#1-%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3-2"><strong>1. 概念理解</strong></a></li>
<li><a href="#2-%E5%90%AF%E7%94%A8-strict-mode"><strong>2. 启用 Strict Mode</strong></a></li>
<li><a href="#3-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E5%8A%BF"><strong>3. 严格模式的优势</strong></a></li>
<li><a href="#4-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><strong>4. 注意事项</strong></a></li>
<li><a href="#5-%E5%AE%9E%E8%B7%B5%E4%BE%8B%E5%AD%90"><strong>5. 实践例子</strong></a></li>
<li><a href="#6-%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0%E9%A2%98-2"><strong>6. 相关练习题</strong></a></li>
<li><a href="#7-%E5%A4%8D%E4%B9%A0%E5%B0%8F%E7%BB%93-3"><strong>7. 复习小结</strong></a></li>
</ul>
</li>
<li>
<a href="#functions"><strong>Functions</strong></a><ul>
<li><a href="#1-%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3-3"><strong>1. 概念理解</strong></a></li>
<li>
<a href="#2-%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F"><strong>2. 函数的声明与表达式</strong></a><ul>
<li><a href="#21-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8Efunction-declaration">2.1. <strong>函数声明（Function Declaration）</strong></a></li>
<li><a href="#22-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8Ffunction-expression">2.2. <strong>函数表达式（Function Expression）</strong></a></li>
<li><a href="#23-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0arrow-function">2.3. <strong>箭头函数（Arrow Function）</strong></a></li>
</ul>
</li>
<li>
<a href="#3-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><strong>3. 函数参数</strong></a><ul>
<li><a href="#31-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0default-parameters">3.1. <strong>默认参数（Default Parameters）</strong></a></li>
<li><a href="#32-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%84destructuring-parameters">3.2. <strong>参数解构（Destructuring Parameters）</strong></a></li>
</ul>
</li>
<li><a href="#4-%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><strong>4. 函数的返回值</strong></a></li>
<li>
<a href="#5-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85"><strong>5. 函数的作用域与闭包</strong></a><ul>
<li><a href="#51-%E4%BD%9C%E7%94%A8%E5%9F%9Fscope">5.1. <strong>作用域（Scope）</strong></a></li>
<li><a href="#52-%E9%97%AD%E5%8C%85closure">5.2. <strong>闭包（Closure）</strong></a></li>
</ul>
</li>
<li><a href="#6-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><strong>6. 常见问题与注意事项</strong></a></li>
<li><a href="#7-%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0%E9%A2%98-1"><strong>7. 相关练习题</strong></a></li>
<li><a href="#8-%E5%A4%8D%E4%B9%A0%E5%B0%8F%E7%BB%93-3"><strong>8. 复习小结</strong></a></li>
</ul>
</li>
<li>
<a href="#basic-array-operations-methods"><strong>Basic Array Operations (Methods)</strong></a><ul>
<li><a href="#1-%E6%A6%82%E5%BF%B5%E6%A6%82%E8%BF%B0">1. <strong>概念概述</strong></a></li>
<li><a href="#2-%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84">2. <strong>创建数组</strong></a></li>
<li>
<a href="#3-%E5%9F%BA%E6%9C%AC%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C">3. <strong>基本数组操作</strong></a><ul>
<li><a href="#31-%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><strong>3.1. 添加和删除元素</strong></a></li>
<li><a href="#32-%E6%9F%A5%E6%89%BE%E5%92%8C%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C"><strong>3.2. 查找和索引操作</strong></a></li>
<li><a href="#33-%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86"><strong>3.3. 数组遍历</strong></a></li>
</ul>
</li>
<li><a href="#4-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">4. <strong>数组方法的应用场景</strong></a></li>
<li><a href="#5-%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B">5. <strong>实际案例</strong></a></li>
<li><a href="#6-%E7%BB%83%E4%B9%A0%E9%A2%98-1">6. <strong>练习题</strong></a></li>
<li><a href="#7-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93">7. <strong>复习总结</strong></a></li>
</ul>
</li>
<li>
<a href="#objects"><strong>Objects</strong></a><ul>
<li><a href="#1-%E6%A6%82%E5%BF%B5%E6%A6%82%E8%BF%B0-1">1. <strong>概念概述</strong></a></li>
<li><a href="#2-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">2. <strong>创建对象</strong></a></li>
<li><a href="#3-%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C">3. <strong>对象属性操作</strong></a></li>
<li><a href="#4-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95">4. <strong>对象的方法</strong></a></li>
<li><a href="#5-%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86">5. <strong>对象的遍历</strong></a></li>
<li><a href="#6-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%90%88%E5%B9%B6">6. <strong>对象的复制与合并</strong></a></li>
<li><a href="#7-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">7. <strong>实际应用场景</strong></a></li>
<li><a href="#8-%E7%BB%83%E4%B9%A0%E9%A2%98">8. <strong>练习题</strong></a></li>
<li><a href="#9-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93">9. <strong>复习总结</strong></a></li>
</ul>
</li>
<li>
<a href="#object-methods"><strong>Object Methods</strong></a><ul>
<li><a href="#1-%E5%AE%9A%E4%B9%89"><strong>1. 定义：</strong></a></li>
<li><a href="#2-%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><strong>2. 创建方法：</strong></a></li>
<li><a href="#3-this-%E5%85%B3%E9%94%AE%E5%AD%97"><strong>3. <code>this</code> 关键字：</strong></a></li>
<li><a href="#4-%E7%AE%80%E5%86%99%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95"><strong>4. 简写方法语法：</strong></a></li>
<li><a href="#5-%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><strong>5. 使用对象方法：</strong></a></li>
<li><a href="#6-%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><strong>6. 常见应用场景：</strong></a></li>
<li><a href="#7-%E5%A4%8D%E4%B9%A0%E5%B0%8F%E7%BB%93-4"><strong>7. 复习小结：</strong></a></li>
<li><a href="#8-%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0%E9%A2%98"><strong>8. 相关练习题：</strong></a></li>
</ul>
</li>
<li>
<a href="#loops"><strong>Loops</strong></a><ul>
<li><a href="#1-%E6%A6%82%E5%BF%B5%E6%A6%82%E8%BF%B0-2"><strong>1. 概念概述</strong></a></li>
<li>
<a href="#2-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B"><strong>2. 常见的循环类型</strong></a><ul>
<li><a href="#21-for-%E5%BE%AA%E7%8E%AF"><strong>2.1. <code>for</code> 循环</strong></a></li>
<li><a href="#22-while-%E5%BE%AA%E7%8E%AF"><strong>2.2. <code>while</code> 循环</strong></a></li>
<li><a href="#23-dowhile-%E5%BE%AA%E7%8E%AF"><strong>2.3. <code>do...while</code> 循环</strong></a></li>
<li><a href="#24-forin-%E5%BE%AA%E7%8E%AF"><strong>2.4. <code>for...in</code> 循环</strong></a></li>
<li><a href="#25-forof-%E5%BE%AA%E7%8E%AF"><strong>2.5. <code>for...of</code> 循环</strong></a></li>
</ul>
</li>
<li>
<a href="#3-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><strong>3. 循环控制</strong></a><ul>
<li><a href="#31-break-%E8%AF%AD%E5%8F%A5"><strong>3.1. <code>break</code> 语句</strong></a></li>
<li><a href="#32-continue-%E8%AF%AD%E5%8F%A5"><strong>3.2. <code>continue</code> 语句</strong></a></li>
</ul>
</li>
<li><a href="#4-%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF"><strong>4. 嵌套循环</strong></a></li>
<li><a href="#5-%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E6%80%A7%E8%83%BD"><strong>5. 循环中的作用域和性能</strong></a></li>
<li><a href="#6-%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B"><strong>6. 实际案例</strong></a></li>
<li><a href="#7-%E7%BB%83%E4%B9%A0%E9%A2%98-1"><strong>7. 练习题</strong></a></li>
<li><a href="#8-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93"><strong>8. 复习总结</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><strong>WHAT IS JAVASCRIPT?</strong></h2>
<p>JAVASCRIPT IS A HIGH-LEVEL, OBJECT-ORIENTED, MULTI-PARADIGM PROGRAMMING LANGUAGE.</p>
<ul>
<li>
<p><code>PROGRAMMING LANGUAGE</code> --&gt; Instruct computer to do things</p>
</li>
<li>
<p><code>HIGH-LEVEL</code> --&gt; We don’t have to worry about complex stuff like memory management</p>
</li>
<li>
<p><code>OBJECT-ORIENTED</code> --&gt; Based on objects, for storing most kinds of data</p>
</li>
<li>
<p><code>MULTI-PARADIGM</code> --&gt; We can use different styles of programming</p>
</li>
</ul>
<h2><strong>THE ROLE OF JAVASCRIPT IN WEB DEVELOPMENT</strong></h2>
<ul>
<li>
<p><code>HTML</code> --&gt; CONTENT --&gt; <code>NOUNS</code></p>
<pre><code class="language-HTML">&lt;p&gt;&lt;/p&gt;
</code></pre>
</li>
<li>
<p><code>CSS</code> --&gt; PRESENTATION --&gt; <code>ADJECTIVES</code></p>
<pre><code class="language-CSS">p {color : red}
</code></pre>
</li>
<li>
<p><code>JS</code> --&gt; PROGRAMMING LANGUAGE : BUILDING WEB APPLICATIONS --&gt; <code>VERBS</code></p>
<pre><code class="language-javascript">p.hide();
</code></pre>
</li>
</ul>
<h2><strong>WHAT CAN WE DO WITH JAVASCRIPT</strong></h2>
<ul>
<li>Dynamic effects and web applications in the browser</li>
<li>Web applications on web servers ( through Node.js )</li>
<li>Native mobile applications</li>
<li>Native desktop applications</li>
</ul>
<h2><strong>JAVASCRIPT RELEASES</strong></h2>
<p>ES5 --&gt; ES6/ES2015 --&gt; ES7/ES2016 ... --&gt;ES11/ES2020 ... --&gt;ES2024</p>
<p>ES6 发布于2015年，增加了重要的新特性。从 ES6 开始，ECMAScript 规范改为每年发布一次，每次都将增加新特性。</p>
<h2><strong>Values and Variables</strong></h2>
<h3><strong>1. 概念</strong></h3>
<ul>
<li><strong>Value（值）</strong> 是程序中存储的数据，可以是数字、字符串、布尔值等。</li>
<li><strong>Variable（变量）</strong> 是用来存储值的容器，值可以在程序执行过程中改变。</li>
</ul>
<h3><strong>2. 变量的声明与赋值</strong></h3>
<p>JavaScript 中变量可以使用 <code>let</code>、<code>const</code> 和 <code>var</code> 来声明。<a href="#let-const-and-var"><strong>let, const and var</strong></a></p>
<pre><code class="language-javascript">let age = 30;         // 声明一个可以改变的变量
const birthYear = 1993; // 声明一个不可改变的变量
var job = &#x27;programmer&#x27;; // 使用 var 声明变量（老式写法）
</code></pre>
<h3><strong>3. 命名规则</strong></h3>
<ul>
<li>变量名必须以字母、下划线 <code>_</code> 或美元符号 <code>$</code> 开头。</li>
<li>不能以数字开头。</li>
<li>驼峰命名法（例如 <code>herFirstName</code>）。</li>
<li>变量名应该具有描述性（例如 <code>firstName</code>），以便代码更易读。</li>
</ul>
<h3><strong>4. 常见错误</strong></h3>
<ul>
<li>
<p><strong>使用未声明的变量</strong>: 在使用变量前必须先声明，否则会抛出 <code>ReferenceError</code>。</p>
<pre><code class="language-javascript">console.log(name); // ReferenceError: name is not defined
</code></pre>
</li>
<li>
<p><strong>重新赋值 <code>const</code> 变量</strong>: <code>const</code> 声明的变量一旦赋值后不能再更改。</p>
<pre><code class="language-javascript">const birthYear = 1993;
birthYear = 1990; // TypeError: Assignment to constant variable.
</code></pre>
</li>
<li>
<p><strong>变量名区分大小写</strong>: <code>firstName</code> 和 <code>firstname</code> 是不同的变量。</p>
<pre><code class="language-javascript">let firstName = &#x27;John&#x27;;
let firstname = &#x27;Jane&#x27;;
console.log(firstName); // John
console.log(firstname); // Jane
</code></pre>
</li>
</ul>
<h3><strong>5. 变量作用域</strong></h3>
<ul>
<li>
<p><strong>局部变量</strong>: 在函数或代码块中声明的变量只在该范围内有效。</p>
<pre><code class="language-javascript">function greet() {
    let message = &#x27;Hello!&#x27;;
    console.log(message); // &#x27;Hello!&#x27;
}
console.log(message); // ReferenceError: message is not defined
</code></pre>
</li>
<li>
<p><strong>全局变量</strong>: 在函数外部声明的变量可以在整个程序中访问。</p>
<pre><code class="language-javascript">let greeting = &#x27;Hi!&#x27;;
function greet() {
    console.log(greeting); // &#x27;Hi!&#x27;
}
greet();
</code></pre>
</li>
</ul>
<h3><strong>6. 深入理解</strong></h3>
<ul>
<li>
<p><strong>Hoisting（提升）</strong>: <code>var</code> 声明的变量会被提升到作用域的顶部，但只有声明会被提升，赋值不会。因此，可能会导致意外行为。</p>
<pre><code class="language-javascript">console.log(job); // undefined
var job = &#x27;developer&#x27;;
</code></pre>
<p>使用 <code>let</code> 和 <code>const</code> 的变量不会被提升，因此最好使用它们来避免 <code>hoisting</code> 带来的潜在问题。</p>
</li>
</ul>
<h3><strong>7. 相关练习题</strong></h3>
<pre><code class="language-javascript">// 练习题 1: 结果是什么？
let country = &#x27;Japan&#x27;;
country = &#x27;France&#x27;;
console.log(country); // ?

// 练习题 2: 结果是什么？
const city = &#x27;Tokyo&#x27;;
city = &#x27;Osaka&#x27;; // ?

// 练习题 3: 结果是什么？
console.log(year);
var year = 2024; // ?
</code></pre>
<h3><strong>8. 复习小结</strong></h3>
<ul>
<li>使用 <code>let</code> 和 <code>const</code> 来声明变量，避免使用 <code>var</code> 。</li>
<li>确保变量名具有描述性，以提高代码可读性。</li>
<li>注意 <code>hoisting</code> 行为，避免在声明前使用变量。</li>
</ul>
<h2><strong>Data Types</strong></h2>
<h3><strong>1. 概念</strong></h3>
<p><strong>Data Types（数据类型）</strong> 是指不同种类的值在编程语言中的表示方式。JavaScript 中的数据类型分为两大类：原始类型（Primitive Data Types）和引用类型（Reference Data Types）。</p>
<h3><strong>2. 原始数据类型（Primitive Data Types）</strong></h3>
<p>原始类型是不可变的，主要包括以下几种：</p>
<ul>
<li>
<p><strong>Number</strong>: 用于表示整数和浮点数。</p>
<pre><code class="language-javascript">let age = 25;
let temperature = 36.6;
</code></pre>
</li>
<li>
<p><strong>String</strong>: 用于表示文本数据，用单引号 <code>&#x27;</code>、双引号 <code>&quot;</code> 或反引号 <code>`</code> 包裹。</p>
<pre><code class="language-javascript">let firstName = &#x27;John&#x27;;
let greeting = &quot;Hello, world!&quot;;
let multiLine = `This is
a multiline string.`;
</code></pre>
</li>
<li>
<p><strong>Boolean</strong>: 用于表示真（<code>true</code>）或假（<code>false</code>）。</p>
<pre><code class="language-javascript">let isJavaScriptFun = true;
</code></pre>
</li>
<li>
<p><strong>Undefined</strong>: 当变量声明了但未赋值时，值为 <code>undefined</code>。</p>
<pre><code class="language-javascript">let year;
console.log(year); // undefined
</code></pre>
</li>
<li>
<p><strong>Null</strong>: 表示一个空值，手动赋值为 <code>null</code> 以表示“无”。</p>
<pre><code class="language-javascript">let emptyValue = null;
</code></pre>
</li>
<li>
<p><strong>Symbol</strong>: 用来创建独一无二的值，通常用于对象属性的标识符。</p>
<pre><code class="language-javascript">let uniqueId = Symbol(&#x27;id&#x27;);
</code></pre>
</li>
<li>
<p><strong>BigInt</strong>: 用于表示大整数，可以超出 <code>Number</code> 类型的最大安全整数限制。</p>
<pre><code class="language-javascript">let bigNumber = 1234567890123456789012345678901234567890n;
</code></pre>
</li>
</ul>
<h3><strong>3. 引用数据类型（Reference Data Types）</strong></h3>
<p>引用类型主要包括对象、数组和函数，它们是可变的。</p>
<ul>
<li>
<p><strong>Object</strong>: 一组键值对的集合，可以包含任意类型的数据。</p>
<pre><code class="language-javascript">let person = {
    name: &#x27;Alice&#x27;,
    age: 30,
    job: &#x27;Developer&#x27;
};
</code></pre>
</li>
<li>
<p><strong>Array</strong>: 有序的值的集合，可以包含不同类型的数据。</p>
<pre><code class="language-javascript">let colors = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;];
</code></pre>
</li>
<li>
<p><strong>Function</strong>: 用来封装可复用的代码块。</p>
<pre><code class="language-javascript">function greet(name) {
    return `Hello, ${name}!`;
}
</code></pre>
</li>
</ul>
<h3><strong>4. 数据类型的特性</strong></h3>
<ul>
<li>
<p><strong>原始类型的不可变性</strong>: 原始类型的值一旦创建，就不能被改变。即使修改了变量的值，实际上是将变量指向了一个新的值，而不是修改了原始的值。例如：</p>
<pre><code class="language-javascript">let greeting = &#x27;Hello&#x27;;
greeting[0] = &#x27;h&#x27;; // 尝试修改字符串的第一个字符（无效）
console.log(greeting); // &#x27;Hello&#x27;

greeting = &#x27;Hi&#x27;; // 重新赋值，这是创建了一个新的字符串，而不是修改原来的 &#x27;Hello&#x27;
</code></pre>
<p>这里的关键是，<strong>变量的类型</strong> 并不固定，但<strong>值的类型</strong> 是固定的。当你改变 <code>greeting</code> 变量的值时，实际上是重新分配了一个新的字符串给这个变量，而不是修改原有的字符串。</p>
</li>
<li>
<p><strong>引用类型的可变性</strong>: 引用类型的数据可以在创建后被修改。</p>
<pre><code class="language-javascript">let arr = [1, 2, 3];
arr[0] = 10; // 修改数组的第一个元素
</code></pre>
</li>
</ul>
<h3><strong>5. 动态类型（Dynamic Typing）</strong></h3>
<p>JavaScript 是一种动态类型语言，变量的数据类型可以在运行时改变。虽然变量本身没有固定的类型，但变量当前所持有的值是有类型的。例如：</p>
<pre><code class="language-javascript">let dynamicVar = &#x27;Hello&#x27;; // 现在是字符串
dynamicVar = 42; // 现在是数字
dynamicVar = true; // 现在是布尔值
</code></pre>
<p>这里的重点是，<strong>变量是动态的</strong>，可以在不同的时间点持有不同类型的值。这种灵活性是 JavaScript 的一个特性，但也可能导致类型错误，因此要谨慎使用。</p>
<h3><strong>6. 与 Java 的对比</strong></h3>
<p>在 Java 中，<strong>变量的类型是固定的</strong>，即在声明时就必须指定，并且在整个生命周期内不会改变。例如：</p>
<pre><code class="language-java">int number = 42;
number = &quot;Hello&quot;; // 错误：不能将字符串赋值给 int 类型的变量
</code></pre>
<p>这里的 <code>number</code> 变量一开始是 <code>int</code> 类型，所以它只能存储 <code>int</code> 类型的值，不能存储其他类型的值。这与 JavaScript 的动态类型形成了鲜明的对比。</p>
<h3><strong>7. &quot;Value has type, NOT variable!&quot; 的理解</strong></h3>
<p>这句话的意思是，在 JavaScript 中，<strong>值的类型是固定的</strong>，而<strong>变量的类型是动态的</strong>。即使变量可以随时改变所持有的值的类型，但一旦某个值被创建，它的类型就是确定的，不可改变的。例如：</p>
<pre><code class="language-javascript">let value = 10; // 10 是一个 number 类型的值
value = &#x27;Hello&#x27;; // &#x27;Hello&#x27; 是一个 string 类型的值
</code></pre>
<p>在这个例子中，<code>value</code> 这个变量可以先保存 <code>number</code> 类型的值，然后再保存 <code>string</code> 类型的值。但 <strong>10</strong> 一直是 <code>number</code> 类型，而 <strong>'Hello'</strong> 一直是 <code>string</code> 类型。</p>
<h3><strong>8. 类型检测</strong></h3>
<p>使用 <code>typeof</code> 操作符来检查变量的数据类型。</p>
<pre><code class="language-javascript">console.log(typeof 42);        // &#x27;number&#x27;
console.log(typeof &#x27;hello&#x27;);   // &#x27;string&#x27;
console.log(typeof true);      // &#x27;boolean&#x27;
console.log(typeof undefined); // &#x27;undefined&#x27;
console.log(typeof null);      // &#x27;object&#x27; (JavaScript的一个bug)
console.log(typeof {});        // &#x27;object&#x27;
console.log(typeof Symbol());  // &#x27;symbol&#x27;
console.log(typeof 123n);      // &#x27;bigint&#x27;
</code></pre>
<h3><strong>9. 常见错误</strong></h3>
<ul>
<li>
<p>原始类型的不可变性和动态类型并不冲突。它们是两个不同的概念，分别解决不同的问题：</p>
<ul>
<li>
<p><strong>不可变性</strong> 是关于具体值的性质，即这些值本身一旦创建就不能被修改。例如，一个字符串 <code>&#x27;Hello&#x27;</code> 不能通过修改其内容变成 <code>&#x27;Hella&#x27;</code>。</p>
</li>
<li>
<p><strong>动态类型</strong> 是关于变量的性质，指的是变量可以在不同类型的值之间切换。例如，一个变量可以先存储数字，再存储字符串，最后存储布尔值。</p>
</li>
<li>
<p><strong>总结：</strong> 原始类型的不可变性意味着你不能直接修改这些类型的值，但你可以通过重新赋值来改变变量存储的值。动态类型则意味着变量可以存储不同类型的值。这两者之间并不矛盾，而是各自独立的概念。</p>
</li>
</ul>
</li>
<li>
<p><strong>null 和 undefined 的区别</strong>: <code>null</code> 是手动赋值的空值，<code>undefined</code> 是变量未赋值时的默认值。</p>
</li>
<li>
<p><strong>NaN 的来源</strong>: 执行无法解析为数值的数学操作会产生 <code>NaN</code> (Not a Number)。</p>
<pre><code class="language-javascript">let result = &#x27;hello&#x27; * 2;
console.log(result); // NaN
</code></pre>
</li>
</ul>
<h3><strong>10. 相关练习题</strong></h3>
<p>通过练习题进一步理解数据类型。</p>
<pre><code class="language-javascript">// 练习题 1: 结果是什么？
console.log(typeof null); // ?

// 练习题 2: 结果是什么？
let value;
console.log(typeof value); // ?

// 练习题 3: 结果是什么？
let bigNum = 123456789012345678901234567890n;
console.log(typeof bigNum); // ?
</code></pre>
<h3><strong>11. 复习小结</strong></h3>
<ul>
<li>理解原始类型和引用类型的区别，知道何时使用何种类型。</li>
<li>了解 JavaScript 的动态类型特性及其带来的灵活性和潜在问题。</li>
<li>熟练使用 <code>typeof</code> 操作符进行类型检测。</li>
<li>理解“Value has type, NOT variable!” 的含义，即值的类型是固定的，而变量的类型是动态的。</li>
<li>NaN的来源。</li>
</ul>
<h2><strong>let, const and var</strong></h2>
<h3><strong>1. 概念</strong></h3>
<ul>
<li><strong><code>var</code></strong>: 最早引入的变量声明方式，具有函数作用域和变量提升特性。</li>
<li><strong><code>let</code></strong>: ES6 中引入的块级作用域变量声明方式，取代 <code>var</code> 的使用。</li>
<li><strong><code>const</code></strong>: ES6 中引入的块级作用域常量声明方式，声明后不能重新赋值。</li>
</ul>
<h3><strong>2. 作用域（Scope）</strong></h3>
<ul>
<li>
<p><strong><code>var</code> 的函数作用域</strong>: <code>var</code> 声明的变量仅在函数内部有效，如果在函数外部声明，则是全局变量。</p>
<pre><code class="language-javascript">function example() {
    var x = 10;
    if (true) {
        var x = 20; // 这里的 var x 与外面的 var x 是同一个变量
        console.log(x); // 20
    }
    console.log(x); // 20
}
</code></pre>
</li>
<li>
<p><strong><code>let</code> 和 <code>const</code> 的块级作用域</strong>: <code>let</code> 和 <code>const</code> 声明的变量仅在它们声明的块（如 <code>{}</code> 内）中有效。</p>
<pre><code class="language-javascript">function example() {
    let y = 10;
    if (true) {
        let y = 20; // 这里的 y 是一个新的变量，作用范围只在这个块内
        console.log(y); // 20
    }
    console.log(y); // 10
}
</code></pre>
</li>
</ul>
<h3><strong>3. 变量提升（Hoisting）</strong></h3>
<ul>
<li>
<p><strong><code>var</code> 的变量提升</strong>: 使用 <code>var</code> 声明的变量会在作用域顶部被提升，但不会初始化。</p>
<pre><code class="language-javascript">console.log(z); // undefined
var z = 5;
console.log(z); // 5
</code></pre>
</li>
<li>
<p><strong><code>let</code> 和 <code>const</code> 的暂时性死区（Temporal Dead Zone）</strong>: <code>let</code> 和 <code>const</code> 声明的变量不会被提升，在声明之前使用会导致错误。</p>
<pre><code class="language-javascript">console.log(a); // ReferenceError: a is not defined
let a = 5;
</code></pre>
</li>
</ul>
<h3><strong>4. 可变性和不可变性（Mutability / Immutability）</strong></h3>
<ul>
<li>
<p><strong><code>const</code> 的不可变性</strong>: <code>const</code> 声明的变量一旦被赋值，就不能再被重新赋值。但如果变量保存的是一个对象或数组，这个对象或数组本身是可以改变的。</p>
<pre><code class="language-javascript">const num = 42;
num = 50; // TypeError: Assignment to constant variable.

const arr = [1, 2, 3];
arr.push(4); // 合法：可以修改数组内容
console.log(arr); // [1, 2, 3, 4]
</code></pre>
</li>
<li>
<p><strong>let 和 var 的可变性</strong>:<code>let</code> 、 <code>var</code> 声明的变量是可变的，可以随时重新赋值。</p>
</li>
</ul>
<h3><strong>5. 选择使用 <code>let</code>、<code>const</code> 还是 <code>var</code></strong></h3>
<ul>
<li><strong>推荐使用 <code>let</code> 和 <code>const</code></strong>: 由于 <code>var</code> 存在作用域和变量提升问题，通常推荐使用 <code>let</code> 和 <code>const</code>。其中，<code>const</code> 用于声明不会改变的常量，而 <code>let</code> 用于声明会重新赋值的变量。</li>
<li><strong>变量声明习惯</strong>: 开发中尽量使用 <code>const</code>，只有在需要重新赋值的情况下使用 <code>let</code>。</li>
</ul>
<h3><strong>6. 注意事项与常见错误</strong></h3>
<ul>
<li><strong>避免使用 <code>var</code></strong>: 使用 <code>var</code> 可能引入难以追踪的作用域问题，因此应尽量避免。</li>
<li><strong>理解 <code>const</code> 的不可变性</strong>: 仅禁止重新赋值，允许对象内部修改，因此要小心使用对象或数组。</li>
</ul>
<h3><strong>7. 代码示例总结</strong></h3>
<ul>
<li>
<p><code>var</code> 的变量提升和函数作用域：</p>
<pre><code class="language-javascript">var x = 10;
function example() {
    console.log(x); // undefined
    var x = 20;
    console.log(x); // 20
}
example();
</code></pre>
</li>
<li>
<p><code>let</code> 和 <code>const</code> 的块级作用域和暂时性死区：</p>
<pre><code class="language-javascript">let y = 10;
if (true) {
    let y = 20;
    console.log(y); // 20
}
console.log(y); // 10

console.log(a); // ReferenceError
let a = 5;
</code></pre>
</li>
<li>
<p><code>const</code> 的对象内部可变性：</p>
<pre><code class="language-javascript">const person = { name: &#x27;Alice&#x27; };
person.name = &#x27;Bob&#x27;; // 合法
console.log(person.name); // &#x27;Bob&#x27;

person = {}; // TypeError: Assignment to constant variable.
</code></pre>
</li>
</ul>
<h3><strong>8. 复习与总结</strong></h3>
<ul>
<li>尽量避免使用 <code>var</code>，推荐使用 <code>let</code> 和 <code>const</code>。</li>
<li>在需要重新赋值时使用 <code>let</code>，而在不可变的情况下使用 <code>const</code>。</li>
<li>理解变量提升的行为以及不同作用域带来的影响，写出更安全的代码。</li>
</ul>
<h2><strong>Basic Operators</strong></h2>
<h3><strong>1. 概念</strong></h3>
<p><strong>运算符（Operators）</strong> 是用于在程序中执行某种操作的符号。JavaScript 中的基本运算符可以分为以下几类：算术运算符、赋值运算符、比较运算符、逻辑运算符、字符串运算符和条件运算符（也称三元运算符）等。</p>
<h3><strong>2. 算术运算符（Arithmetic Operators）</strong></h3>
<p>用于执行数学计算的运算符。</p>
<ul>
<li>
<p><strong>加法（<code>+</code>）</strong>: 用于两个数值相加，也可用于字符串拼接。</p>
</li>
<li>
<p><strong>减法（<code>-</code>）</strong>: 用于减去两个数值。</p>
</li>
<li>
<p><strong>乘法（<code>*</code>）</strong>: 用于两个数值相乘。</p>
</li>
<li>
<p><strong>除法（<code>/</code>）</strong>: 用于两个数值相除。</p>
</li>
<li>
<p><strong>取模（<code>%</code>）</strong>: 用于取两个数值相除后的余数。</p>
</li>
<li>
<p><strong>幂运算（<code>**</code>）</strong>: 用于计算一个数值的幂次方。</p>
</li>
</ul>
<h3><strong>3. 字符串与数字混合运算</strong></h3>
<pre><code class="language-javascript">//加法运算 --&gt; 当操作数之一是字符串时，JavaScript 会将另一个操作数也转换为字符串，然后进行连接。
let result1 = &#x27;5&#x27; + 3;
console.log(result1); // &#x27;53&#x27; (数字 3 被转换为字符串 &#x27;3&#x27;)

let result2 = 3 + &#x27;5&#x27;;
console.log(result2); // &#x27;35&#x27; (数字 3 被转换为字符串 &#x27;3&#x27;)

let result3 = &#x27;5&#x27; + 3 + 2;
console.log(result3); // &#x27;532&#x27; (从左到右，&#x27;5&#x27; + 3 变成 &#x27;53&#x27;，然后 &#x27;53&#x27; + 2 变成 &#x27;532&#x27;)

//减法 --&gt; 都会将字符串转换为数字，然后进行运算。乘法、除法、指数运算、取余运算同上。
let result1 = &#x27;5&#x27; - 3;
console.log(result1); // 2 (字符串 &#x27;5&#x27; 被转换为数字 5)

let result2 = &#x27;10&#x27; - &#x27;2&#x27;;
console.log(result2); // 8 (两个字符串都被转换为数字)

let result3 = &#x27;5&#x27; - &#x27;hello&#x27;;
console.log(result3); // NaN (字符串 &#x27;hello&#x27; 无法转换为数字)
</code></pre>
<ul>
<li><strong>总结</strong>：在 JavaScript 中，字符串与数字混合运算时，通常会将字符串尝试转换为数字进行运算。如果字符串不能被成功转换为数字，结果通常会是 <code>NaN</code>（Not a Number）。唯一的例外是 <code>+</code> 操作符，因为它也可以用于字符串连接，因此会优先进行字符串连接而不是数值计算。</li>
</ul>
<h3><strong>4. 赋值运算符（Assignment Operators）</strong></h3>
<p>用于将值赋给变量。</p>
<ul>
<li>
<p><strong>基本赋值（<code>=</code>）</strong>: 将右边的值赋给左边的变量。</p>
</li>
<li>
<p><strong>复合赋值</strong>: 。</p>
<pre><code class="language-javascript">x += 5; // 等同于 x = x + 5; 现在 x 的值是 15
x -= 2; // 等同于 x = x - 2; 现在 x 的值是 13
x *= 3; // 等同于 x = x * 3; 现在 x 的值是 39
x /= 3; // 等同于 x = x / 3; 现在 x 的值是 13
x %= 2; // 等同于 x = x % 2; 现在 x 的值是 1
x **= 2; // 等同于 x = x ** 2; 现在 x 的值是 1
</code></pre>
</li>
</ul>
<h3><strong>5. 比较运算符（Comparison Operators）</strong></h3>
<p>用于比较两个值并返回布尔值（<code>true</code> 或 <code>false</code>）。</p>
<ul>
<li>
<p><strong>等于（<code>==</code>）和严格等于（<code>===</code>）</strong>:</p>
<pre><code class="language-javascript">let isEqual = (5 == &#x27;5&#x27;); // true（仅比较值，允许类型转换）
let isStrictEqual = (5 === &#x27;5&#x27;); // false（比较值和类型，不允许类型转换）
</code></pre>
</li>
<li>
<p><strong>不等于（<code>!=</code>）和严格不等于（<code>!==</code>）</strong>:</p>
<pre><code class="language-javascript">let isNotEqual = (5 != &#x27;5&#x27;); // false
let isStrictNotEqual = (5 !== &#x27;5&#x27;); // true
</code></pre>
</li>
<li>
<p><strong>大于（<code>&gt;</code>）</strong>、<strong>小于（<code>&lt;</code>）</strong>、<strong>大于等于（<code>&gt;=</code>）</strong>、<strong>小于等于（<code>&lt;=</code>）</strong>: 用于数值比较。</p>
</li>
</ul>
<h3><strong>6. 逻辑运算符（Logical Operators）</strong></h3>
<p>用于布尔值的组合。</p>
<ul>
<li>
<p><strong>与（<code>&amp;&amp;</code>）</strong>: 仅当两个操作数都为 <code>true</code> 时返回 <code>true</code>。</p>
</li>
<li>
<p><strong>或（<code>||</code>）</strong>: 只要有一个操作数为 <code>true</code> 就返回 <code>true</code>。</p>
</li>
<li>
<p><strong>非（<code>!</code>）</strong>: 取反运算符，将布尔值反转。</p>
</li>
</ul>
<h3><strong>7. 字符串运算符（String Operators）</strong></h3>
<ul>
<li>
<p><strong>拼接运算符（<code>+</code>）</strong>: 用于连接字符串。</p>
<pre><code class="language-javascript">let fullName = &#x27;John&#x27; + &#x27; &#x27; + &#x27;Doe&#x27;; // &quot;John Doe&quot;
</code></pre>
</li>
<li>
<p><strong>赋值拼接（<code>+=</code>）</strong>: 将字符串拼接并赋值给变量。</p>
<pre><code class="language-javascript">let text = &#x27;Hello&#x27;;
text += &#x27; world&#x27;; // &quot;Hello world&quot;
</code></pre>
</li>
</ul>
<h3><strong>8. 其他常见操作符</strong></h3>
<ul>
<li>
<p>条件运算符/三元运算符（<code>? :</code>）: 用于根据条件返回不同的值。</p>
<ul>
<li>
<p><strong>语法</strong>: <code>condition ? expr1 : expr2</code></p>
<pre><code class="language-javascript">let age = 18;
let isAdult = age &gt;= 18 ? &#x27;Yes&#x27; : &#x27;No&#x27;; // &quot;Yes&quot;
</code></pre>
</li>
</ul>
</li>
<li>
<p>类型操作符 (<code>typeof</code>):</p>
<pre><code class="language-javascript">let type = typeof 42; // &#x27;number&#x27;
</code></pre>
</li>
<li>
<p>删除操作符 (<code>delete</code>):</p>
<pre><code class="language-javascript">let person = { name: &#x27;John&#x27;, age: 30 };
delete person.age; // 删除对象的 age 属性
</code></pre>
</li>
</ul>
<h3><strong>9. 运算符优先级（Operator Precedence）</strong></h3>
<p>运算符的优先级决定了表达式中各运算符的计算顺序。可以通过括号明确优先顺序。<a href="#operator-precedence">Operator Precedence</a></p>
<h3><strong>10. 注意事项与常见错误</strong></h3>
<ul>
<li>
<p><strong>相等和严格相等的区别</strong>: <code>==</code> 允许类型转换，而 <code>===</code> 不允许，因此通常推荐使用 <code>===</code> 来避免意外的类型转换。</p>
</li>
<li>
<p><strong>运算符优先级</strong>: 在复杂表达式中，运算符的优先级可能导致意外结果，建议使用括号明确优先级。</p>
</li>
</ul>
<h3><strong>11. 练习题与总结</strong></h3>
<ul>
<li>
<p><strong>练习题</strong>:</p>
<pre><code class="language-javascript">// 练习题 1: 结果是什么？
let result = 5 + &#x27;1&#x27;; // ?

// 练习题 2: 结果是什么？
let isEven = 4 % 2 === 0; // ?

// 练习题 3: 结果是什么？
let x = true || false &amp;&amp; !true; // ?
</code></pre>
</li>
<li>
<p><strong>总结</strong>:</p>
<ul>
<li>理解并熟练使用各种基本运算符。</li>
<li>理解运算符优先级，合理使用括号控制运算顺序。</li>
<li>注意 <code>==</code> 和 <code>===</code> 的区别，避免不必要的类型转换。</li>
<li>避免常见的字符串与数字混合运算中的错误。</li>
</ul>
</li>
</ul>
<h2><strong>Operator Precedence</strong></h2>
<h3><strong>1. 概念介绍</strong></h3>
<p><strong>Operator Precedence（操作符优先级）</strong> 是指在表达式中多个操作符共存时，操作符的执行顺序。优先级较高的操作符会比优先级较低的操作符先执行。</p>
<ul>
<li>操作符优先级决定了表达式中各个部分的计算顺序。</li>
<li>操作符还可以结合使用，其中有结合性（Associativity）的概念，指的是在相同优先级下，操作符的计算顺序（从左至右或从右至左）。</li>
</ul>
<h3><strong>2. 操作符优先级表</strong></h3>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_precedence">MDN Operator Precedence Table</a></li>
</ul>
<table>
<thead>
<tr>
<th><strong>优先级</strong></th>
<th><strong>操作符</strong></th>
<th><strong>描述</strong></th>
<th><strong>结合性</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>()</code></td>
<td>括号：显式地指定运算顺序</td>
<td>N/A</td>
</tr>
<tr>
<td>2</td>
<td><code>!</code>、<code>++</code>、<code>--</code></td>
<td>单目运算符：逻辑非、递增、递减等操作符</td>
<td>N/A</td>
</tr>
<tr>
<td>3</td>
<td><code>**</code></td>
<td>指数运算</td>
<td>右到左 (RTL)</td>
</tr>
<tr>
<td>4</td>
<td><code>*</code>、<code>/</code>、<code>%</code></td>
<td>乘法、除法、取余</td>
<td>左到右 (LTR)</td>
</tr>
<tr>
<td>5</td>
<td><code>+</code>、<code>-</code></td>
<td>加法、减法</td>
<td>左到右 (LTR)</td>
</tr>
<tr>
<td>6</td>
<td><code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code></td>
<td>比较操作符：用于比较大小</td>
<td>左到右 (LTR)</td>
</tr>
<tr>
<td>7</td>
<td><code>==</code>、<code>!=</code>、<code>===</code>、<code>!==</code></td>
<td>等值/非等值操作符：用于比较相等性</td>
<td>左到右 (LTR)</td>
</tr>
<tr>
<td>8</td>
<td><code>&amp;&amp;</code></td>
<td>逻辑与：当且仅当两个操作数均为 <code>true</code> 时，结果为 <code>true</code></td>
<td>左到右 (LTR)</td>
</tr>
<tr>
<td>9</td>
<td><code>||</code></td>
<td>逻辑或：只要有一个操作数为 <code>true</code>，结果就为 <code>true</code></td>
<td>左到右 (LTR)</td>
</tr>
<tr>
<td>10</td>
<td><code>=</code></td>
<td>赋值操作符：优先级最低，用于赋值</td>
<td>右到左 (RTL)</td>
</tr>
</tbody></table><h3><strong>3. 示例代码</strong></h3>
<p>在理解操作符优先级时，使用具体的代码示例可以帮助巩固知识。</p>
<pre><code class="language-javascript">let a = 10 &gt; 5 &amp;&amp; 8 &lt; 7;
console.log(a); // 11，因为比较运算符的优先级高于逻辑 &amp;&amp;

let b = (5 + 3) * 2;
console.log(b); // 16，因为括号改变了运算顺序

let c = 5 + 3 &gt; 7;
console.log(c); // true，因为加法的优先级高于比较运算

let d = true || false &amp;&amp; !false;
console.log(d); // true，因为逻辑非 (!false) 先执行，然后逻辑与 (&amp;&amp;)，最后是逻辑或 (||)
</code></pre>
<h3><strong>4. 注意事项</strong></h3>
<ul>
<li><strong>使用圆括号</strong>：当表达式变得复杂时，为了避免优先级错误，建议使用圆括号明确指示运算顺序。</li>
<li><strong>结合性</strong>：当多个操作符优先级相同时，理解结合性能够帮助正确评估表达式的结果。</li>
</ul>
<h3><strong>5. 练习题</strong></h3>
<p>通过练习题进一步理解操作符优先级。</p>
<pre><code class="language-javascript">// 练习题 1: 结果是什么？
let x = 10 + 5 * 2 &gt; 20 || false;
console.log(x); // ?

// 练习题 2: 结果是什么？
let y = !true &amp;&amp; false || true;
console.log(y); // ?

// 练习题 3: 结果是什么？
let z = 3 + 4 * 2 / (1 - 5) ** 2;
console.log(z); // ?
</code></pre>
<h3><strong>6. 复习小结</strong></h3>
<ul>
<li>理解操作符优先级和结合性对准确评估复杂表达式至关重要。</li>
<li>熟练使用圆括号以明确表达式的运算顺序。</li>
</ul>
<h2><strong>Strings and Template Literals</strong></h2>
<h3><strong>1. 概念简介</strong></h3>
<p><strong>字符串（Strings</strong>）是用于表示文本的基本数据类型。JavaScript 中的字符串可以使用单引号 <code>&#x27;</code>、双引号 <code>&quot;</code> 或反引号 <code>`</code> 来定义。</p>
<p><strong>模板字面量（Template Literals</strong>）是一种新的字符串字面量，用反引号 <code>`</code> 包裹，支持多行字符串和嵌入表达式。</p>
<pre><code class="language-javascript">`string text ${expression} string text`
</code></pre>
<h3><strong>2. 字符串的创建和操作</strong></h3>
<ul>
<li>
<p><strong>字符串创建</strong>：可以使用单引号、双引号或反引号创建字符串。</p>
<pre><code class="language-javascript">let singleQuote = &#x27;Hello&#x27;;
let doubleQuote = &quot;World&quot;;
let templateLiteral = `Hello, World!`;
</code></pre>
</li>
<li>
<p><strong>字符串连接</strong>：使用 <code>+</code> 操作符将字符串连接在一起。</p>
<pre><code class="language-javascript">let greeting = &#x27;Hello&#x27; + &#x27; &#x27; + &#x27;World&#x27;;
console.log(greeting); // &quot;Hello World&quot;
</code></pre>
</li>
<li>
<p><strong>字符串长度</strong>：通过 <code>.length</code> 属性获取字符串的长度。</p>
<pre><code class="language-javascript">let name = &#x27;JavaScript&#x27;;
console.log(name.length); // 10
</code></pre>
</li>
</ul>
<h3><strong>3. 模板字面量（Template Literals）</strong></h3>
<ul>
<li>
<p><strong>多行字符串</strong>：模板字面量支持多行字符串，无需使用转义字符 <code>\n</code>。</p>
<pre><code class="language-javascript">let multiLine = `This is a
multiline string`;
console.log(multiLine);
// 输出：
// This is a
// multiline string
</code></pre>
</li>
<li>
<p><strong>嵌入表达式</strong>：模板字面量支持嵌入 JavaScript 表达式，使用 <code>${}</code> 语法。</p>
<pre><code class="language-javascript">let name = &#x27;John&#x27;;
let greeting = `Hello, ${name}!`;
console.log(greeting); // &quot;Hello, John!&quot;
</code></pre>
</li>
<li>
<p><strong>嵌入表达式中的计算</strong>：在 <code>${}</code> 中可以直接进行计算或调用函数。</p>
<pre><code class="language-javascript">let a = 5;
let b = 10;
console.log(`The sum of a and b is ${a + b}`); // &quot;The sum of a and b is 15&quot;
</code></pre>
</li>
</ul>
<h3><strong>4. 常见操作</strong></h3>
<ul>
<li>
<p><strong>字符串方法</strong>：如 <code>.toUpperCase()</code>、<code>.toLowerCase()</code>、<code>.includes()</code>、<code>.startsWith()</code> 等。</p>
<pre><code class="language-javascript">let str = &#x27;JavaScript&#x27;;
console.log(str.toUpperCase()); // &quot;JAVASCRIPT&quot;
console.log(str.includes(&#x27;Script&#x27;)); // true
</code></pre>
</li>
<li>
<p><strong>模板字面量中的函数调用</strong>：你可以在模板字面量中直接调用函数并插入返回值。</p>
<pre><code class="language-javascript">function greet(name) {
    return `Hello, ${name}!`;
}
let message = `${greet(&#x27;Alice&#x27;)}`;
console.log(message); // &quot;Hello, Alice!&quot;
</code></pre>
</li>
</ul>
<h3><strong>5. 注意事项</strong></h3>
<ul>
<li>
<p><strong>区别单引号、双引号与反引号</strong>：使用模板字面量（反引号）时，不需要像使用单引号或双引号那样手动转义特殊字符或插入变量。</p>
<pre><code class="language-javascript">let escaped = &#x27;It\&#x27;s a nice day&#x27;;
let template = `It&#x27;s a nice day`;
</code></pre>
</li>
<li>
<p><strong>性能考虑</strong>：模板字面量提供了更简洁的语法，但在某些情况下，使用连接操作符 <code>+</code> 可能会稍微快一些。</p>
</li>
</ul>
<h3><strong>6. 相关练习题</strong></h3>
<p>通过练习题进一步理解字符串与模板字面量的使用。</p>
<pre><code class="language-javascript">// 练习题 1: 使用模板字面量创建一个包含多行文字的字符串。
let multiLineStr = `This is line 1
This is line 2
This is line 3`;

// 练习题 2: 在模板字面量中插入一个表达式，计算 10 + 20 并输出结果。
let result = `The result of 10 + 20 is ${10 + 20}`;
console.log(result); // &quot;The result of 10 + 20 is 30&quot;

// 练习题 3: 使用字符串方法将字符串 &quot;hello&quot; 转换为大写并在模板字面量中输出。
let str = `HELLO`.toLowerCase();
console.log(`The lowercase of HELLO is ${str}`); // &quot;The lowercase of HELLO is hello&quot;
</code></pre>
<h3><strong>7. 复习小结</strong></h3>
<ul>
<li>理解字符串的基本操作，包括创建、连接、获取长度等。</li>
<li>掌握模板字面量的语法，特别是多行字符串和嵌入表达式的使用方法。</li>
</ul>
<h2><strong>Taking Decisions: if / else Statements</strong></h2>
<h3><strong>1. 概念介绍</strong></h3>
<p><strong><code>if / else</code> 语句</strong>是用于控制程序流程的基本结构，根据条件的真假来决定是否执行某段代码。它通常用于当需要根据不同条件执行不同代码块时。</p>
<h3><strong>2. 注意事项</strong></h3>
<ul>
<li>
<p><strong>三元运算符</strong>：对于简单的 <code>if / else</code> 语句，可以使用三元运算符 <code>? :</code> 进行简化。</p>
<pre><code class="language-javascript">let age = 18;
let message = age &gt;= 18 ? &#x27;You are an adult.&#x27; : &#x27;You are a minor.&#x27;;
console.log(message);
</code></pre>
</li>
</ul>
<h3><strong>3. 复习小结</strong></h3>
<ul>
<li>了解嵌套条件语句和逻辑运算符的应用场景，并熟练使用三元运算符进行简化判断。</li>
</ul>
<h2><strong>Type Conversion and Coercion</strong></h2>
<h3><strong>1.  概念简介</strong></h3>
<p><strong>Type Conversion（类型转换）</strong> 和 <strong>Type Coercion（类型强制转换）</strong> 是指在 JavaScript 中将一种数据类型转换为另一种类型的过程。</p>
<ul>
<li><strong>Type Conversion</strong>: 是显式的，由开发者手动进行的类型转换。</li>
<li><strong>Type Coercion</strong>: 是隐式的，由 JavaScript 在需要时自动进行的类型转换。</li>
</ul>
<h3><strong>2. Type Conversion（显式类型转换）</strong></h3>
<p>显式类型转换是指开发者使用内置函数或方法手动将数据从一种类型转换为另一种类型。</p>
<ul>
<li>
<p><strong>将数字转换为字符串</strong>：</p>
<pre><code class="language-javascript">let num = 42;
let str = String(num); // &#x27;42&#x27;
</code></pre>
</li>
<li>
<p><strong>将字符串转换为数字</strong>：</p>
<pre><code class="language-javascript">let str = &#x27;3.14&#x27;;
let num = Number(str); // 3.14
let intNum = parseInt(str); // 3
let floatNum = parseFloat(str); // 3.14
</code></pre>
</li>
<li>
<p><strong>将布尔值转换为字符串</strong>：</p>
<pre><code class="language-javascript">let bool = true;
let str = String(bool); // &#x27;true&#x27;
</code></pre>
</li>
<li>
<p><strong>将其他类型转换为布尔值</strong>：</p>
<pre><code class="language-javascript">let num = 0;
let isZero = Boolean(num); // false
</code></pre>
</li>
</ul>
<h3><strong>3. Type Coercion（隐式类型强制转换）</strong></h3>
<p>隐式类型强制转换是指 JavaScript 在表达式中自动将不同类型的数据转换为相同类型，以便进行运算或比较。或<a href="#4-boolean%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">在许多情况下会自动将不同类型的值转换为布尔值</a>，例如，在条件判断中。</p>
<ul>
<li>
<p><strong>字符串与数字的混合运算</strong>：</p>
<pre><code class="language-javascript">let result = &#x27;5&#x27; + 10; // &#x27;510&#x27; (数字被转换为字符串)
let result2 = &#x27;5&#x27; * 2; // 10 (字符串被转换为数字)
</code></pre>
</li>
<li>
<p><strong>布尔值与数字的混合运算</strong>：</p>
<pre><code class="language-javascript">let result = true + 2; // 3 (true 被转换为 1)
let result2 = false + 10; // 10 (false 被转换为 0)
</code></pre>
</li>
<li>
<p><strong>比较操作中的类型强制转换</strong>：</p>
<pre><code class="language-javascript">let result = &#x27;10&#x27; == 10; // true (字符串被转换为数字)
let result2 = &#x27;10&#x27; === 10; // false (不同类型，不转换)
</code></pre>
</li>
</ul>
<h3><strong>4. 实践示例</strong></h3>
<ul>
<li>
<p><strong>显式类型转换</strong>：</p>
<pre><code class="language-javascript">let inputYear = &#x27;1991&#x27;;
let birthYear = Number(inputYear); // 1991
console.log(birthYear + 10); // 2001
</code></pre>
</li>
<li>
<p><strong>隐式类型强制转换</strong>：</p>
<pre><code class="language-javascript">console.log(&#x27;I am &#x27; + 23 + &#x27; years old&#x27;); // &#x27;I am 23 years old&#x27;
console.log(&#x27;23&#x27; - &#x27;10&#x27; - 3); // 10
console.log(&#x27;23&#x27; * &#x27;2&#x27;); // 46
console.log(&#x27;23&#x27; / &#x27;2&#x27;); // 11.5
</code></pre>
</li>
</ul>
<h3><strong>5.  注意事项</strong></h3>
<ul>
<li>
<p><strong>避免混淆类型</strong>：使用 <code>==</code> 时要小心，因为它会进行类型强制转换，可能导致意外结果。建议使用 <code>===</code> 来避免类型强制转换。</p>
<pre><code class="language-javascript">console.log(&#x27;0&#x27; == 0); // true
console.log(&#x27;0&#x27; === 0); // false
</code></pre>
</li>
<li>
<p><strong>了解 <code>NaN</code> 的来源</strong>：执行无法解析为数值的操作会导致 <code>NaN</code>（Not a Number）。</p>
<pre><code class="language-javascript">let result = &#x27;hello&#x27; * 2;
console.log(result); // NaN
</code></pre>
</li>
</ul>
<h3><strong>6. 练习题</strong></h3>
<p>通过练习题进一步理解类型转换和强制转换的应用。</p>
<pre><code class="language-javascript">// 练习题 1: 结果是什么？
console.log(&#x27;5&#x27; + 10); // ?

// 练习题 2: 结果是什么？
console.log(&#x27;5&#x27; - &#x27;2&#x27;); // ?

// 练习题 3: 结果是什么？
console.log(true + &#x27;1&#x27;); // ?
</code></pre>
<h3><strong>7. 复习小结</strong></h3>
<ul>
<li>理解并掌握显式和隐式类型转换的区别及应用场景。</li>
<li>注意类型强制转换带来的潜在问题，尤其是在比较操作中。</li>
<li>通过练习加深对字符串、数字、布尔值等类型之间的转换理解。</li>
</ul>
<h2><strong>Truthy and Falsy Values</strong></h2>
<h3><strong>1. 概念</strong></h3>
<p>在 JavaScript 中，任何值都可以被转换为布尔值 <code>true</code> 或 <code>false</code>。</p>
<ul>
<li><strong>Truthy 值</strong>: 在布尔上下文中会被认为是 <code>true</code> 的值。</li>
<li><strong>Falsy 值</strong>: 在布尔上下文中会被认为是 <code>false</code> 的值。</li>
</ul>
<h3><strong>2. 常见的 Falsy 值</strong></h3>
<p>JavaScript 中有以下 6 种 Falsy 值：</p>
<ul>
<li>
<p><strong><code>false</code></strong>: 布尔值 <code>false</code> 本身。</p>
</li>
<li>
<p><strong><code>0</code></strong>: 数字零。</p>
</li>
<li>
<p><strong><code>&#x27;&#x27;</code> 或 <code>&quot;&quot;</code></strong>: 空字符串。</p>
</li>
<li>
<p><strong><code>null</code></strong>: 表示空值或无效的对象引用。</p>
</li>
<li>
<p><strong><code>undefined</code></strong>: 当变量未定义或未赋值时的默认值。</p>
</li>
<li>
<p><strong><code>NaN</code></strong>: 表示“不是一个数字”的特殊数值。</p>
</li>
</ul>
<h3><strong>3. 常见的 Truthy 值</strong></h3>
<p>除了以上列出的 Falsy 值，所有其他值都被认为是 Truthy，包括：</p>
<ul>
<li>
<p><strong>非空字符串</strong>：任何包含字符的字符串。</p>
</li>
<li>
<p><strong>非零数字</strong>：正数、负数、浮点数等。</p>
</li>
<li>
<p><strong><code>true</code></strong>: 布尔值 <code>true</code> 本身。</p>
</li>
<li>
<p><strong>对象和数组</strong>：即使是空对象 <code>{}</code> 和空数组 <code>[]</code> 也是 Truthy 值。</p>
</li>
</ul>
<h3><strong>4. Boolean的隐式转换和使用场景</strong></h3>
<p>在实际操作中，JavaScript 中的布尔值转换通常是<a href="#type-conversion-and-coercion">隐式</a>的（无需使用 <code>Boolean()</code> 函数进行显式类型转换），即 JavaScript 会自动将不同类型的值转换为布尔值（例如，在条件判断中）. (So in practice,the conversion to boolean is always implicit,not explixit,or in other words is always typed coercion that JavaScript does automatically behind the scenes.)</p>
<h4><strong>When exactly does JavaScript do type coercion to booleans?</strong></h4>
<ul>
<li>
<p><strong>使用逻辑操作符时</strong>:</p>
<ul>
<li>例如在使用 <code>&amp;&amp;</code>（逻辑与）、<code>||</code>（逻辑或）、<code>!</code>（逻辑非）时，JavaScript 会自动将值转换为布尔值。</li>
</ul>
</li>
<li>
<p><strong>在逻辑上下文中</strong>:</p>
<ul>
<li>例如在 <code>if / else</code> 语句的条件中，JavaScript 会将条件表达式隐式地转换为布尔值。</li>
</ul>
</li>
</ul>
<h3><strong>5. 实践示例</strong></h3>
<ul>
<li>
<p><strong>判断值是否为 Falsy</strong>：</p>
<pre><code class="language-javascript">let values = [0, &#x27;&#x27;, null, undefined, NaN, false];
values.forEach(value =&gt; {
    if (!value) {
        console.log(`${value} is Falsy`);
    }
});
</code></pre>
</li>
<li>
<p><strong>JavaScript强制类型转换为Boolean</strong>：</p>
<pre><code class="language-javascript">let value = &#x27;0&#x27;;
console.log(!!value); // true
</code></pre>
</li>
</ul>
<h3><strong>6. 注意事项</strong></h3>
<ul>
<li>
<p><strong>避免 Falsy 值误判</strong>: 某些值（如 <code>0</code> 和 <code>&#x27;&#x27;</code>）虽然是有效数据，但在布尔上下文中会被视为 <code>false</code>。要注意在条件判断中使用这些值时可能出现的逻辑错误。</p>
<pre><code class="language-javascript">let height = 0; 
if (height){
    console.log(&quot;Height is defined&quot;);
}else{
    console.log(&quot;Height is UNDEFINED);
}
//当height 赋值 0 时，这是一个有效的数据，但因为数字 0 是falsy值，将直接执行else语句，导致bug.
</code></pre>
</li>
<li>
<p><strong>严格等于 (<code>===</code>) 的使用</strong>：使用严格等于运算符可以避免类型强制转换带来的潜在问题。</p>
<pre><code class="language-javascript">let value = &#x27;0&#x27;;
if (value === 0) {
    console.log(&#x27;This will not print.&#x27;);
}
</code></pre>
</li>
</ul>
<h3><strong>7. 练习题</strong></h3>
<p>通过练习题进一步理解 Truthy 和 Falsy 值的应用。</p>
<pre><code class="language-javascript">// 练习题 1: 结果是什么？
let value = &#x27; &#x27;;
console.log(!!value); // ?

// 练习题 2: 结果是什么？
let value = [];
console.log(!!value); // ?

// 练习题 3: 结果是什么？
let value = &#x27;0&#x27;;
console.log(!!value); // ?
</code></pre>
<h3><strong>8. 复习小结</strong></h3>
<ul>
<li>
<p>牢记 JavaScript 中的 6 种 Falsy 值。熟练判断哪些值为 Truthy。</p>
</li>
<li>
<p>认识到布尔值的转换在 JavaScript 中通常是隐式进行的，即 JavaScript 会在后台自动进行这种类型转换。</p>
</li>
<li>
<p>熟悉 if / else 语句和逻辑操作符中的类型强制转换行为，知道何时 JavaScript 会自动将值转换为布尔值。</p>
</li>
<li>
<p>通过实战练习加深理解，避免潜在的逻辑错误。</p>
</li>
</ul>
<h3><strong>9. 适用场景</strong></h3>
<ul>
<li>
<p>业务场景</p>
<ul>
<li>
<p><strong>1. 表单验证场景</strong></p>
<p><strong>使用 <code>Truthy</code> 和 <code>Falsy</code> 值</strong></p>
<p>在表单验证中，通常需要检查输入是否为空。如果输入为空字符串、<code>null</code> 或 <code>undefined</code>，我们可以直接使用 <code>if (inputValue)</code> 来判断：</p>
<pre><code class="language-javascript">let inputValue = &quot;&quot;; // 用户未填写内容

if (inputValue) {
  console.log(&quot;Valid input&quot;);
} else {
  console.log(&quot;Input is empty&quot;);
}
</code></pre>
<p><strong>没有 <code>Truthy</code> 和 <code>Falsy</code> 值时的代码</strong></p>
<p>如果 JavaScript 没有 <code>Truthy</code> 和 <code>Falsy</code> 值的概念，我们就需要显式地检查所有可能的空值情况：</p>
<pre><code class="language-javascript">let inputValue = &quot;&quot;; // 用户未填写内容

if (inputValue !== &quot;&quot; &amp;&amp; inputValue !== null &amp;&amp; inputValue !== undefined) {
  console.log(&quot;Valid input&quot;);
} else {
  console.log(&quot;Input is empty&quot;);
}
</code></pre>
<p><strong>对比分析</strong></p>
<p>有了 <code>Truthy</code> 和 <code>Falsy</code> 值的机制后，代码更加简洁，只需要一个简单的 <code>if</code> 语句即可。而如果没有这一机制，则需要对所有可能的“空”值进行显式判断，代码更加冗长，也更容易出错。</p>
</li>
<li>
<p><strong>2. 用户认证场景</strong></p>
<p><strong>使用 <code>Truthy</code> 和 <code>Falsy</code> 值</strong></p>
<p>在用户认证时，通常需要检查用户对象是否存在：</p>
<pre><code class="language-javascript">let user = null; // 用户未登录

if (user) {
  console.log(&quot;User is logged in&quot;);
} else {
  console.log(&quot;User is not logged in&quot;);
}
</code></pre>
<p><strong>没有 <code>Truthy</code> 和 <code>Falsy</code> 值时的代码</strong></p>
<p>如果没有 <code>Truthy</code> 和 <code>Falsy</code> 值，我们需要显式检查 <code>user</code> 是否为 <code>null</code> 或 <code>undefined</code>：</p>
<pre><code class="language-javascript">let user = null; // 用户未登录

if (user !== null &amp;&amp; user !== undefined) {
  console.log(&quot;User is logged in&quot;);
} else {
  console.log(&quot;User is not logged in&quot;);
}
</code></pre>
<p><strong>对比分析</strong></p>
<p>有了 <code>Truthy</code> 和 <code>Falsy</code> 值的机制后，用户认证的代码逻辑变得更加简洁，减少了显式检查 <code>null</code> 和 <code>undefined</code> 的复杂性。</p>
</li>
</ul>
</li>
<li>
<p>技术场景</p>
<ul>
<li>
<p><strong>1. 默认参数场景</strong></p>
<p><strong>使用 <code>Truthy</code> 和 <code>Falsy</code> 值</strong></p>
<p>在函数中为参数设置默认值时，可以利用 <code>||</code> 运算符来简化代码：</p>
<pre><code class="language-javascript">function greet(name) {
  name = name || &quot;Guest&quot;;
  console.log(`Hello, ${name}!`);
}

greet(); // &quot;Hello, Guest!&quot;
</code></pre>
<p><strong>没有 <code>Truthy</code> 和 <code>Falsy</code> 值时的代码</strong></p>
<p>如果没有 <code>Truthy</code> 和 <code>Falsy</code> 值，我们需要显式检查参数是否为 <code>undefined</code>：</p>
<pre><code class="language-javascript">function greet(name) {
  if (name === undefined) {
    name = &quot;Guest&quot;;
  }
  console.log(`Hello, ${name}!`);
}

greet(); // &quot;Hello, Guest!&quot;
</code></pre>
<p><strong>对比分析</strong></p>
<p>利用 <code>Truthy</code> 和 <code>Falsy</code> 值的机制，可以在一行代码中完成默认值的设置，而没有这一机制时，则需要进行显式检查，代码变得更加繁琐。</p>
</li>
<li>
<p><strong>2. 循环终止条件场景</strong></p>
<p><strong>使用 <code>Truthy</code> 和 <code>Falsy</code> 值</strong></p>
<p>在遍历链表时，可以利用 <code>Truthy</code> 和 <code>Falsy</code> 值来简化循环条件：</p>
<pre><code class="language-javascript">let node = null; // 假设链表为空

while (node) {
  console.log(node.value);
  node = node.next;
}
</code></pre>
<p><strong>没有 <code>Truthy</code> 和 <code>Falsy</code> 值时的代码</strong></p>
<p>如果没有 <code>Truthy</code> 和 <code>Falsy</code> 值，我们需要显式检查 <code>node</code> 是否为 <code>null</code> 或 <code>undefined</code>：</p>
<pre><code class="language-javascript">let node = null; // 假设链表为空

while (node !== null &amp;&amp; node !== undefined) {
  console.log(node.value);
  node = node.next;
}
</code></pre>
<p><strong>对比分析</strong></p>
<p>有了 <code>Truthy</code> 和 <code>Falsy</code> 值的机制后，循环条件的判断变得更加简洁，不需要显式检查 <code>null</code> 和 <code>undefined</code>。</p>
</li>
<li>
<p><strong>总结：<code>Truthy</code> 和 <code>Falsy</code> 值的目的</strong></p>
<p>通过对比这些代码示例，我们可以看到 <code>Truthy</code> 和 <code>Falsy</code> 值的机制极大地简化了 JavaScript 代码的编写。这一机制减少了显式的类型检查，使得条件判断、参数设置、循环等常见操作更加直观和高效，帮助开发者编写出更简洁、易于维护的代码。</p>
<p>这种简化是 <code>Truthy</code> 和 <code>Falsy</code> 值诞生的主要目的，它们使 JavaScript 在处理不同数据类型时更具灵活性，避免了冗长的类型判断逻辑，从而提高了开发效率。</p>
</li>
</ul>
</li>
</ul>
<h2><strong>Equality Operators: == vs. ===</strong></h2>
<h3><strong>1. 概念</strong></h3>
<p><strong>Equality Operators</strong> 是用来比较两个值是否相等的操作符，主要包括以下两种：</p>
<ul>
<li><strong><code>==</code> (Abstract Equality, 抽象相等)</strong>: 进行类型转换后再比较两个值是否相等。</li>
<li><strong><code>===</code> (Strict Equality, 严格相等)</strong>: 在不进行类型转换的情况下直接比较两个值是否相等。</li>
</ul>
<h3><strong>2. 操作符的区别</strong></h3>
<ul>
<li>
<p><strong><code>==</code> 操作符</strong></p>
<ul>
<li>
<p>当使用 <code>==</code> 进行比较时，如果两个值类型不同，JavaScript 会在比较之前尝试进行类型转换。</p>
</li>
<li>
<p>适用场景：当你明确知道并希望 JavaScript 在比较时自动进行类型转换。</p>
<pre><code class="language-javascript">console.log(2 == &#x27;2&#x27;); // true，字符串 &#x27;2&#x27; 被转换为数字 2
console.log(true == 1); // true，布尔值 true 被转换为数字 1
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong><code>===</code> 操作符</strong></p>
<ul>
<li>
<p>当使用 <code>===</code> 进行比较时，JavaScript 不会进行任何类型转换，只有在值和类型都相同时才会返回 <code>true</code>。</p>
</li>
<li>
<p>适用场景：当你需要严格比较两个值，并避免自动类型转换带来的潜在问题。</p>
<pre><code class="language-javascript">console.log(2 === &#x27;2&#x27;); // false，不同类型的值
console.log(true === 1); // false，不同类型的值
</code></pre>
</li>
</ul>
</li>
</ul>
<h3><strong>3. 适用场景</strong></h3>
<ul>
<li><strong>业务场景</strong>: 在用户输入数据时，可能需要宽松的类型判断（<code>==</code>），例如检查用户输入的数字或字符串。</li>
<li><strong>技术场景</strong>: 在 API 调用中，为了确保数据一致性，需要严格比较两个值（<code>===</code>），避免因类型不一致导致的错误。</li>
</ul>
<h3><strong>4. 实践练习</strong></h3>
<pre><code class="language-javascript">// 练习题 1: 结果是什么？
console.log(&#x27;0&#x27; == false); // true，因为 &#x27;0&#x27; 被转换为 0，再与 false 比较

// 练习题 2: 结果是什么？
console.log(&#x27;&#x27; === false); // false，因为空字符串和 false 类型不同

// 练习题 3: 结果是什么？
let value = 42;
console.log(value == &#x27;42&#x27;); // true，字符串 &#x27;42&#x27; 被转换为数字 42
console.log(value === &#x27;42&#x27;); // false，不同类型的值
</code></pre>
<h3><strong>5. 复习小结</strong></h3>
<ul>
<li><strong><code>==</code> vs. <code>===</code></strong>: 理解它们之间的差异及适用场景非常重要，尽量在代码中使用 <code>===</code> 以确保比较的准确性。</li>
<li><strong>常见误区</strong>: 注意 <code>==</code> 操作符在类型转换中的潜在风险，避免因自动转换导致的错误。</li>
</ul>
<h2><strong>The switch Statement</strong></h2>
<h3><strong>1. 概念理解</strong></h3>
<p><strong><code>switch</code> 语句</strong> 是一种条件控制语句，用于基于不同的表达式值执行不同的代码块。它类似于多个 <code>if...else if</code> 的结构，但在某些情况下，<code>switch</code> 语句可以使代码更简洁和易读。</p>
<h3><strong>2. 基本语法</strong></h3>
<pre><code class="language-javascript">switch (expression) {
    case value1: //expression === value1
        // 当 expression 的值等于 value1 时执行的代码
        break;
    case value2:
        // 当 expression 的值等于 value2 时执行的代码
        break;
    // 你可以有任意多个 case 语句
    default:
        // 如果没有匹配到任何 case，执行此代码
}
</code></pre>
<h3><strong>3. 实践例子</strong></h3>
<pre><code class="language-javascript">let day = 3;

switch (day) {
    case 1:
        console.log(&#x27;Monday&#x27;);
        break;
    case 2:
        console.log(&#x27;Tuesday&#x27;);
        break;
    case 3:
        console.log(&#x27;Wednesday&#x27;);
        break;
    case 4:
        console.log(&#x27;Thursday&#x27;);
        break;
    case 5:
        console.log(&#x27;Friday&#x27;);
        break;
    case 6:
        console.log(&#x27;Saturday&#x27;);
        break;
    case 7:
        console.log(&#x27;Sunday&#x27;);
        break;
    default:
        console.log(&#x27;Invalid day&#x27;);
}
</code></pre>
<p><strong>解释</strong>: 在这个例子中，<code>day</code> 的值为 <code>3</code>，因此控制台将输出 <code>&#x27;Wednesday&#x27;</code>。每个 <code>case</code> 块以 <code>break</code> 语句结束，防止执行后续的 <code>case</code> 块。</p>
<h3><strong>4. 注意事项</strong></h3>
<ul>
<li>
<p><strong><code>break</code> 语句</strong>: 如果省略 <code>break</code>，代码会继续执行后续的 <code>case</code> 块，直到遇到 <code>break</code> 或 <code>switch</code> 语句结束。</p>
</li>
<li>
<p><strong><code>default</code> 块</strong>: 是可选的，但建议使用，确保在没有匹配到任何 <code>case</code> 时有合理的处理。</p>
</li>
<li>
<p><strong>多 <code>case</code> 合并</strong>: 如果多个 <code>case</code> 共享相同的逻辑，可以将它们合并。</p>
<pre><code class="language-javascript">let fruit = &#x27;apple&#x27;;

switch (fruit) {
    case &#x27;apple&#x27;:
    case &#x27;pear&#x27;:
    case &#x27;plum&#x27;:
        console.log(&#x27;This is a pome fruit.&#x27;);
        break;
    case &#x27;orange&#x27;:
    case &#x27;lemon&#x27;:
        console.log(&#x27;This is a citrus fruit.&#x27;);
        break;
    default:
        console.log(&#x27;Unknown fruit.&#x27;);
}
</code></pre>
</li>
</ul>
<p><strong>解释</strong>: <code>apple</code>、<code>pear</code> 和 <code>plum</code> 共享相同的处理逻辑，因此可以合并到一起。</p>
<h3><strong>5. 适用场景</strong></h3>
<ul>
<li>当需要基于单一变量的多个可能值执行不同代码块时，<code>switch</code> 语句通常比 <code>if...else</code> 更清晰。</li>
<li>尤其适用于根据数值、字符串等离散值进行条件判断的情况。</li>
</ul>
<h3><strong>6. 与 <code>if...else</code> 的对比</strong></h3>
<ul>
<li><strong>可读性</strong>: 当有大量 <code>case</code> 需要判断时，<code>switch</code> 语句使得代码更易于阅读。</li>
<li><strong>性能</strong>: 对于简单的条件判断，两者性能差异不大；但在复杂判断中，<code>switch</code> 可能更高效。</li>
</ul>
<h3><strong>7. 常见错误</strong></h3>
<ul>
<li>忘记 <code>break</code> 语句：导致“fall-through”行为，即代码会继续执行下一个 <code>case</code>。</li>
<li>忘记 <code>default</code> 块：没有考虑到所有可能的情况，导致错误处理。</li>
</ul>
<h3><strong>8. 复习小结</strong></h3>
<ul>
<li>理解 <code>switch</code> 语句的结构和基本用法。</li>
<li>知道如何使用 <code>break</code> 和 <code>default</code> 块进行流程控制。</li>
<li>了解 <code>switch</code> 在多值判断中的优势和适用场景。</li>
</ul>
<h2><strong>The Conditional (Ternary) Operator</strong></h2>
<h3><strong>1. 概念理解</strong></h3>
<p><strong>The Conditional (Ternary) Operator</strong> 是 JavaScript 中唯一的三元运算符，它提供了一种简洁的方式来替代简单的 <code>if...else</code> 语句。三元运算符的语法非常紧凑，可以将一个条件判断和两个可能的结果压缩到一行代码中。</p>
<h3><strong>2. 基本语法</strong></h3>
<pre><code class="language-javascript">condition ? exprIfTrue : exprIfFalse;
</code></pre>
<ul>
<li><strong><code>condition</code></strong>: 布尔表达式。如果条件为 <code>true</code>，则返回 <code>exprIfTrue</code>；如果条件为 <code>false</code>，则返回 <code>exprIfFalse</code>。</li>
<li><strong><code>exprIfTrue</code></strong>: 当 <code>condition</code> 为 <code>true</code> 时执行的表达式或返回的值。</li>
<li><strong><code>exprIfFalse</code></strong>: 当 <code>condition</code> 为 <code>false</code> 时执行的表达式或返回的值。</li>
</ul>
<h3><strong>3. Ternary Operator 与 Template Literals 的结合</strong></h3>
<p>在实际开发中，<code>ternary operator</code> 和 <a href="#strings-and-template-literals"><code>template literals</code></a> 经常结合使用，特别是在构建字符串时。</p>
<pre><code class="language-javascript">let user = {
  name: &#x27;Alice&#x27;,
  age: 25
};

let message = `Hello, ${user.name}. You are ${user.age &gt;= 18 ? &#x27;an adult&#x27; : &#x27;not an adult&#x27;}.`;
console.log(message); // 输出: &quot;Hello, Alice. You are an adult.&quot;
</code></pre>
<p><strong>解释</strong>: 在这个例子中，我们将三元运算符嵌入到模板字符串（template literals）中，使得根据条件动态生成字符串变得非常直观。</p>
<h3><strong>4. Statements 与 Expressions 的区别</strong></h3>
<ul>
<li>
<p><strong>Statements</strong>: 是执行某些动作的代码块，通常不会返回值。例如，<code>if...else</code> 语句就是一个典型的 statement。</p>
<pre><code class="language-javascript">if (age &gt;= 18) {
    console.log(&#x27;You are an adult&#x27;);
} else {
    console.log(&#x27;You are not an adult&#x27;);
}
</code></pre>
</li>
<li>
<p><strong>Expressions</strong>: 是产生值的代码片段，它们总会返回一个值。例如变量、运算、函数调用等。<code>ternary operator</code> 就是一个典型的 expression。</p>
<pre><code class="language-javascript">let message = age &gt;= 18 ? &#x27;You are an adult&#x27; : &#x27;You are not an adult&#x27;;
</code></pre>
</li>
</ul>
<p><strong>关键区别</strong>: Statements 不能用作模板字符串中的内嵌逻辑，而 expressions 可以。因此，在需要返回一个值的情况下，尤其是在模板字符串中，使用 expressions 更为合适。</p>
<h3><strong>5. 常见错误</strong></h3>
<ul>
<li>
<p><strong>误用三元运算符</strong>: 将三元运算符用于复杂逻辑时，容易导致代码难以理解，应该避免。</p>
<pre><code class="language-javascript">// 不推荐的写法
let result = condition1 ? value1 : condition2 ? value2 : value3;

// 推荐的写法
let result;
if (condition1) {
    result = value1;
} else if (condition2) {
    result = value2;
} else {
    result = value3;
}
</code></pre>
</li>
</ul>
<h3><strong>6. 相关练习题</strong></h3>
<p>通过练习题巩固对三元运算符及其与模板字符串结合使用的理解。</p>
<pre><code class="language-javascript">// 练习题 1: 结果是什么？
let score = 85;
let gradeMessage = `Your grade is ${score &gt; 90 ? &#x27;A&#x27; : score &gt; 75 ? &#x27;B&#x27; : &#x27;C&#x27;}`;
console.log(gradeMessage); // 输出: &quot;Your grade is B&quot;

// 练习题 2: 结果是什么？
let number = 10;
let resultMessage = `The number is ${number % 2 === 0 ? &#x27;Even&#x27; : &#x27;Odd&#x27;}`;
console.log(resultMessage); // 输出: &quot;The number is Even&quot;
</code></pre>
<h3><strong>7. 复习小结</strong></h3>
<ul>
<li>理解 ternary operator 和 template literals 的基本用法，并掌握二者结合使用的场景。</li>
<li>熟悉 statements 和 expressions 的区别，知道何时应该使用哪种结构。</li>
</ul>
<h2><strong>Activating Strict Mode</strong></h2>
<h3><strong>1. 概念理解</strong></h3>
<p><strong>Strict Mode（严格模式）</strong> 是 JavaScript 的一种运行模式，通过在代码中添加特定的声明，可以更严格地检查代码质量并消除潜在的错误。</p>
<h3><strong>2. 启用 Strict Mode</strong></h3>
<p>要启用严格模式，可以在脚本或函数的开头添加 <code>&quot;use strict&quot;;</code> 声明：</p>
<pre><code class="language-javascript">&quot;use strict&quot;; // 整个脚本启用严格模式

function myFunction() {
    &quot;use strict&quot;; // 仅在该函数内部启用严格模式
    // 代码块
}
</code></pre>
<h3><strong>3. 严格模式的优势</strong></h3>
<ul>
<li>
<p><strong>避免意外全局变量</strong>: 在严格模式下，所有变量必须先声明再使用，否则会抛出错误。</p>
<pre><code class="language-javascript">&quot;use strict&quot;;
x = 3.14; // 抛出 ReferenceError: x is not defined
</code></pre>
</li>
<li>
<p><strong>消除静默错误</strong>: 在非严格模式下，某些代码错误不会抛出异常，而在严格模式下，这些错误会被检测到并抛出异常。</p>
<pre><code class="language-javascript">&quot;use strict&quot;;

let hasCard = false;
let isAdult = true;

if (isAdult) hacard = true;
if (hasCard) console(&quot;hah&quot;);// 严格模式下将抛出 ReferenceError: hacard is not defined 而非静默错误。
</code></pre>
</li>
<li>
<p><strong>禁用某些功能</strong>: 禁用了一些可能导致代码混淆或不安全的功能，例如 <code>with</code> 语句。</p>
<pre><code class="language-javascript">&quot;use strict&quot;;
with (Math) { x = cos(2); } // 抛出 SyntaxError: Strict mode code may not include a with statement
</code></pre>
</li>
<li>
<p><strong>提前检测错误</strong>: 在开发过程中更早地发现错误，使得代码更健壮。</p>
</li>
</ul>
<h3><strong>4. 注意事项</strong></h3>
<ul>
<li>
<p><strong>兼容性</strong>: 严格模式不向后兼容，启用后可能导致老代码无法正常运行，因此在启用前应确保代码符合严格模式的要求。</p>
</li>
<li>
<p><strong>结合模块</strong>: 在 ES6 模块中，严格模式是默认启用的，因此无需额外声明。
的检查，但总体上对大多数应用程序的性能影响可以忽略不计。</p>
</li>
</ul>
<h3><strong>5. 实践例子</strong></h3>
<pre><code class="language-javascript">&quot;use strict&quot;;

function strictFunction() {
    &quot;use strict&quot;;
    let y = 3.14; // 正确：严格模式下变量必须声明
}

function nonStrictFunction() {
    x = 3.14; // 错误：严格模式下会抛出 ReferenceError: x is not defined
}

strictFunction();
nonStrictFunction();
</code></pre>
<p><strong>解释</strong>: 代码中 <code>strictFunction</code> 启用了严格模式，因此未声明的变量 <code>y</code> 会导致错误。而 <code>nonStrictFunction</code> 如果没有启用严格模式，允许未声明的变量 <code>x</code> 直接赋值。</p>
<h3><strong>6. 相关练习题</strong></h3>
<p>通过练习题进一步理解严格模式的应用场景和限制。</p>
<pre><code class="language-javascript">// 练习题 1: 结果是什么？
&quot;use strict&quot;;
a = 10;
console.log(a); // ?

// 练习题 2: 结果是什么？
function strictTest() {
    &quot;use strict&quot;;
    var obj = {};
    Object.defineProperty(obj, &quot;x&quot;, { value: 42, writable: false });
    obj.x = 9; // ?
}

strictTest();
</code></pre>
<h3><strong>7. 复习小结</strong></h3>
<ul>
<li>理解严格模式的用途及其在提升代码质量方面的作用。</li>
<li>了解如何在脚本或函数中启用严格模式，并认识到其局限性。</li>
</ul>
<h2><strong>Functions</strong></h2>
<h3><strong>1. 概念理解</strong></h3>
<p><strong>函数（Function）</strong> 是一段可以被重复调用的代码块，它可以接受输入（参数），执行特定操作，并返回输出（结果）。</p>
<h3><strong>2. 函数的声明与表达式</strong></h3>
<h4>2.1. <strong>函数声明（Function Declaration）</strong></h4>
<p>函数声明是定义函数的一种方式，它可以在定义之前调用，具有提升特性。</p>
<pre><code class="language-javascript">function greet(name) {
    return `Hello, ${name}!`;
}

console.log(greet(&#x27;Alice&#x27;)); // 输出: Hello, Alice!
</code></pre>
<p><strong>特点</strong>:</p>
<ul>
<li>提升特性：函数声明会在代码执行前被提升，因此可以在函数声明之前调用。</li>
<li>可读性高：通常用于定义独立的、通用的功能。</li>
</ul>
<h4>2.2. <strong>函数表达式（Function Expression）</strong></h4>
<p>函数表达式是将函数作为一个值赋给变量的一种方式。与函数声明不同，函数表达式不会被提升。</p>
<pre><code class="language-javascript">const greet = function(name) {
    return `Hello, ${name}!`;
};

console.log(greet(&#x27;Bob&#x27;)); // 输出: Hello, Bob!
</code></pre>
<p><strong>特点</strong>:</p>
<ul>
<li>无提升特性：必须在函数表达式之后才能调用。</li>
<li>灵活性高：常用于回调函数或将函数作为参数传递的场景。</li>
</ul>
<h4>2.3. <strong>箭头函数（Arrow Function）</strong></h4>
<p>箭头函数是 ES6 引入的语法，更加简洁，并且没有自己的 <code>this</code> 值。</p>
<pre><code class="language-javascript">const greet = (name) =&gt; `Hello, ${name}!`;

console.log(greet(&#x27;Charlie&#x27;)); // 输出: Hello, Charlie!
</code></pre>
<p><strong>特点</strong>:</p>
<ul>
<li>简洁语法：适合简单的函数定义。</li>
<li>没有 <code>this</code> 值：适合在不需要 <code>this</code> 绑定的场景使用。</li>
</ul>
<p><strong>总结</strong>：Three different ways of writing functions, but they all work in a
similar way: receive input data, transform data, and then output data.</p>
<h3><strong>3. 函数参数</strong></h3>
<h4>3.1. <strong>默认参数（Default Parameters）</strong></h4>
<p>在函数定义时，可以为参数指定默认值，当调用时未传递该参数时会使用默认值。</p>
<pre><code class="language-javascript">function greet(name = &#x27;stranger&#x27;) {
    return `Hello, ${name}!`;
}

console.log(greet()); // 输出: Hello, stranger!
</code></pre>
<h4>3.2. <strong>参数解构（Destructuring Parameters）</strong></h4>
<p>可以通过解构赋值直接在函数参数中拆解对象或数组。</p>
<pre><code class="language-javascript">function display({name, age}) {
    console.log(`Name: ${name}, Age: ${age}`);
}

const person = { name: &#x27;David&#x27;, age: 25 };
display(person); // 输出: Name: David, Age: 25
</code></pre>
<h3><strong>4. 函数的返回值</strong></h3>
<p>函数可以通过 <code>return</code> 语句返回一个值。如果没有 <code>return</code>，则返回 <code>undefined</code>。return statement to output a value from the function and terminate execution.</p>
<pre><code class="language-javascript">function add(a, b) {
    return a + b;
}

console.log(add(2, 3)); // 输出: 5
</code></pre>
<h3><strong>5. 函数的作用域与闭包</strong></h3>
<h4>5.1. <strong>作用域（Scope）</strong></h4>
<p>作用域决定了变量的可访问范围。在 JavaScript 中，函数内部定义的变量在函数外部是不可访问的。</p>
<pre><code class="language-javascript">function scopeTest() {
    let x = 10;
    console.log(x); // 输出: 10
}
console.log(x); // 抛出 ReferenceError: x is not defined
</code></pre>
<h4>5.2. <strong>闭包（Closure）</strong></h4>
<p>闭包是指函数可以访问其定义时所在的作用域中的变量，即使这个函数是在该作用域外部执行的。</p>
<pre><code class="language-javascript">function outer() {
    let outerVar = &#x27;I am from outer function&#x27;;

    function inner() {
        console.log(outerVar); // 输出: I am from outer function
    }

    return inner;
}

const innerFunc = outer();
innerFunc();
</code></pre>
<h3><strong>6. 常见问题与注意事项</strong></h3>
<ul>
<li><strong>函数提升</strong>: 函数声明会被提升，但函数表达式不会。使用时需注意函数的定义顺序。</li>
<li><strong><code>this</code> 绑定</strong>: 箭头函数没有自己的 <code>this</code>，它的 <code>this</code> 值由外层作用域决定，适用于需要继承外部 <code>this</code> 的情况。</li>
<li><strong>过度参数</strong>: 如果传递的参数多于函数定义的参数，多余的参数会被忽略。</li>
</ul>
<h3><strong>7. 相关练习题</strong></h3>
<p>通过练习题进一步理解函数的概念与应用。</p>
<pre><code class="language-javascript">// 练习题 1: 结果是什么？
function multiply(x, y = 5) {
    return x * y;
}

console.log(multiply(2)); // ?

// 练习题 2: 结果是什么？
const sayHello = function(name) {
    return `Hello, ${name}`;
};

console.log(sayHello(&#x27;Alice&#x27;)); // ?

// 练习题 3: 结果是什么？
const double = x =&gt; x * 2;
console.log(double(3)); // ?
</code></pre>
<h3><strong>8. 复习小结</strong></h3>
<ul>
<li>理解函数声明与表达式的差异，以及它们在代码中的适用场景。</li>
<li>掌握函数参数的使用方式，包括默认参数和解构赋值。</li>
<li>理解函数的作用域与闭包的概念，了解它们在 JavaScript 中的重要性。</li>
</ul>
<h2><strong>Basic Array Operations (Methods)</strong></h2>
<h3>1. <strong>概念概述</strong></h3>
<p><strong>数组（Array）</strong> 是一种数据结构，用于存储多个值的有序集合。JavaScript 中的数组是动态的，可以包含不同类型的元素。</p>
<pre><code class="language-javascript">const numbers = [10, 20, 30, 40];
const mixedArray = [10, &#x27;hello&#x27;, true, null];
</code></pre>
<h3>2. <strong>创建数组</strong></h3>
<p>记录几种常用的创建数组的方式。</p>
<ul>
<li>
<p><strong>字面量创建</strong>：</p>
<pre><code class="language-javascript">const arr = [1, 2, 3];
</code></pre>
</li>
<li>
<p><strong>使用 <code>Array</code> 构造函数</strong>：</p>
<pre><code class="language-javascript">const arr = new Array(5); // 创建一个长度为5的空数组
const arr2 = new Array(1, 2, 3); // 创建一个包含元素1, 2, 3的数组
</code></pre>
</li>
</ul>
<h3>3. <strong>基本数组操作</strong></h3>
<p>记录数组中常见的操作方法及其使用场景。</p>
<h4><strong>3.1. 添加和删除元素</strong></h4>
<ul>
<li>
<p><strong><code>push()</code></strong>: 在数组末尾添加一个或多个元素，并返回新数组的长度。</p>
<pre><code class="language-javascript">const fruits = [&#x27;apple&#x27;, &#x27;banana&#x27;];
fruits.push(&#x27;orange&#x27;); // [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;orange&#x27;]
</code></pre>
</li>
<li>
<p><strong><code>pop()</code></strong>: 删除数组末尾的一个元素，并返回该元素。</p>
<pre><code class="language-javascript">const lastFruit = fruits.pop(); // &#x27;orange&#x27;, 剩余 [&#x27;apple&#x27;, &#x27;banana&#x27;]
</code></pre>
</li>
<li>
<p><strong><code>unshift()</code></strong>: 在数组开头添加一个或多个元素，并返回新数组的长度。</p>
<pre><code class="language-javascript">fruits.unshift(&#x27;strawberry&#x27;); // [&#x27;strawberry&#x27;, &#x27;apple&#x27;, &#x27;banana&#x27;]
</code></pre>
</li>
<li>
<p><strong><code>shift()</code></strong>: 删除数组开头的一个元素，并返回该元素。</p>
<pre><code class="language-javascript">const firstFruit = fruits.shift(); // &#x27;strawberry&#x27;, 剩余 [&#x27;apple&#x27;, &#x27;banana&#x27;]
</code></pre>
</li>
</ul>
<h4><strong>3.2. 查找和索引操作</strong></h4>
<ul>
<li>
<p><strong><code>indexOf()</code></strong>: 返回数组中某个元素的第一个匹配项的索引，如果没有找到则返回 <code>-1</code>。</p>
<pre><code class="language-javascript">const index = fruits.indexOf(&#x27;banana&#x27;); // 1
</code></pre>
</li>
<li>
<p><strong><code>includes()</code></strong>: 判断数组是否包含某个元素，返回布尔值。</p>
<pre><code class="language-javascript">const hasApple = fruits.includes(&#x27;apple&#x27;); // true
</code></pre>
</li>
</ul>
<h4><strong>3.3. 数组遍历</strong></h4>
<ul>
<li>
<p><strong><code>forEach()</code></strong>: 对数组中的每个元素执行一次提供的函数。</p>
<pre><code class="language-javascript">fruits.forEach(fruit =&gt; console.log(fruit));
</code></pre>
</li>
<li>
<p><strong><code>map()</code></strong>: 创建一个新数组，其结果是该数组中的每个元素调用提供的函数的返回值。</p>
<pre><code class="language-javascript">const uppercasedFruits = fruits.map(fruit =&gt; fruit.toUpperCase());
// [&#x27;APPLE&#x27;, &#x27;BANANA&#x27;]
</code></pre>
</li>
</ul>
<h3>4. <strong>数组方法的应用场景</strong></h3>
<ul>
<li>
<p><strong><code>push()</code> 和 <code>pop()</code></strong>: 常用于管理栈（LIFO，后进先出）数据结构。</p>
</li>
<li>
<p><strong><code>unshift()</code> 和 <code>shift()</code></strong>: 常用于管理队列（FIFO，先进先出）数据结构。</p>
</li>
<li>
<p><strong><code>map()</code> 和 <code>forEach()</code></strong>: 常用于对数组中的元素进行批量操作，比如格式化数据、创建新数组等。</p>
</li>
</ul>
<h3>5. <strong>实际案例</strong></h3>
<p>结合业务需求记录一些实际使用数组操作的方法：</p>
<p><strong>示例：从一个用户列表中获取所有用户的名字并转换为大写字母：</strong></p>
<pre><code class="language-javascript">const users = [
  { name: &#x27;Alice&#x27;, age: 30 },
  { name: &#x27;Bob&#x27;, age: 25 },
  { name: &#x27;Charlie&#x27;, age: 35 }
];

const userNames = users.map(user =&gt; user.name.toUpperCase());
console.log(userNames); // [&#x27;ALICE&#x27;, &#x27;BOB&#x27;, &#x27;CHARLIE&#x27;]
</code></pre>
<h3>6. <strong>练习题</strong></h3>
<pre><code class="language-javascript">// 练习题 1: 给定一个数组 [3, 5, 7, 9]，使用数组方法删除最后一个元素，并在开头添加一个元素 1。

// 练习题 2: 使用 map() 方法将以下数组 [2, 4, 6, 8] 中的每个数字乘以 2，生成一个新数组。
</code></pre>
<h3>7. <strong>复习总结</strong></h3>
<ul>
<li>了解数组的基本概念和创建方法。</li>
<li>熟悉常见数组操作方法的使用场景及其区别。</li>
</ul>
<h2><strong>Objects</strong></h2>
<h3>1. <strong>概念概述</strong></h3>
<p><strong>对象（Object）</strong> 是一种数据结构，用于存储键值对（key-value pairs）。在JavaScript中，对象是一种重要的数据类型，几乎所有非原始值都是对象，包括数组、函数等。</p>
<pre><code class="language-javascript">const person = {
  name: &#x27;John&#x27;,
  age: 30,
  job: &#x27;Engineer&#x27;
};
</code></pre>
<h3>2. <strong>创建对象</strong></h3>
<p>记录几种常用的创建对象的方式。</p>
<ul>
<li>
<p><strong>对象字面量</strong>：</p>
<pre><code class="language-javascript">const car = {
  brand: &#x27;Toyota&#x27;,
  model: &#x27;Camry&#x27;,
  year: 2020
};
</code></pre>
</li>
<li>
<p><strong>使用 <code>new Object()</code> 构造函数</strong>：</p>
<pre><code class="language-javascript">const car = new Object();
car.brand = &#x27;Toyota&#x27;;
car.model = &#x27;Camry&#x27;;
car.year = 2020;
</code></pre>
</li>
</ul>
<h3>3. <strong>对象属性操作</strong></h3>
<p>记录对象的属性访问、修改和删除方法。</p>
<ul>
<li>
<p><strong>访问属性</strong>：</p>
<ul>
<li>
<p>点表示法：</p>
<p>仅在你知道属性的确切名称且不包含特殊字符时有效。</p>
</li>
<li>
<p>方括号表示法：</p>
<p>当属性名存储在变量中或属性名包含不适合点表示法的字符（如空格或连字符）时使用。</p>
<pre><code class="language-javascript">console.log(car[&#x27;brand&#x27;]); // 输出: Toyota

// 使用变量访问
let prop = &#x27;year&#x27;;
console.log(person[prop]); // 输出: 2020
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>添加或修改属性</strong>：</p>
<pre><code class="language-javascript">person.job = &#x27;Developer&#x27;; // 修改现有属性
person.country = &#x27;USA&#x27;; // 添加新属性
</code></pre>
</li>
<li>
<p><strong>删除属性</strong>：</p>
<pre><code class="language-javascript">delete person.age; // 删除 age 属性
</code></pre>
</li>
</ul>
<h3>4. <strong>对象的方法</strong></h3>
<p>记录如何在对象中定义和使用方法。</p>
<ul>
<li>
<p><strong>定义对象方法</strong>：</p>
<pre><code class="language-javascript">const calculator = {
  add: function(a, b) {
    return a + b;
  },
  subtract(a, b) {
    return a - b;
  }
};

console.log(calculator.add(5, 3)); // 8
console.log(calculator.subtract(5, 3)); // 2
</code></pre>
</li>
</ul>
<h3>5. <strong>对象的遍历</strong></h3>
<p>记录如何遍历对象的属性。</p>
<ul>
<li>
<p><strong><code>for...in</code> 循环</strong>：</p>
<pre><code class="language-javascript">for (let key in person) {
  console.log(`${key}: ${person[key]}`);
}
</code></pre>
</li>
<li>
<p><strong><code>Object.keys()</code> 和 <code>Object.values()</code></strong>：</p>
<pre><code class="language-javascript">const keys = Object.keys(person); // [&#x27;name&#x27;, &#x27;job&#x27;, &#x27;country&#x27;]
const values = Object.values(person); // [&#x27;John&#x27;, &#x27;Developer&#x27;, &#x27;USA&#x27;]
</code></pre>
</li>
</ul>
<h3>6. <strong>对象的复制与合并</strong></h3>
<p>记录对象复制和合并的方法。</p>
<ul>
<li>
<p><strong>浅拷贝</strong>：</p>
<ul>
<li>
<p>使用 <code>Object.assign()</code>：</p>
<pre><code class="language-javascript">const newPerson = Object.assign({}, person);
</code></pre>
</li>
<li>
<p>使用展开运算符 <code>...</code>：</p>
<pre><code class="language-javascript">const newPerson = { ...person };
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>对象合并</strong>：</p>
<pre><code class="language-javascript">const car = { brand: &#x27;Toyota&#x27; };
const details = { model: &#x27;Camry&#x27;, year: 2020 };
const fullCar = { ...car, ...details };
</code></pre>
</li>
</ul>
<h3>7. <strong>实际应用场景</strong></h3>
<p>记录一些结合业务需求的实际对象使用案例：</p>
<p><strong>示例：在用户管理系统中存储和操作用户信息：</strong></p>
<pre><code class="language-javascript">const user = {
  id: 1,
  name: &#x27;Alice&#x27;,
  email: &#x27;alice@example.com&#x27;,
  login() {
    console.log(`${this.name} has logged in.`);
  }
};

user.login(); // &#x27;Alice has logged in.&#x27;
</code></pre>
<h3>8. <strong>练习题</strong></h3>
<p>为巩固学习效果，加入一些练习题：</p>
<pre><code class="language-javascript">// 练习题 1: 创建一个对象，该对象代表一本书，并包含书名、作者和出版年份属性。

// 练习题 2: 向已创建的书对象添加一个新的属性 &#x27;genre&#x27;，并将其值设置为 &#x27;Fiction&#x27;。
</code></pre>
<h3>9. <strong>复习总结</strong></h3>
<ul>
<li>了解对象的基本概念和创建方式。</li>
<li>熟悉对象属性的访问、修改和删除方法。</li>
<li>通过遍历和合并操作掌握对对象的全面控制。</li>
</ul>
<h2><strong>Object Methods</strong></h2>
<h3><strong>1. 定义：</strong></h3>
<ul>
<li><strong>Object Methods</strong> 是对象的属性，其值为函数。方法允许对象执行操作，并能够访问和操作对象的数据。</li>
</ul>
<h3><strong>2. 创建方法：</strong></h3>
<ul>
<li>
<p>在对象中，可以直接将函数定义为属性，这个属性就称为方法。</p>
<pre><code class="language-javascript">const person = {
  firstName: &#x27;John&#x27;,
  lastName: &#x27;Doe&#x27;,
  age: 30,
  job: &#x27;Developer&#x27;,
  
  // 定义方法
  fullName: function() {
    return `${this.firstName} ${this.lastName}`;
  }
};

console.log(person.fullName()); // 输出: John Doe
</code></pre>
</li>
</ul>
<h3><strong>3. <code>this</code> 关键字：</strong></h3>
<ul>
<li>
<p>在方法中，<code>this</code> 关键字引用的是调用该方法的对象本身。这使得方法可以访问对象的其他属性。</p>
<pre><code class="language-javascript">const person = {
  firstName: &#x27;John&#x27;,
  lastName: &#x27;Doe&#x27;,
  age: 30,
  job: &#x27;Developer&#x27;,

  fullName: function() {
    return `${this.firstName} ${this.lastName}`;
  },
  
  isAdult: function() {
    return this.age &gt;= 18;
  }
};

console.log(person.isAdult()); // 输出: true
</code></pre>
</li>
</ul>
<h3><strong>4. 简写方法语法：</strong></h3>
<ul>
<li>
<p>ES6 引入了简写语法，可以使方法定义更加简洁。</p>
<pre><code class="language-javascript">const person = {
  firstName: &#x27;John&#x27;,
  lastName: &#x27;Doe&#x27;,
  age: 30,
  
  // 简写方法
  fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
};

console.log(person.fullName()); // 输出: John Doe
</code></pre>
</li>
</ul>
<h3><strong>5. 使用对象方法：</strong></h3>
<ul>
<li>
<p>对象方法可以在代码中被调用来执行特定的操作。方法通常用于处理与对象相关的数据。</p>
<p><strong>示例：</strong></p>
<pre><code class="language-javascript">const car = {
  brand: &#x27;Toyota&#x27;,
  model: &#x27;Camry&#x27;,
  year: 2020,

  getCarInfo() {
    return `${this.brand} ${this.model}, ${this.year}`;
  }
};

console.log(car.getCarInfo()); // 输出: Toyota Camry, 2020
</code></pre>
</li>
</ul>
<h3><strong>6. 常见应用场景：</strong></h3>
<ul>
<li><strong>数据验证：</strong> 使用方法来检查对象属性的值是否有效。</li>
<li><strong>数据格式化：</strong> 使用方法来格式化或组合对象中的多个属性。</li>
<li><strong>业务逻辑：</strong> 方法可以封装对象相关的业务逻辑，如计算或决策。</li>
</ul>
<h3><strong>7. 复习小结：</strong></h3>
<ul>
<li><strong>Object Methods</strong> 是对象中功能强大的组成部分，可以对对象数据进行操作和处理。</li>
<li>理解 <code>this</code> 关键字在方法中的作用至关重要，因为它决定了方法如何访问对象属性。</li>
</ul>
<h3><strong>8. 相关练习题：</strong></h3>
<ul>
<li>
<p>创建一个 <code>book</code> 对象，包含 <code>title</code>、<code>author</code> 和 <code>year</code> 属性，以及一个 <code>getSummary</code> 方法，返回一本书的摘要信息。</p>
<p><strong>示例：</strong></p>
<pre><code class="language-javascript">const book = {
  title: &#x27;1984&#x27;,
  author: &#x27;George Orwell&#x27;,
  year: 1949,

  getSummary() {
    return `${this.title} by ${this.author}, published in ${this.year}.`;
  }
};

console.log(book.getSummary()); // 输出: 1984 by George Orwell, published in 1949.
</code></pre>
</li>
</ul>
<h2><strong>Loops</strong></h2>
<h3><strong>1. 概念概述</strong></h3>
<p><strong>循环（Loop）</strong> 是一种控制结构，用于重复执行一段代码，直到满足特定条件为止。循环在处理需要重复操作的数据集或任务时尤为有用，例如遍历数组、处理用户输入等。</p>
<h3><strong>2. 常见的循环类型</strong></h3>
<h4><strong>2.1. <code>for</code> 循环</strong></h4>
<p><strong>语法：</strong></p>
<pre><code class="language-javascript">for (初始化; 条件; 更新) {
    // 循环体
}
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-javascript">for (let i = 0; i &lt; 5; i++) {
    console.log(`当前循环次数: ${i}`);
}
// 输出:
// 当前循环次数: 0
// 当前循环次数: 1
// 当前循环次数: 2
// 当前循环次数: 3
// 当前循环次数: 4
</code></pre>
<p><strong>应用场景：</strong></p>
<ul>
<li>已知循环次数时使用，例如遍历数组的索引。</li>
</ul>
<h4><strong>2.2. <code>while</code> 循环</strong></h4>
<p><strong>语法：</strong></p>
<pre><code class="language-javascript">while (条件) {
    // 循环体
}
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-javascript">let i = 0;
while (i &lt; 5) {
    console.log(`当前循环次数: ${i}`);
    i++;
}
// 输出同上
</code></pre>
<p><strong>应用场景：</strong></p>
<ul>
<li>循环次数未知，需要根据某个条件来决定何时停止。</li>
</ul>
<h4><strong>2.3. <code>do...while</code> 循环</strong></h4>
<p><strong>语法：</strong></p>
<pre><code class="language-javascript">do {
    // 循环体
} while (条件);
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-javascript">let i = 0;
do {
    console.log(`当前循环次数: ${i}`);
    i++;
} while (i &lt; 5);
// 输出同上
</code></pre>
<p><strong>特点：</strong></p>
<ul>
<li>至少执行一次循环体，因为条件在循环体之后判断。</li>
</ul>
<h4><strong>2.4. <code>for...in</code> 循环</strong></h4>
<p><strong>语法：</strong></p>
<pre><code class="language-javascript">for (let key in object) {
    // 循环体
}
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-javascript">const person = { name: &#x27;Alice&#x27;, age: 25, city: &#x27;New York&#x27; };
for (let key in person) {
    console.log(`${key}: ${person[key]}`);
}
// 输出:
// name: Alice
// age: 25
// city: New York
</code></pre>
<p><strong>应用场景：</strong></p>
<ul>
<li>遍历对象的可枚举属性。</li>
</ul>
<h4><strong>2.5. <code>for...of</code> 循环</strong></h4>
<p><strong>语法：</strong></p>
<pre><code class="language-javascript">for (let element of iterable) {
    // 循环体
}
</code></pre>
<p><strong>示例：</strong></p>
<pre><code class="language-javascript">const fruits = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;];
for (let fruit of fruits) {
    console.log(fruit);
}
// 输出:
// apple
// banana
// cherry
</code></pre>
<p><strong>应用场景：</strong></p>
<ul>
<li>遍历数组、字符串、Map、Set 等可迭代对象。</li>
</ul>
<h3><strong>3. 循环控制</strong></h3>
<h4><strong>3.1. <code>break</code> 语句</strong></h4>
<p><strong>作用：</strong></p>
<ul>
<li>立即退出当前循环，终止循环的执行。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-javascript">for (let i = 0; i &lt; 10; i++) {
    if (i === 5) {
        break;
    }
    console.log(i);
}
// 输出: 0, 1, 2, 3, 4
</code></pre>
<h4><strong>3.2. <code>continue</code> 语句</strong></h4>
<p><strong>作用：</strong></p>
<ul>
<li>跳过当前循环的剩余部分，立即开始下一次循环迭代。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-javascript">for (let i = 0; i &lt; 5; i++) {
    if (i === 2) {
        continue;
    }
    console.log(i);
}
// 输出: 0, 1, 3, 4
</code></pre>
<h3><strong>4. 嵌套循环</strong></h3>
<p><strong>定义：</strong></p>
<ul>
<li>在一个循环的内部再嵌套一个或多个循环。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="language-javascript">for (let i = 1; i &lt;= 3; i++) {
    for (let j = 1; j &lt;= 2; j++) {
        console.log(`外层循环: ${i}, 内层循环: ${j}`);
    }
}
// 输出:
// 外层循环: 1, 内层循环: 1
// 外层循环: 1, 内层循环: 2
// 外层循环: 2, 内层循环: 1
// 外层循环: 2, 内层循环: 2
// 外层循环: 3, 内层循环: 1
// 外层循环: 3, 内层循环: 2
</code></pre>
<p><strong>注意事项：</strong></p>
<ul>
<li>嵌套循环可能导致性能问题，尤其是在处理大数据集时，应谨慎使用。</li>
</ul>
<h3><strong>5. 循环中的作用域和性能</strong></h3>
<ul>
<li>
<p><strong>作用域：</strong></p>
<ul>
<li>循环内部声明的变量（如 <code>let</code>）仅在循环体内有效，使用 <code>var</code> 声明的变量则具有函数作用域。</li>
</ul>
</li>
<li>
<p><strong>性能优化：</strong></p>
<ul>
<li>尽量减少循环内部的计算和操作，提升代码执行效率。</li>
<li>对于大型数据集，考虑使用更高效的算法或方法（如数组的内建方法 <code>map</code>、<code>filter</code> 等）。</li>
</ul>
</li>
</ul>
<h3><strong>6. 实际案例</strong></h3>
<p>示例 1：<strong>遍历数组并计算总和</strong></p>
<pre><code class="language-javascript">const numbers = [10, 20, 30, 40, 50];
let total = 0;
for (let i = 0; i &lt; numbers.length; i++) {
    total += numbers[i];
}
console.log(`总和: ${total}`); // 输出: 总和: 150
</code></pre>
<p>示例 2：<strong>查找对象中满足条件的属性</strong></p>
<pre><code class="language-javascript">const scores = { Alice: 85, Bob: 92, Charlie: 78, David: 90 };
for (let student in scores) {
    if (scores[student] &gt;= 90) {
        console.log(`${student} 获得了优秀成绩: ${scores[student]}`);
    }
}
// 输出:
// Bob 获得了优秀成绩: 92
// David 获得了优秀成绩: 90
</code></pre>
<h3><strong>7. 练习题</strong></h3>
<pre><code class="language-javascript">// 练习题 1: 使用 for 循环打印从 1 到 10 的所有偶数。
for (let i = 1; i &lt;= 10; i++) {
    if (i % 2 === 0) {
        console.log(i);
    }
}
// 输出: 2, 4, 6, 8, 10

// 练习题 2: 使用 while 循环计算数组 [5, 10, 15, 20] 的平均值。
const arr = [5, 10, 15, 20];
let sum = 0;
let index = 0;
while (index &lt; arr.length) {
    sum += arr[index];
    index++;
}
const average = sum / arr.length;
console.log(`平均值: ${average}`); // 输出: 平均值: 12.5

// 练习题 3: 使用 for...of 循环遍历字符串 &quot;Hello&quot; 并打印每个字符。
const str = &quot;Hello&quot;;
for (let char of str) {
    console.log(char);
}
// 输出:
// H
// e
// l
// l
// o
</code></pre>
<h3><strong>8. 复习总结</strong></h3>
<ul>
<li><strong>理解不同类型的循环结构</strong>：掌握 <code>for</code>、<code>while</code>、<code>do...while</code>、<code>for...in</code> 和 <code>for...of</code> 的语法及适用场景。</li>
<li><strong>循环控制</strong>：熟悉 <code>break</code> 和 <code>continue</code> 的使用，能够在需要时控制循环流程。</li>
<li><strong>嵌套循环的使用</strong>：了解嵌套循环的基本概念和注意事项，避免不必要的性能开销。</li>
<li><strong>性能优化</strong>：在编写循环时，关注代码的执行效率，避免低效的循环嵌套和不必要的计算。</li>
</ul>
]]></content><link href="https://github.com/hadleysu/gitblog/issues/11"/><category term="技术相关"/><published>2024-09-01T15:08:11+00:00</published></entry><entry><id>https://github.com/hadleysu/gitblog/issues/10</id><title>HTML和CSS实现Google Image Search样式</title><updated>2024-09-01T15:08:35.067432+00:00</updated><content type="html"><![CDATA[<h1>HTML和CSS实现Google Image Search样式</h1>
<ul>
<li>
<a href="#html%E5%92%8Ccss%E5%AE%9E%E7%8E%B0google-image-search%E6%A0%B7%E5%BC%8F">HTML和CSS实现Google Image Search样式</a><ul>
<li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3">参考文档</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li>
<li>
<a href="#%E5%AE%9E%E7%8E%B0-google-%E5%9B%BE%E6%A0%87%E4%B8%8E-images-%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E5%AF%B9%E4%BD%8D%E7%BD%AE%E4%B8%94%E6%95%B4%E4%BD%93%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD">实现 Google 图标与 images 之间的相对位置，且整体水平居中</a><ul>
<li><a href="#%E7%9B%B8%E5%AF%B9%E4%BD%8D%E7%BD%AE">相对位置</a></li>
<li>
<a href="#%E5%AE%B9%E5%99%A8%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD">容器水平居中</a><ul>
<li><a href="#%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E6%98%AF%E4%BD%BF%E7%94%A8-css-%E7%9A%84-transform-%E5%B1%9E%E6%80%A7">一种方法是使用 CSS 的 <code>transform</code> 属性</a></li>
<li><a href="#%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E6%98%AF%E4%BD%BF%E7%94%A8-margin-0-auto-%E9%85%8D%E5%90%88%E5%9B%BA%E5%AE%9A%E5%AE%BD%E5%BA%A6">另一种方法是使用 <code>margin: 0 auto;</code> 配合固定宽度</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>参考文档</h2>
<ul>
<li>
<p><a href="https://www.w3schools.com/css/css_positioning.asp">W3Schools - css position</a></p>
</li>
<li>
<p><a href="https://www.ruanyifeng.com/blog/2019/11/css-position.html">阮一峰 CSS 定位详解</a></p>
<ul>
<li><code>static</code> <code>relative</code> <code>fixed</code> <code>absolute</code> <code>sticky</code></li>
</ul>
</li>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display">MDN - css display</a></p>
<ul>
<li><code>block</code> <code>inline</code> <code>inline-block</code> <code>flex</code> <code>grid</code></li>
</ul>
</li>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform">MDN - css transform</a></p>
</li>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/margin">MDN -css margin</a></p>
<ul>
<li><code>margin-top</code> <code>margin-right</code> <code>margin-bottom</code> <code>margin-left</code></li>
</ul>
</li>
<li>
<p><a href="https://getbootstrap.com/docs/5.3/layout/grid/">Bootstrap - Grid</a></p>
</li>
<li>
<p><a href="https://getbootstrap.com/docs/5.3/layout/columns/">Bootstrap - Columns</a></p>
</li>
</ul>
<h2>代码</h2>
<p>HTML:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Images&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css&quot; integrity=&quot;sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH&quot; crossorigin=&quot;anonymous&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container-fluid&quot;&gt;
        &lt;ul class=&quot;nav nav-underline justify-content-end p-2&quot;&gt;
            &lt;li class=&quot;nav-item&quot;&gt;
                &lt;a class=&quot;nav-link text-dark&quot; href=&quot;index.html&quot;&gt;Google&lt;/a&gt;
            &lt;/li&gt;
            &lt;li class=&quot;nav-item&quot;&gt;
                &lt;a class=&quot;nav-link text-dark&quot; href=&quot;advanced.html&quot;&gt;Advanced&lt;/a&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
        &lt;div class=&quot;image-logo&quot;&gt;
            &lt;!-- Google图标 --&gt;
            &lt;img src=&quot;https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png&quot; class=&quot;rounded mx-auto d-block&quot; alt=&quot;Google Images&quot;&gt;
            &lt;!-- &quot;images&quot;文字 --&gt;
            &lt;div class=&quot;images-text text-primary&quot;&gt;
                &lt;span&gt;images&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;  
        &lt;div class=&quot;mt-4 text-center&quot;&gt;
            &lt;form id=&quot;searchForm&quot; class=&quot; row justify-content-center&quot; action=&quot;https://www.google.com/search&quot;&gt;
                &lt;div class=&quot;col-md-6&quot;&gt;
                    &lt;div class=&quot;input-group&quot;&gt;
                        &lt;span class=&quot;input-group-text&quot;&gt;
                            &lt;i class=&quot;bi bi-search&quot;&gt;&lt;/i&gt;
                        &lt;/span&gt;
                        &lt;input type=&quot;text&quot; class=&quot;form-control form-control-lg&quot; name=&quot;q&quot;&gt;
                        &lt;input type=&quot;hidden&quot; name=&quot;tbm&quot; value=&quot;isch&quot;&gt;
                    &lt;/div&gt;
                    &lt;button type=&quot;submit&quot; form=&quot;searchForm&quot; class=&quot;btn btn-light me-2 mt-4&quot;&gt;Images Search&lt;/button&gt;
                &lt;/div&gt;    
            &lt;/form&gt;
        &lt;/div&gt; 
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>CSS:</p>
<pre><code class="language-css">.image-logo {
    position: relative; /* 相对定位，为内部绝对定位元素提供参照 */
    display: inline-block; /* 使容器的宽度适应内容 */
    transform: translateX(-50%);/*将容器水平移动自身宽度的一半,达到水平居中的效果。*/
    left: 50%;/*将容器的左边缘移动到页面中心*/
}

.google-logo {
    width: 272px; 
    height: auto; /* 高度自动，保持宽高比 */
}

.images-text {
    position: absolute; /* 绝对定位 */
    bottom: 0; 
    right: 1px; 
}

/* 另一种方法是使用 margin: 0 auto; 配合固定宽度。
.image-logo 容器被设置为 position: relative; 
并且有一个固定的宽度。使用 margin: 0 auto; 将容器水平居中。*/
/* 
.image-logo {
    position: relative;
    width: 272px; 设置固定宽度
    margin: 0 auto; 水平居中
}

.google-logo {
    width: 100%;
    height: auto;
}

.images-text {
    position: absolute;
    bottom: 0;
    right: 1px;
} */
</code></pre>
<h2>实现 Google 图标与 images 之间的相对位置，且整体水平居中</h2>
<h3>相对位置</h3>
<p>将问题转化为我们有一个大容器元素和一个小容器元素,需要将小容器放置在大容器的右下角某个位置。我们可以使用 CSS 的绝对定位属性来实现这一目标。</p>
<p>具体步骤如下:</p>
<ol>
<li>
<p><strong>设置父容器为相对定位</strong></p>
<ul>
<li>将大容器的 <code>position</code> 属性设置为 <code>relative</code>。这样可以为子元素提供一个相对定位的参考点。</li>
</ul>
</li>
<li>
<p><strong>设置子容器为绝对定位</strong></p>
<ul>
<li>将小容器的 <code>position</code> 属性设置为 <code>absolute</code>。这样可以脱离文档流,使其可以相对于父容器进行定位。</li>
</ul>
</li>
<li>
<p><strong>定位子容器的位置</strong></p>
<ul>
<li>使用 <code>right</code> 和 <code>bottom</code> 属性来控制小容器相对于父容器的水平和垂直位置。例如 <code>right: 20px; bottom: 30px;</code> 将把小容器放置在父容器的右下角,距离边缘分别为 20px 和 30px。</li>
</ul>
</li>
</ol>
<ul>
<li>
<p><strong>还有重要的一点，父容器的大小要正好是 Google 图标的大小，这样才好调整 images 文字的位置</strong>。这样的样式设置才能保证，Google 图标与 images 之间的相对位置不会随着屏幕大小的改变而改变。</p>
<ul>
<li><code>display: inline-block;</code> or <code>width: 272px;</code> 要么使容器的宽度适应内容，而非占整行的宽度；要么设置固定宽度（即Google图标的宽度）。</li>
</ul>
</li>
</ul>
<h3>容器水平居中</h3>
<h4>一种方法是使用 CSS 的 <code>transform</code> 属性</h4>
<pre><code class="language-css">.image-logo {
    position: relative;/* 相对定位，为内部绝对定位元素提供参照 */
    display: inline-block; /* 使容器的宽度适应内容 */
    transform: translateX(-50%);/*将容器水平移动自身宽度的一半,达到水平居中的效果。*/
    left: 50%;/*将容器的左边缘移动到页面中心*/
}

.google-logo {
    width: 272px;
    height: auto;/* 高度自动，保持宽高比 */
}

.images-text {
    position: absolute;/* 绝对定位 */
    bottom: 0;
    right: 1px;
}
</code></pre>
<p>在这个例子中:</p>
<ol>
<li><code>.image-logo</code> 容器被设置为 <code>position: relative;</code>。</li>
<li>使用 <code>transform: translateX(-50%);</code> 将容器水平移动自身宽度的一半,达到水平居中的效果。</li>
<li>同时设置 <code>left: 50%;</code> 将容器的左边缘移动到页面中心。</li>
</ol>
<h4>另一种方法是使用 <code>margin: 0 auto;</code> 配合固定宽度</h4>
<pre><code class="language-css">.image-logo {
    position: relative;
    width: 272px; /* 设置固定宽度 */
    margin: 0 auto; /* 水平居中 */
}

.google-logo {
    width: 100%;
    height: auto;
}

.images-text {
    position: absolute;
    bottom: 0;
    right: 1px;
}
</code></pre>
<p>在这个例子中:</p>
<ol>
<li><code>.image-logo</code> 容器被设置为 <code>position: relative;</code> 并且有一个明确的宽度。</li>
<li>使用 <code>margin: 0 auto;</code> 将margin的水平值设为auto，实现容器水平居中。</li>
</ol>
]]></content><link href="https://github.com/hadleysu/gitblog/issues/10"/><category term="技术相关"/><published>2024-05-18T06:12:09+00:00</published></entry><entry><id>https://github.com/hadleysu/gitblog/issues/9</id><title>CSS 基础笔记</title><updated>2024-09-01T15:08:35.179973+00:00</updated><content type="html"><![CDATA[<h1>CSS 基础笔记</h1>
<ul>
<li>
<a href="#css-%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0">CSS 基础笔记</a><ul>
<li>
<a href="#css%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E9%97%AE%E9%A2%98">CSS能解决什么样的问题</a><ul>
<li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3">参考文档</a></li>
</ul>
</li>
<li>
<a href="#%E5%88%86%E7%B1%BB">分类</a><ul>
<li><a href="#inline-styling">inline styling</a></li>
<li><a href="#internal-css">internal CSS</a></li>
<li><a href="#external-css">external CSS</a></li>
</ul>
</li>
<li>
<a href="#css-selectors">CSS Selectors</a><ul>
<li><a href="#type-selector--element-selector">Type Selector / Element Selector</a></li>
<li><a href="#id-selector">Id Selector</a></li>
<li><a href="#class-selector">Class Selector</a></li>
<li><a href="#multiple-element-selector">Multiple Element Selector</a></li>
<li><a href="#css-%E4%BC%98%E5%85%88%E7%BA%A7%E8%A7%84%E5%88%99">CSS 优先级规则</a></li>
<li><a href="#css-selectors-table">CSS Selectors Table</a></li>
<li><a href="#child-selector">Child Selector</a></li>
<li><a href="#descendant-selector">Descendant Selector</a></li>
<li><a href="#attribute-selector">Attribute Selector</a></li>
<li>
<a href="#pseudo-class">Pseudo Class</a><ul>
<li><a href="#hover--%E6%82%AC%E5%81%9C%E6%97%B6">hover  (悬停时)</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#responsive-design">Responsive Design</a><ul>
<li><a href="#viewport">viewport</a></li>
<li><a href="#media-queries">Media Queries</a></li>
<li><a href="#flexbox">Flexbox</a></li>
<li><a href="#grids">Grids</a></li>
</ul>
</li>
<li>
<a href="#bootstrap">Bootstrap</a><ul>
<li><a href="#bootstraps-grid-system">Bootstrap’s grid system</a></li>
</ul>
</li>
<li>
<a href="#sass">Sass</a><ul>
<li><a href="#sass%E6%94%AF%E6%8C%81%E5%8F%98%E9%87%8F">Sass支持变量</a></li>
<li><a href="#sass-%E4%B8%AD%E5%B5%8C%E5%A5%97%E8%AF%AD%E6%B3%95%E6%9B%B4%E7%AE%80%E5%8D%95">Sass 中嵌套语法更简单</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li>
<li>
<a href="#%E7%88%B6%E9%80%89%E6%8B%A9%E5%99%A8---referencing-parent-selectors--">父选择器 &amp; ( Referencing Parent Selectors: &amp; )</a><ul>
<li><a href="#-%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95">&amp; 有以下几种用法</a></li>
<li><a href="#%E9%97%AE%E9%A2%98">问题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>CSS能解决什么样的问题</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS：层叠样式表 | MDN</a> Cascading Style Sheets 用于设置网页的样式及布局——比如，可以更改内容的字体、颜色、大小以及间距，或是将其分列，或是添加动画及赋予内容其他装饰性的特征。<a href="https://cs50.harvard.edu/web/2020/notes/0/">CS50W HTML, CSS notes</a>  </p>
<h3>参考文档</h3>
<ul>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors">MDN - CSS selectors</a></p>
</li>
<li>
<p><a href="https://www.w3schools.com/CSS/css_selectors.asp">W3Schools  - CSS Selectors</a></p>
</li>
<li>
<p><a href="https://www.w3schools.com/css/css3_flexbox.asp">W3Schools  - CSS Flexbox</a></p>
</li>
<li>
<p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">阮一峰 Flex 布局教程：语法篇</a></p>
</li>
<li>
<p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-examples.html">阮一峰 Flex 布局教程：实例篇</a></p>
</li>
<li>
<p><a href="https://www.ruanyifeng.com/blog/2018/10/flexbox-form.html">阮一峰 Flexbox 布局的最简单表单</a></p>
</li>
<li>
<p><a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">阮一峰 CSS Grid 网格布局教程</a></p>
</li>
<li>
<p><a href="https://www.w3schools.com/css/css_grid.asp">W3Schools  - CSS Grid Layout Module</a></p>
</li>
</ul>
<h2>分类</h2>
<h3>inline styling</h3>
<pre><code class="language-html">&lt;h1 style=&quot;color: blue; text-align: center;&quot;&gt;This is a heading.&lt;/h1&gt;
</code></pre>
<h3>internal CSS</h3>
<pre><code class="language-html">&lt;head&gt;
  &lt;style&gt;
    h1 {
      color: blue;
      text-align: center;
    }
  &lt;/style&gt;
&lt;/head&gt;
</code></pre>
<h3>external CSS</h3>
<ul>
<li>创建单独的 css 文件，如 style.css</li>
<li>在&lt; head &gt;里用&lt; link &gt;引用，如：</li>
</ul>
<pre><code class="language-html">&lt;head&gt;
  &lt;link ref=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;
&lt;/head&gt;
</code></pre>
<h2>CSS Selectors</h2>
<h3>Type Selector / Element Selector</h3>
<pre><code class="language-css">div {
    background-color: orange;
    width: 200px;
    height: 200px;
    padding: 20px; /*内边距*/
    margin: 20px; /*外边距*/
}

/* font */
div {
    border: 2px solid black;
    font-family: Arial, Helvetica, sans-serif;
    font-size: 28px;
    font-weight: bold;
}
</code></pre>
<h3>Id Selector</h3>
<p>HTML 中：</p>
<pre><code class="language-html">&lt;h1 id=&quot;foo&quot;&gt;Heading 1&lt;/h1&gt;
&lt;h1&gt;Heading 2&lt;/h1&gt;
&lt;h1&gt;Heading 3&lt;/h1&gt;
</code></pre>
<p>CSS 中：</p>
<pre><code class="language-css">#foo{
    color: blue;
}
</code></pre>
<h3>Class Selector</h3>
<p>HTML 中：</p>
<pre><code class="language-html">&lt;h1 class=&quot;baz&quot;&gt;Heading 1&lt;/h1&gt;
&lt;h1 class=&quot;baz&quot;&gt;Heading 2&lt;/h1&gt;
&lt;h1&gt;Heading 3&lt;/h1&gt;
</code></pre>
<p>CSS 中：</p>
<pre><code class="language-css">.baz{
    color: blue;
}
</code></pre>
<h3>Multiple Element Selector</h3>
<pre><code class="language-css">table {
    border: 2px solid black;
    border-collapse: collapse;
}
td, th { /*th 和 td 具有相同的样式，就直接用逗号连接放一起*/
    border: 2px solid black;
    padding: 5px;
}
</code></pre>
<h3>CSS 优先级规则</h3>
<p>当同一个元素被多条 CSS 规则定义时,浏览器会根据一定的优先级规则来决定最终应用哪一条规则。这个优先级规则被称为 CSS 优先级。</p>
<p>CSS 优先级的主要规则如下:</p>
<ol>
<li>
<p><strong>内联样式 &gt; ID 选择器 &gt; 类选择器 &gt; 元素选择器</strong></p>
<ul>
<li>inline <code>如 style=&quot;...&quot;</code></li>
<li>id <code>如 #my-element</code></li>
<li>class <code>如 .my-class</code></li>
<li>type <code>如 div</code></li>
</ul>
</li>
<li>
<p><strong>就近原则</strong></p>
<ul>
<li>当多条具有相同优先级的规则应用于同一元素时,就近原则生效,即最后定义的规则会覆盖先前的规则。</li>
</ul>
</li>
<li>
<p><strong>!important 关键字</strong></p>
<ul>
<li>使用 <code>!important</code> 关键字可以提升某条 CSS 规则的优先级,使其覆盖其他规则。但应该谨慎使用,因为它会破坏 CSS 的级联机制。</li>
</ul>
</li>
</ol>
<h3>CSS Selectors Table</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>a, b</td>
<td>Multiple Element Selector</td>
</tr>
<tr>
<td>a b</td>
<td>Descendant Selector</td>
</tr>
<tr>
<td>a &gt; b</td>
<td>Child Selector</td>
</tr>
<tr>
<td>a + b</td>
<td>Adjacent Sibling Selector</td>
</tr>
<tr>
<td>[a=b]</td>
<td>Attribute Selector</td>
</tr>
<tr>
<td>a:b</td>
<td>Pseudoclass Selector</td>
</tr>
<tr>
<td>a::b</td>
<td>Pseudoelement Selector</td>
</tr>
</tbody></table><h3>Child Selector</h3>
<p>指定直系子代</p>
<p>HTML 中：</p>
<pre><code class="language-html">&lt;ol&gt;
   &lt;li&gt;list item one&lt;/li&gt;
   &lt;li&gt;list item two&lt;/li&gt;
   &lt;ul&gt;
       &lt;li&gt;sublist item one&lt;/li&gt;
       &lt;li&gt;sublist item two&lt;/li&gt;
   &lt;/ul&gt;
   &lt;li&gt;list item three&lt;/li&gt;
&lt;/ol&gt;&gt;
</code></pre>
<p>CSS 中：</p>
<pre><code class="language-css">ul &gt; li{
    color: blue;
}
</code></pre>
<h3>Descendant Selector</h3>
<p>选定所有后代元素</p>
<pre><code class="language-css">ul li{
    color: blue;
}
</code></pre>
<h3>Attribute Selector</h3>
<p>HTML 中：</p>
<pre><code class="language-html">&lt;ul&gt;
   &lt;li&gt;&lt;a href=&quot;https:google.com&quot;&gt;Google&lt;/a&gt;&lt;/li&gt;
   &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS&quot;&gt;CSS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>CSS 中：</p>
<pre><code class="language-css">a {
    color: blue;
}
a[href=&quot;https:google.com&quot;] {
    color: red;
}
</code></pre>
<h3>Pseudo Class</h3>
<h4>hover  (悬停时)</h4>
<p>HTML 中：</p>
<pre><code class="language-html">&lt;button&gt;Click Me&lt;/button&gt;
</code></pre>
<p>CSS 中：</p>
<pre><code class="language-css">button {
    width: 200px;
    height: 50px;
    font-size: 20px;
    background-color: blue;
}
button:hover {
    background-color: red;
}
</code></pre>
<h2>Responsive Design</h2>
<ul>
<li>viewport</li>
<li>Media Queries</li>
<li>Flexbox</li>
<li>Grids</li>
</ul>
<h3>viewport</h3>
<p><code>viewport</code> 元素可以控制网页在不同设备上的显示方式和缩放比例。代码中，<code>width=device-width</code> 表示将 viewport 的宽度设置为设备的屏幕宽度，<code>initial-scale=1.0</code> 表示将网页的初始缩放比例设置为1.0，也就是不缩放。这样可以让网页适应不同大小的屏幕，实现响应式设计。</p>
<pre><code class="language-html">&lt;head&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;!-- 其他的head元素 --&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 网页的内容 --&gt;
&lt;/body&gt;
</code></pre>
<h3>Media Queries</h3>
<p><code>Media Queries</code> 的作用是实现响应式网页设计，让网页能够适应不同大小和分辨率的屏幕和设备。</p>
<pre><code class="language-css">@media (min-width:600px) {
    body {
        background-color: red;
    }
}          
@media (max-width:599px) {
    body {
        background-color: blue;
    }
}
</code></pre>
<h3>Flexbox</h3>
<p><code>Flexbox</code> 是CSS3中的一种布局模式，它可以让网页中的元素按照灵活的方式排列和对齐。</p>
<p>HTML 中：</p>
<pre><code class="language-html">&lt;div id=&quot;container&quot;&gt;
    &lt;div&gt;1.This is some sample text inside of a div to dome Flexbox.&lt;/div&gt;
    &lt;div&gt;2.This is some sample text inside of a div to dome Flexbox.&lt;/div&gt;
    &lt;div&gt;3.This is some sample text inside of a div to dome Flexbox.&lt;/div&gt;
    &lt;div&gt;4.This is some sample text inside of a div to dome Flexbox.&lt;/div&gt;
    &lt;div&gt;5.This is some sample text inside of a div to dome Flexbox.&lt;/div&gt;
    &lt;div&gt;6.This is some sample text inside of a div to dome Flexbox.&lt;/div&gt;
    &lt;div&gt;7.This is some sample text inside of a div to dome Flexbox.&lt;/div&gt;
    &lt;div&gt;8.This is some sample text inside of a div to dome Flexbox.&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>CSS 中：</p>
<pre><code class="language-css">#container {
    display: flex; /* 设置为flex布局 */
    flex-wrap: wrap; /* 允许项目换行 */
}
#container &gt; div {
    background-color: springgreen;
    margin: 20px;
    padding: 20px;
    width: 200px;
}
</code></pre>
<h3>Grids</h3>
<p><code>Grids</code> 是 CSS3 中的另一种布局模式，它可以让网页中的元素按照二维的方式排列和对齐。Grids 的优点是可以创建复杂的网格结构，可以控制网格的行高和列宽，可以实现网页的响应式设计。</p>
<p>HTML 中：</p>
<pre><code class="language-html">&lt;div id=&quot;grid&quot;&gt;
    &lt;div class=&quot;grid-item&quot;&gt;1&lt;/div&gt;
    &lt;div class=&quot;grid-item&quot;&gt;2&lt;/div&gt;
    &lt;div class=&quot;grid-item&quot;&gt;3&lt;/div&gt;
    &lt;div class=&quot;grid-item&quot;&gt;4&lt;/div&gt;
    &lt;div class=&quot;grid-item&quot;&gt;5&lt;/div&gt;
    &lt;div class=&quot;grid-item&quot;&gt;6&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>CSS 中：</p>
<pre><code class="language-css">#grid {
    background-color: green;
    display: grid; /* 设置为grid布局 */
    padding: 20px;
    grid-column-gap: 20px;
    grid-row-gap: 10px;
    grid-template-columns: 200px 200px auto;/* 设置三列的宽度 */
}
.grid-item {
    background-color: springgreen;
    font-size: 20px;
    padding: 20px;
    text-align: center;
}
</code></pre>
<h2>Bootstrap</h2>
<p><code>BOOTSTRAP</code> 是一个开源的前端框架，它可以让开发者快速地创建响应式的网页和应用。BOOTSTRAP 提供了丰富的 <code>CSS</code> 样式，组件和 <code>JavaScript</code> 插件，可以方便地实现网页的布局，导航，表单，按钮，图标，模态框，轮播图，警告框等功能。</p>
<pre><code class="language-html">&lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css&quot;&gt;
&lt;/head&gt; 
&lt;body&gt;
    &lt;!-- 可直接使用Bootstrap组件里的代码 --&gt;
    &lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt;
        A simple primary alert—check it out!
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h3>Bootstrap’s grid system</h3>
<p>每行有 <strong>12 个模板列</strong>，允许您创建不同组合的元素，它们可以跨越任意数量的列。列类指示您想要使用的模板列的数量（例如，<code>.col-4</code> 跨越四个列）。</p>
<pre><code class="language-html">&lt;head&gt;
    &lt;title&gt;My Web Page!&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css&quot; integrity=&quot;sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh&quot; crossorigin=&quot;anonymous&quot;&gt;
    &lt;style&gt;
        .row &gt; div {
            padding: 20px;
            background-color: teal;
            border: 2px solid black;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
            &lt;div class=&quot;col-4&quot;&gt;
                This is a section.
            &lt;/div&gt;
            &lt;div class=&quot;col-4&quot;&gt;
                This is another section.
            &lt;/div&gt;
            &lt;div class=&quot;col-4&quot;&gt;
                This is a third section.
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;br/&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
            &lt;div class=&quot;col-3&quot;&gt;
                This is a section.
            &lt;/div&gt;
            &lt;div class=&quot;col-6&quot;&gt;
                This is another section.
            &lt;/div&gt;
            &lt;div class=&quot;col-3&quot;&gt;
                This is a third section.
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>根据不同的屏幕尺寸( lg / sm )控制容器和列的大小和行为。</p>
<pre><code class="language-html">&lt;head&gt;
    &lt;title&gt;My Web Page!&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css&quot; integrity=&quot;sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh&quot; crossorigin=&quot;anonymous&quot;&gt;
    &lt;style&gt;
        .row &gt; div {
            padding: 20px;
            background-color: teal;
            border: 2px solid black;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
            &lt;div class=&quot;col-lg-3 col-sm-6&quot;&gt;
                This is a section.
            &lt;/div&gt;
            &lt;div class=&quot;col-lg-3 col-sm-6&quot;&gt;
                This is another section.
            &lt;/div&gt;
            &lt;div class=&quot;col-lg-3 col-sm-6&quot;&gt;
                This is a third section.
            &lt;/div&gt;
            &lt;div class=&quot;col-lg-3 col-sm-6&quot;&gt;
                This is a fourth section.
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h2>Sass</h2>
<p>Syntactically Awesome Style Sheets 可以帮助您减少 CSS 的重复，节省时间，提高代码的可维护性。</p>
<h3>Sass支持变量</h3>
<ul>
<li>创建单独的 Sass 文件，如 <code>variables.scss</code></li>
</ul>
<pre><code class="language-scss">/* 定义变量 */
$color: red;  /*如果颜色发生改变只需要改变变量即可*/

ul {
    font-size: 14px;
    color: $color;
}

ol {
    font-size: 18px;
    color: $color;
}
</code></pre>
<ul>
<li>在&lt; head &gt;里用&lt; link &gt;引用，如：</li>
</ul>
<pre><code class="language-html">&lt;link rel=&quot;stylesheet&quot; href=&quot;variables.css&quot;&gt;
</code></pre>
<ul>
<li><strong>浏览器理解 CSS 但不理解 Sass</strong> ，为解决这个问题，可以在电脑上直接安装 Sass ，或在终端使用 <code>sass variables.scss:variables.css</code> 命令进行<strong>编译</strong>，将Sass代码编译成标准的 CSS 代码。</li>
<li>终端使用 <code>sass --watch variables.scss:variables.css</code> 命令时，能在检测到 Sass 文件发生改变时，自动进行编译，将Sass代码编译成 CSS 代码，实现自动更新 CSS 代码。</li>
</ul>
<h3>Sass 中嵌套语法更简单</h3>
<p>While using Sass, we can also physically nest our styling rather than use the CSS selectors we talked about earlier. Sass中：</p>
<pre><code class="language-scss">div {
    font-size: 10px;

    p {
        color: blue;
    }

    ul {
        color: green;
    }
}
</code></pre>
<p>编译后生成的 CSS 中：</p>
<pre><code class="language-css">div {
    font-size: 18px;
}

div p { /*Descendant Selector */
    color: blue;
}

div ul { /*Descendant Selector */
    color: green;
}
</code></pre>
<h3>继承</h3>
<p>Sass 中：</p>
<pre><code class="language-scss">%message { /*adding a % before a name of a class, adding some styling*/
    font-family: sans-serif;
    font-size: 18px;
    font-weight: bold;
    border: 1px solid black;
    padding: 20px;
    margin: 20px;
}

.success { 
    @extend %message; /*adding the line @extend %classname to the beginning of some styling*/
    background-color: green;
}

.warning {
    @extend %message;
    background-color: orange;
}

.error {
    @extend %message;
    background-color: red;
}
</code></pre>
<p>HTML 中：</p>
<pre><code class="language-html">&lt;head&gt;
    &lt;title&gt;My Web Page!&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;inheritance.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;success&quot;&gt;This is a success message.&lt;/div&gt;

    &lt;div class=&quot;warning&quot;&gt;This is a warning message.&lt;/div&gt;

    &lt;div class=&quot;error&quot;&gt;This is an error message.&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h3>父选择器 &amp; ( Referencing Parent Selectors: &amp; )</h3>
<h4>&amp; 有以下几种用法</h4>
<ul>
<li>与伪类或伪元素结合：你可以用&amp;和伪类或伪元素配合使用，表示父选择器的某种状态或修饰。比如，你可以用 <code>&amp;:focus</code> 来表示 <code>input:focus</code> ，表示 input 元素获得焦点时的样式。你也可以用 <code>&amp;:hover</code> 来表示 <code>input[type=&quot;submit&quot;]:hover</code> ，表示 input 元素类型为 submit 并且鼠标悬停时的样式。</li>
</ul>
<p>Sass 中：</p>
<pre><code class="language-scss">//定义一个input选择器，选择所有的&lt;input&gt;元素
input {
    font-size: 16px;
    width: 300px;
    padding: 13px 0;

    //使用&amp;和:focus伪类结合，选择所有获得焦点的&lt;input&gt;元素
    &amp;:focus {
        outline: none;
    }

    //使用&amp;和属性选择器结合，选择所有类型为submit的&lt;input&gt;元素
    &amp;[type=&quot;submit&quot;] {
        font-size: 14px;
        width: 185px;
        /* Remove border */
        border-width: 0px;
        border-radius: 15px;
        margin: 20px;

        //使用&amp;和:hover伪类结合，选择所有鼠标悬停的类型为submit的&lt;input&gt;元素
        &amp;:hover {
            /* Add box-shadow when hovering button (border adds space) */
            box-shadow: 0px 0px 2px rgba(0, 0, 0, 0.8);
        }
    }
}
</code></pre>
<p>编译后生成的 CSS 中：</p>
<pre><code class="language-css">input {
  font-size: 16px;
  width: 300px;
  padding: 13px 0;
  /* Parent selector = &amp; */
}
input:focus {
  outline: none;
}
input[type=submit] {
  font-size: 14px;
  width: 185px;
  /* Remove border */
  border-width: 0px;
  border-radius: 15px;
  margin: 20px;
}
input[type=submit]:hover {
  /* Add box-shadow when hovering button (border adds space) */
  box-shadow: 0px 0px 2px rgba(0, 0, 0, 0.8);
}
</code></pre>
<ul>
<li>与属性选择器结合：你可以用 <code>&amp;</code> 和属性选择器配合使用，表示父选择器具有某种属性或属性值。比如，你可以用 <code>&amp;[type=&quot;text&quot;]</code> 来表示 <code>input[type=&quot;text&quot;]</code> ，表示 input 元素类型为 text 的样式。你也可以用 <code>&amp;[type=&quot;submit&quot;]</code> 来表示 <code>input[type=&quot;submit&quot;]</code> ，表示 input 元素类型为 submit 的样式。</li>
</ul>
<p>Sass 中：</p>
<pre><code class="language-scss">input {
    font-size: 16px;
    width: 300px;
    padding: 13px 0;

    //使用&amp;和属性选择器结合，选择所有类型为text的&lt;input&gt;元素
    &amp;[type=&quot;text&quot;] {
        /* Give input text a lighter color */
        color: #464646;
        margin: 0 0 0 5px;
    }

    &amp;[type=&quot;submit&quot;] {
        font-size: 14px;
        width: 185px;
        /* Remove border */
        border-width: 0px;
        border-radius: 15px;
        margin: 20px;
    }
}
</code></pre>
<p>编译后生成的 CSS 中：</p>
<pre><code class="language-css">input {
  font-size: 16px;
  width: 300px;
  padding: 13px 0;
  /* Parent selector = &amp; */
}
input[type=text] {
  /* Give input text a lighter color */
  color: #464646;
  margin: 0 0 0 5px;
}
input[type=submit] {
  font-size: 14px;
  width: 185px;
  /* Remove border */
  border-width: 0px;
  border-radius: 15px;
  margin: 20px;
}
</code></pre>
<ul>
<li>与类选择器结合：你可以用 <code>&amp;</code> 和类选择器配合使用，表示父选择器同时具有某个类名。比如，你可以用 <code>&amp;.blue-button</code> 来表示 <code>input.blue-button</code> ，表示 input 元素同时具有 blue-button 类名的样式。</li>
</ul>
<p>Sass 中：</p>
<pre><code class="language-scss">input {
    font-size: 16px;
    width: 300px;
    padding: 13px 0;
 
    //使用&amp;和类选择器结合，选择所有同时具有blue-button类名的&lt;input&gt;元素
    &amp;.blue-button {
        background-color: dodgerblue;
        color: white;
        font-size: smaller;
        max-width: 200px;
        border-radius: 0px;
        border: 1px solid #156bbd;
        float: right;
        padding: 10px 2px;
        margin: 0;
    }
}
</code></pre>
<p>编译后生成的 CSS 中：</p>
<pre><code class="language-css">input {
  font-size: 16px;
  width: 300px;
  padding: 13px 0;
  /* Parent selector = &amp; */
}
input.blue-button {
  background-color: dodgerblue;
  color: white;
  font-size: smaller;
  max-width: 200px;
  border-radius: 0px;
  border: 1px solid #156bbd;
  float: right;
  padding: 10px 2px;
  margin: 0;
}
</code></pre>
<ul>
<li>与其他选择器拼接：你可以用 <code>&amp;</code> 和其他选择器拼接，表示父选择器的一部分。比如，你可以用 <code>&amp;-button</code> 来表示 <code>input-button</code> ，表示以 input-button 为选择器的样式。</li>
</ul>
<p>Sass 中：</p>
<pre><code class="language-scss">//定义一个.header选择器，选择所有具有header类名的元素
.header {
    display: flex;
    align-items: center;

    //使用&amp;和其他选择器拼接，选择所有具有header-advanced类名的元素
    &amp;-advanced {
        @extend .header;
        background-color: #f1f1f1;
        height: 50px;
    }

    //使用&amp;和其他选择器拼接，选择所有具有header-advanced-logo类名的元素
    &amp;-advanced-logo {
        @extend .header;
        padding: 10px;

        //使用嵌套的img选择器，选择所有父元素具有header-advanced-logo类名的&lt;img&gt;元素
        img {
            height: 30px;
        }
    }

    //使用&amp;和其他选择器拼接，选择所有具有header-links类名的元素
    &amp;-links {
        @extend .header;
        margin-left: auto;
    }
}
</code></pre>
<p>编译后生成的 CSS 中：</p>
<pre><code class="language-css">/*如果使用了@extend指令，就会生成后代选择器，如果没有使用，就不会生成后代选择器。*/
.header, .header-links, .header-advanced-logo, .header-advanced {
  display: flex;
  align-items: center;
}
/*因为使用了@extend指令，就会生成后代选择器*/
.header a, .header-links a, .header-advanced-logo a, .header-advanced a {
  color: black;
  padding: 10px;
  text-decoration: none;
}
.header-advanced {
  background-color: #f1f1f1;
  height: 50px;
}
.header-advanced-logo {
  padding: 10px;
}
.header-advanced-logo img {
  height: 30px;
}
.header-links {
  margin-left: auto;
}
</code></pre>
<ul>
<li>与后代选择器结合：你可以用 <code>&amp;</code> 和后代选择器结合，表示父选择器的子孙元素。比如，你可以用 <code>.nav-menu &amp;</code> 来表示 <code>.nav-menu input</code> ，表示 nav-menu 类名下的 input 元素的样式。</li>
</ul>
<p>Sass 中：</p>
<pre><code class="language-scss">//在sass中先写了子元素的效果，但在某种情况下需要进行覆盖时，可以使用选择器后面加&amp;，注意中间要加空格。
a {
    color: red;
    
    //选择nav-menu类名下的所有&lt;a&gt;元素
    .nav-menu &amp; {
        color: blue;
    }
}
</code></pre>
<p>编译后生成的 CSS 中：</p>
<pre><code class="language-css">a {
    color: red;
}
/*后代选择器*/
.nav-menu a {
    color: blue;
}
</code></pre>
<h4>问题</h4>
<ul>
<li>
<p>是不是在 <code>sass</code> 的嵌套代码里如果不使用 <code>&amp;</code> ，就会产生后代选择器呢？</p>
<ul>
<li>是的。如果你在 <code>sass</code> 的嵌套代码里不使用 <code>&amp;</code>，就会产生后代选择器。</li>
</ul>
</li>
<li>
<p>什么情况下在 <code>sass</code> 的嵌套代码里不会产生后代选择器呢？</p>
<ul>
<li>如果你在 <code>sass</code> 的嵌套代码里使用了 <code>&amp;</code> 符号，就不会产生后代选择器，而是会产生其他类型的选择器，比如多类选择器，伪类选择器，属性选择器等。</li>
</ul>
</li>
</ul>
]]></content><link href="https://github.com/hadleysu/gitblog/issues/9"/><category term="技术相关"/><published>2024-01-07T17:05:54+00:00</published></entry><entry><id>https://github.com/hadleysu/gitblog/issues/8</id><title>HTML 基础笔记</title><updated>2024-09-01T15:08:35.293083+00:00</updated><content type="html"><![CDATA[<h1>HTML 基础笔记</h1>
<h2>HTML 能解决什么样的问题</h2>
<p>HyperText Markup Language which is a language that we can use to describe the structure of the webpage.All of the buttons and the text, and the forms and other parts of the webpage that the user ultimately sees and interacts with. <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">HTML（超文本标记语言） | MDN</a></p>
<h2>1st HTML</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;title&gt;Hello!&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        Hello,world!
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2>DOM</h2>
<p>Document Object Model(文档对象模型)The tree like structure that describes how all of these HTML elements are related to each other.</p>
<h2>tags</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>h1</td>
<td>heading，h1~h6</td>
</tr>
<tr>
<td>ol</td>
<td>ordered list</td>
</tr>
<tr>
<td>ul</td>
<td>unordered list</td>
</tr>
<tr>
<td>li</td>
<td>list item ，嵌套在ol/ul里使用</td>
</tr>
<tr>
<td>img</td>
<td>image，required attributes（src/alt/width）</td>
</tr>
<tr>
<td>a</td>
<td>anchor 超链接，attribute(href)</td>
</tr>
<tr>
<td>table</td>
<td>表格</td>
</tr>
<tr>
<td>thead</td>
<td>表头</td>
</tr>
<tr>
<td>th</td>
<td>表头单元格</td>
</tr>
<tr>
<td>tbody</td>
<td>表体</td>
</tr>
<tr>
<td>tr</td>
<td>table row</td>
</tr>
<tr>
<td>td</td>
<td>table data</td>
</tr>
<tr>
<td>form</td>
<td>表单</td>
</tr>
<tr>
<td>input</td>
<td>输入框，attribute(type/placeholder/name/list)</td>
</tr>
<tr>
<td>datalist</td>
<td>定义一个输入候选列表,需要和input标签配合使用</td>
</tr>
<tr>
<td>option</td>
<td>定义datalist列表中每个候选项的值，即下拉菜单的内容。</td>
</tr>
</tbody></table><h2>attributes</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>src</td>
<td>source</td>
</tr>
<tr>
<td>alt</td>
<td>alternative text (用文字描述图片内容 )</td>
</tr>
<tr>
<td>width</td>
<td>宽度</td>
</tr>
<tr>
<td>href</td>
<td>hyperlink reference</td>
</tr>
<tr>
<td>type</td>
<td>表单控件类型（如text/submit/radio/password）</td>
</tr>
<tr>
<td>placeholder</td>
<td>当没有值设定时，出现在表单控件上的文字</td>
</tr>
<tr>
<td>name</td>
<td>表单的控件名称，作为键值对的一部分与表单一同提交</td>
</tr>
<tr>
<td>list</td>
<td>input 标签的 list 属性是 datalist 标签的 id 属性的值，相互关联</td>
</tr>
</tbody></table><p>datalist标签和option标签的一个例子是：</p>
<pre><code class="language-html">&lt;label for=&quot;city&quot;&gt;请选择您的城市：&lt;/label&gt;
&lt;input type=&quot;text&quot; id=&quot;city&quot; list=&quot;city-list&quot;&gt;
&lt;datalist id=&quot;city-list&quot;&gt;
    &lt;option value=&quot;北京&quot;&gt;
    &lt;option value=&quot;上海&quot;&gt;
    &lt;option value=&quot;广州&quot;&gt;
    &lt;option value=&quot;深圳&quot;&gt;
&lt;/datalist&gt;
</code></pre>
<ul>
<li>datalist标签可以定义一个输入候选列表，option标签可以定义每个候选项的值。</li>
<li>datalist标签需要和input标签配合使用，通过input标签的list属性来指定要关联的datalist标签的id属性。这样，当用户在input标签的输入框中输入或点击时，就会显示datalist标签中的候选列表，用户可以从中选择一个或者自己输入一个值。</li>
</ul>
]]></content><link href="https://github.com/hadleysu/gitblog/issues/8"/><category term="技术相关"/><published>2024-01-07T16:57:21+00:00</published></entry><entry><id>https://github.com/hadleysu/gitblog/issues/7</id><title>怎么用电脑键盘打日语（罗马音输入法）</title><updated>2024-09-01T15:08:35.384306+00:00</updated><content type="html"><![CDATA[<h1>怎么用电脑键盘打日语（罗马音输入法）</h1>
<h2>50音</h2>
<table>
<thead>
<tr>
<th>50音</th>
<th>罗马音</th>
</tr>
</thead>
<tbody>
<tr>
<td>あ　い　う　え　お</td>
<td>A I U E O</td>
</tr>
<tr>
<td>规则</td>
<td>辅音+元音</td>
</tr>
<tr>
<td>か　き　く　け　こ</td>
<td>ka ki ku ke ko</td>
</tr>
<tr>
<td>さ　し　す　せ　そ</td>
<td>sa si su se so</td>
</tr>
<tr>
<td>た　ち　つ　て　と</td>
<td>ta ti tu te to</td>
</tr>
<tr>
<td>な　に　ぬ　ね　の</td>
<td>na ni nu ne no</td>
</tr>
<tr>
<td>は　ひ　ふ　へ　ほ</td>
<td>ha hi hu he ho</td>
</tr>
<tr>
<td>ま　み　む　め　も</td>
<td>ma mi mu me mo</td>
</tr>
<tr>
<td>や　　　ゆ　　　よ</td>
<td>ya    yu    yo</td>
</tr>
<tr>
<td>ら　り　る　れ　ろ</td>
<td>ra ri ru re ro</td>
</tr>
<tr>
<td>わ　　　　　　　を</td>
<td>wa          wo</td>
</tr>
<tr>
<td>ん</td>
<td>nn</td>
</tr>
</tbody></table><h2>浊音</h2>
<table>
<thead>
<tr>
<th>浊音</th>
<th>罗马音</th>
</tr>
</thead>
<tbody>
<tr>
<td>が　ぎ　ぐ　げ　ご</td>
<td>ga gi gu ge go</td>
</tr>
<tr>
<td>ざ　じ　ず　ぜ　ぞ</td>
<td>za zi zu ze zo</td>
</tr>
<tr>
<td>だ　ぢ　づ　で　ど</td>
<td>da di du de do</td>
</tr>
<tr>
<td>ば　び　ぶ　べ　ぼ</td>
<td>ba bi bu be bo</td>
</tr>
<tr>
<td>ぱ　ぴ　ぷ　ぺ　ぽ</td>
<td>pa pi pu pe po</td>
</tr>
</tbody></table><h2>拗音</h2>
<table>
<thead>
<tr>
<th>拗音</th>
<th>罗马音</th>
</tr>
</thead>
<tbody>
<tr>
<td>规则</td>
<td>辅音 + y + a/u/o</td>
</tr>
<tr>
<td>きゃ　きゅ　きょ</td>
<td>kya kyu kyo</td>
</tr>
<tr>
<td>しゃ　しゅ　しょ</td>
<td>sya syu syo</td>
</tr>
<tr>
<td>ちゃ　ちゅ　ちょ</td>
<td>tya tyu tyo</td>
</tr>
</tbody></table><h2>促音</h2>
<table>
<thead>
<tr>
<th>促音</th>
<th>罗马音</th>
</tr>
</thead>
<tbody>
<tr>
<td>规则</td>
<td>促音的下一个辅音，把那个辅音打两次</td>
</tr>
<tr>
<td>かった</td>
<td>katta</td>
</tr>
<tr>
<td>ざっし</td>
<td>zassi</td>
</tr>
<tr>
<td>さっか</td>
<td>dakka</td>
</tr>
</tbody></table><h2>外来语（含小写字）</h2>
<table>
<thead>
<tr>
<th>外来语</th>
<th>罗马音</th>
</tr>
</thead>
<tbody>
<tr>
<td>规则</td>
<td>L + 想小写的字</td>
</tr>
<tr>
<td>つぁ</td>
<td>tula</td>
</tr>
<tr>
<td>でぃ</td>
<td>deli</td>
</tr>
</tbody></table><h2>怎么打平假名、片假名、汉字</h2>
<ul>
<li>
常用键  <ul>
<li>空格键 = 选择你要用什么字（平假名、片假名、汉字）</li>
<li>回车键 = 确定</li>
</ul>
</li>
<li>
将打出的所有字都转换为片假名 （除了用空格键）  <ul>
<li>Mac = control + k  </li>
<li>Windows = F7（一些键盘不能用这个，还可以试试 fn+F7 ）  </li>
</ul>
</li>
</ul>
]]></content><link href="https://github.com/hadleysu/gitblog/issues/7"/><category term="nihongo"/><published>2023-12-19T15:46:22+00:00</published></entry><entry><id>https://github.com/hadleysu/gitblog/issues/6</id><title>そう～～ 的用法</title><updated>2024-09-01T15:08:35.462328+00:00</updated><content type="html"><![CDATA[<h1>そう～～ 的用法</h1>
<ul>
<li>そう　在对话中代指对方刚说的那句话，“你说的刚才那句话”的意思。</li>
<li>そうです　 “是的，你说得对” ，表同意、肯定。</li>
<li>そうですか　“哦，是这样吗？”，“哦，你说的这样吗？”</li>
<li>そうですね　ね语气助词带有<strong>同意</strong>的语气。“是的，我同意你，是这样的”</li>
<li>そうですよ　よ语气助词有<strong>强调</strong>的作用。“是呀！是这样的呀！”， “对呀！”</li>
<li>そうか　一种带有自言自语的感觉，对方说什么，你自言自语道“哦，这样啊”，“哦，原来如此”</li>
<li>そうなんです　～～なんです　相当于中文“其实”的感觉，“其实是这样的”</li>
<li>そうなんですか　～～なんですか　经常带有<strong>惊讶</strong>的语气，“诶？这样吗？”，“诶，真的是这样吗？”</li>
</ul>
]]></content><link href="https://github.com/hadleysu/gitblog/issues/6"/><category term="nihongo"/><published>2023-12-18T11:30:27+00:00</published></entry><entry><id>https://github.com/hadleysu/gitblog/issues/5</id><title>设计模式</title><updated>2024-09-01T15:08:35.541816+00:00</updated><content type="html"><![CDATA[<h1>设计模式</h1>
<ul>
<li>
<a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a><ul>
<li><a href="#%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95">学习方法</a></li>
<li>
<a href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">第一部分：基础知识</a><ul>
<li>
<a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0">设计模式概述</a><ul>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5">设计模式从何而来</a></li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">设计模式是什么</a></li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">设计模式有什么用</a></li>
</ul>
</li>
<li>
<a href="#uml%E7%B1%BB%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">UML类图相关知识与面向对象设计原则</a><ul>
<li><a href="#uml%E7%B1%BB%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">UML类图相关知识</a></li>
<li><a href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">类之间的关系</a></li>
<li><a href="#7%E4%B8%AA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">7个面向对象设计原则</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%9E%8B">第二部分：创建型模型</a></li>
</ul>
</li>
</ul>
<p>书籍：设计模式的艺术</p>
<h2>学习方法</h2>
<p>在学习每个设计模式时至少应该掌握如下几点：这个设计模式的意图是什么，它要解决一个什么问题，什么时候可以使用它；它是如何解决问题的，掌握它的结构图，记住它的关键代码；能够想到至少两个它的应用实例，一个生活中的，一个软件中的；这个模式的优缺点是什么，在使用时要注意什么。</p>
<h2>第一部分：基础知识</h2>
<h3>设计模式概述</h3>
<ul>
<li>设计模式从何而来？</li>
<li>设计模式是什么？</li>
<li>设计模式有什么用？</li>
</ul>
<h4>设计模式从何而来</h4>
<p>建筑学</p>
<h4>设计模式是什么</h4>
<p>设计模式是软件设计过程中常见问题的典型解决方案。</p>
<h4>设计模式有什么用</h4>
<p>设计模式提供了一种通用语言，可以帮助您的团队更有效地沟通。可以避免做一些重复性的工作，有助于提高设计和开发效率。</p>
<h3>UML类图相关知识与面向对象设计原则</h3>
<ul>
<li>UML类图相关知识</li>
<li>7个面向对象设计原则</li>
</ul>
<h4>UML类图相关知识</h4>
<p>UML（Unified Modeling Language，统一建模语言）。<br />
UML结构主要包括以下几个部分：</p>
<ul>
<li>视图（View）：UML视图用于从不同的角度来表示待建模系统。包括用户视图、结构视图、行为视图、实现视图和环境视图。</li>
<li>图（Diagram）：UML图是描述UML视图内容的图形。13种图，分别是/用例图（Use Case Diagram）/、/类图（Class Diagram）、对象图（Object Diagram）、包图（Package Diagram）、组合结构图（Composite Structure Diagram）/、/状态图（State Diagram）、活动图（Activity Diagram）、顺序图（Sequence Diagram）、通信图（Communication Diagram）、定时图（Timing Diagram）、交互概览图（Interaction Overview Diagram）/、/组件图（Component Diagram）/和/部署图（Deployment Diagram）/，通过它们之间的相互结合可提供待建模系统的所有视图。</li>
<li>模型元素（Model Element）：模型元素是指UML图中所使用的一些概念，它们对应于普通的面向对象概念，如类、对象、消息以及这些概念之间的关系，如关联关系、依赖关系、泛化关系等。</li>
<li>通用机制（General Mechanism）：UML提供的通用机制为模型元素提供额外的注释、信息和语义，这些通用机制也提供了扩展机制，允许用户对UML进行扩展，如定义新的建模元素等等。</li>
</ul>
<h4>类之间的关系</h4>
<p>关联关系</p>
<ul>
<li>双向关联</li>
<li>单向关联</li>
<li>自关联</li>
<li>多重性关联（表示两个关联对象在数量上的对应关系）</li>
<li>聚合关系（表示整体与部分的关系）</li>
<li>组合关系（也表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期）</li>
</ul>
<p>依赖关系</p>
<ul>
<li>在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，<strong>依赖关系体现在某个类的方法使用另一个类的对象作为参数</strong>。</li>
<li>带箭头的虚线表示。</li>
</ul>
<p>泛化关系</p>
<ul>
<li>也就是继承关系，用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。在代码实现时，使用面向对象的<strong>继承</strong>机制来实现泛化关系，如在Java语言中使用<strong>extends</strong>关键字。</li>
<li>用带空心三角形的直线来表示。</li>
</ul>
<p>接口与实现关系</p>
<ul>
<li>在接口中，通常没有属性，而且所有的操作都是抽象的，只有操作的声明，没有操作的实现。<strong>类实现了接口</strong>，类中的操作实现了接口中所声明的操作。在Java语言中使用<strong>implements</strong>关键字。</li>
<li>类与接口之间的实现关系用带空心三角形的虚线来表示。</li>
</ul>
<h4>7个面向对象设计原则</h4>
<ul>
<li>
<p>单一职责原则（Single Responsibility Principle，SRP）</p>
<ul>
<li>一个类只负责一个功能领域中的相应职责。或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</li>
<li>单一职责原则是实现高内聚、低耦合的指导方针。</li>
</ul>
</li>
<li>
<p>开闭原则（Open-Closed Principle，OCP）</p>
<ul>
<li>一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</li>
<li>为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。</li>
<li>在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。</li>
</ul>
</li>
<li>
<p>里氏代换原则（Liskov Substitution Principle，LSP）</p>
<ul>
<li>所有引用基类（父类）的地方必须能透明地使用其子类的对象。</li>
<li>里氏代换原则表明，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。</li>
<li>里氏代换原则是实现开闭原则的重要方式之一。在运用里氏代换原则时，应该将父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法。程序运行时，子类实例替换父类实例，可以很方便地扩展系统的功能，无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。</li>
<li>在这个原则中，&quot;父类&quot;和&quot;子类&quot;的概念是广义的，它们可以是实际的父类和子类（通过继承关系），也可以是接口和实现接口的类（通过实现关系）。</li>
</ul>
</li>
<li>
<p>依赖倒转原则（Dependency Inversion Principle，DIP）</p>
<ul>
<li>抽象不应该依赖于细节，细节应该依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</li>
<li>在实现依赖倒转原则时，需要针对抽象层编程，而将具体类的对象通过依赖注入（Dependency Injection，DI）的方式注入其他对象中。</li>
<li>常用的注入方式有3种：构造注入、设值注入（Setter注入）和接口注入。</li>
<li>在大多数情况下，这3个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段。</li>
</ul>
</li>
<li>
<p>接口隔离原则（Interface Segregation Principle，ISP）</p>
<ul>
<li>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</li>
</ul>
</li>
<li>
<p>合成复用原则（Composition/Aggregate Reuse Principle，CARP）</p>
<ul>
<li>尽量使用对象组合，而不是继承来达到复用的目的。</li>
<li>简言之：复用时要尽量使用组合／聚合关系（关联关系），少用继承。</li>
<li>在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合／聚合关系（黑箱复用）或通过继承（白箱复用）。</li>
<li>但首先应该考虑使用组合／聚合，组合／聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度。</li>
<li>如果两个类之间是“Has-A”的关系，应使用组合或聚合；如果是“Is-A”关系，可使用继承。</li>
</ul>
</li>
<li>
<p>迪米特法则（Law of Demeter，LoD）</p>
<ul>
<li>一个软件实体应当尽可能少地与其他实体发生相互作用。这是对软件实体之间通信的限制。</li>
<li>迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</li>
<li>如果其中一个对象需要调用另一个对象的方法，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。</li>
</ul>
</li>
</ul>
<h2>第二部分：创建型模型</h2>
]]></content><link href="https://github.com/hadleysu/gitblog/issues/5"/><category term="技术相关"/><published>2023-10-16T14:19:29+00:00</published></entry><entry><id>https://github.com/hadleysu/gitblog/issues/4</id><title>python编程从入门到实践笔记</title><updated>2024-09-01T15:08:35.654406+00:00</updated><content type="html"><![CDATA[<h1>python编程从入门到实践笔记<!-- omit in toc --></h1>
<ul>
<li><a href="#is-python-interpreted-or-compiled-yes">Is Python interpreted or compiled? Yes.</a></li>
<li>
<a href="#2-%E5%8F%98%E9%87%8F%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2 变量和简单的数据类型</a><ul>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
<li><a href="#%E6%95%B0">数</a></li>
<li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li>
</ul>
</li>
<li>
<a href="#3-%E5%88%97%E8%A1%A8%E7%AE%80%E4%BB%8B">3 列表简介</a><ul>
<li><a href="#%E5%88%97%E8%A1%A8">列表</a></li>
<li><a href="#%E7%AE%A1%E7%90%86%E5%88%97%E8%A1%A8--sort--sorted--len-">管理列表 ( sort() , sorted() , len() )</a></li>
<li><a href="#%E4%BD%BF%E5%88%97%E8%A1%A8%E6%97%B6%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E9%94%99%E8%AF%AF">使⽤列表时避免索引错误</a></li>
</ul>
</li>
<li>
<a href="#4-%E6%93%8D%E4%BD%9C%E5%88%97%E8%A1%A8">4 操作列表</a><ul>
<li><a href="#%E9%81%8D%E5%8E%86%E6%95%B4%E4%B8%AA%E5%88%97%E8%A1%A8for">遍历整个列表（for）</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E7%BC%A9%E8%BF%9B%E9%94%99%E8%AF%AF">避免缩进错误</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E5%80%BC%E5%88%97%E8%A1%A8--list--range--">创建数值列表 ( list ( range() ) )</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%88%97%E8%A1%A8%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%E5%88%87%E7%89%87">使用列表的一部分（切片）</a></li>
<li><a href="#%E5%85%83%E7%BB%84">元组</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F">设置代码格式</a></li>
</ul>
</li>
<li>
<a href="#5-if-%E8%AF%AD%E5%8F%A5">5 if 语句</a><ul>
<li><a href="#%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F">条件测试（布尔表达式）</a></li>
<li><a href="#if-%E8%AF%AD%E5%8F%A5-if-else-%E8%AF%AD%E5%8F%A5-if-elif-else-%E8%AF%AD%E5%8F%A5">if 语句/ if-else 语句/ if-elif-else 语句</a></li>
<li><a href="#%E4%BD%BF-if-%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E5%88%97%E8%A1%A8">使⽤ if 语句处理列表</a></li>
</ul>
</li>
<li>
<a href="#6-%E5%AD%97%E5%85%B8">6 字典</a><ul>
<li><a href="#%E5%AD%97%E5%85%B8%E5%AE%9A%E4%B9%89--key--value--key--value--">字典定义（ { key : value , key : value } ）</a></li>
<li><a href="#%E4%BD%BF%E5%AD%97%E5%85%B8">使⽤字典</a></li>
<li><a href="#%E9%81%8D%E5%8E%86%E5%AD%97%E5%85%B8">遍历字典</a></li>
<li><a href="#%E5%B5%8C%E5%A5%97">嵌套</a></li>
</ul>
</li>
<li>
<a href="#7-%E6%88%B7%E8%BE%93%E5%92%8C-while-%E5%BE%AA%E7%8E%AF">7 ⽤户输⼊和 while 循环</a><ul>
<li><a href="#%E4%BD%BF-input-%E6%9D%A5%E8%AE%A9%E6%88%B7%E6%8F%90%E4%BE%9B%E4%BF%A1%E6%81%AF">使⽤ input() 来让⽤户提供信息</a></li>
<li><a href="#%E6%8E%A7%E5%88%B6-while-%E5%BE%AA%E7%8E%AF%E6%B5%81%E7%A8%8B%E7%9A%84%E5%BC%8F">控制 while 循环流程的⽅式</a></li>
<li><a href="#%E4%BD%BF-while-%E5%BE%AA%E7%8E%AF%E5%A4%84%E7%90%86%E5%88%97%E8%A1%A8%E5%92%8C%E5%AD%97%E5%85%B8">使⽤ while 循环处理列表和字典</a></li>
</ul>
</li>
<li>
<a href="#8-%E5%87%BD%E6%95%B0">8 函数</a><ul>
<li><a href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%AE%9E%E5%8F%82%E5%BD%A2%E5%8F%82">定义函数、实参形参</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%AE%9E%E5%8F%82">如何传递实参</a></li>
<li><a href="#%E8%BF%94%E5%9B%9E%E5%80%BC">返回值</a></li>
<li><a href="#%E4%BC%A0%E9%80%92%E5%88%97%E8%A1%A8">传递列表</a></li>
<li><a href="#%E4%BC%A0%E9%80%92%E4%BB%BB%E6%84%8F%E6%95%B0%E9%87%8F%E7%9A%84%E5%AE%9E%E5%8F%82-%E5%BD%A2%E5%8F%82--%E5%BD%A2%E5%8F%82">传递任意数量的实参 （*形参 / **形参）</a></li>
<li><a href="#%E5%B0%86%E5%87%BD%E6%95%B0%E5%AD%98%E5%82%A8%E5%9C%A8%E6%A8%A1%E5%9D%97%E4%B8%AD%E5%86%8D%E5%B0%86%E6%A8%A1%E5%9D%97%E5%AF%BC%E4%B8%BB%E7%A8%8B%E5%BA%8F">将函数存储在模块中，再将模块导⼊主程序</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97">函数编写指南</a></li>
</ul>
</li>
<li>
<a href="#9-%E7%B1%BB">9 类</a><ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%B1%BB%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B">创建和使⽤类创建实例</a></li>
<li><a href="#%E7%BB%99%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8C%87%E5%AE%9A%E9%BB%98%E8%AE%A4%E5%80%BC%E4%BF%AE%E6%94%B9%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC">给类的属性指定默认值，修改实例的属性的值</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li>
<li><a href="#%E5%AF%BC%E7%B1%BB">导⼊类</a></li>
<li><a href="#python-%E6%A0%87%E5%87%86%E5%BA%93">Python 标准库</a></li>
<li><a href="#%E7%B1%BB%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A0%BC">类的编程⻛格</a></li>
</ul>
</li>
<li>
<a href="#10-%E4%BB%B6%E5%92%8C%E5%BC%82%E5%B8%B8">10 ⽂件和异常</a><ul>
<li><a href="#%E8%AF%BB%E5%8F%96%E4%BB%B6-path%E5%AF%B9%E8%B1%A1--read_text-">读取⽂件（ path对象 . read_text() ）</a></li>
<li><a href="#%E5%86%99%E4%BB%B6-path%E5%AF%B9%E8%B1%A1--write_text-">写⼊⽂件（ path对象 . write_text() ）</a></li>
<li>
<a href="#%E5%BC%82%E5%B8%B8">异常</a><ul>
<li><a href="#%E4%BD%BF-try-except-%E4%BB%A3%E7%A0%81%E5%9D%97">使⽤ try-except 代码块</a></li>
<li><a href="#else-%E4%BB%A3%E7%A0%81%E5%9D%97">else 代码块</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E6%9C%89">常见的异常类型有</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E6%A8%A1%E5%9D%97-json-%E6%9D%A5%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE">使⽤模块 json 来存储数据</a></li>
<li><a href="#%E9%87%8D%E6%9E%84">重构</a></li>
</ul>
</li>
<li>
<a href="#11-%E4%BD%BF-pytest-%E5%B7%A5%E5%85%B7%E5%BA%93%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">11 使⽤ pytest 工具库测试代码</a><ul>
<li><a href="#%E4%BD%BF-pip-%E5%AE%89%E8%A3%85-pytest">使⽤ pip 安装 pytest</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0">测试函数</a></li>
<li><a href="#%E8%BF%90%E6%B5%8B%E8%AF%95">运⾏测试</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E7%B1%BB">测试类</a></li>
<li><a href="#%E4%BD%BF%E5%A4%B9%E5%85%B7">使⽤夹具</a></li>
</ul>
</li>
</ul>
<h2><a href="https://nedbatchelder.com/blog/201803/is_python_interpreted_or_compiled_yes.html">Is Python interpreted or compiled? Yes.</a></h2>
<h2>2 变量和简单的数据类型</h2>
<h3>变量</h3>
<ul>
<li>
变量(variable)：变量是可以被赋值的标签，也可以说变量指向特定的值(value)。<ul>
<li>变量的命名：变量名只能包含字⺟、数字和下划线 。变量名能以字⺟或下划线打头，但不能以数字打头。变量名不能包含空格，但能使⽤下划线来分隔其中的单词。</li>
<li>注意：应使⽤⼩写的 Python 变量名。全大写定义常量。</li>
</ul>
</li>
</ul>
<h3>字符串</h3>
<ul>
<li>
字符串(string)：。在 Python 中，⽤引号引起的都是字符串，其中的引号可以是单引号，也可以是双引号.<ul>
<li>
<p>使⽤⽅法修改字符串的⼤⼩写:</p>
<pre><code class="language-python">name = &quot;ada lovelace&quot;
print(name.title()) # title() ⽅法以⾸字⺟⼤写的⽅式显⽰每个单词
name = &quot;Ada Lovelace&quot;
print(name.upper()) # upper() 方法以全大写显示字符串
print(name.lower()) # lower() 方法以全小写显示字符串
</code></pre>
</li>
<li>
<p>f 字符串：将要插⼊的变量放在花括号内</p>
<pre><code class="language-python">first_name = &quot;ada&quot;
last_name = &quot;lovelace&quot;
full_name = f&quot;{first_name} {last_name}&quot;
print(full_name)
print(f&quot;Hello, {full_name.title()}!&quot;)
# 这种字符串称为 f 字符串。f 是 format（设置格式）的简写，因为 Python 通过把花括号内的变量替换为其值来设置字符串的格式。
</code></pre>
</li>
<li>
<p>使⽤制表符或换⾏符来添加空⽩</p>
<pre><code class="language-python"># 制表符 \t ; 换行符 \n ;
&gt;&gt;&gt; print(&quot;Languages:\n\tPython\n\tC\n\tJavaScript&quot;)
Languages:
    Python
    C
    JavaScript
</code></pre>
</li>
<li>
<p>删除空⽩</p>
<pre><code class="language-python"># rstrip() lstrip() strip()分别为删除字符串右端的空⽩、删除字符串左端的空⽩、同时删除字符串两端的空⽩
&gt;&gt;&gt; favorite_language = &#x27; python &#x27;
&gt;&gt;&gt; favorite_language.rstrip()
&#x27; python&#x27;
&gt;&gt;&gt; favorite_language.lstrip()
&#x27;python &#x27;
&gt;&gt;&gt; favorite_language.strip()
&#x27;python&#x27;
</code></pre>
</li>
<li>
<p>删除前缀</p>
<pre><code class="language-python"># removeprefix() ⽅法
&gt;&gt;&gt; nostarch_url = &#x27;https://nostarch.com&#x27;
&gt;&gt;&gt; nostarch_url.removeprefix(&#x27;https://&#x27;)
&#x27;nostarch.com&#x27;
# 如果想保留删除前缀后的值，既可将其重新赋给原来的变量，也可将其赋给另⼀个变量
&gt;&gt;&gt; simple_url = nostarch_url.removeprefix(&#x27;https://&#x27;)
</code></pre>
</li>
</ul>
</li>
</ul>
<h3>数</h3>
<ul>
<li>
<p>整数(integer)</p>
<pre><code class="language-python"># Python 使⽤两个乘号（**）表⽰乘⽅运算
&gt;&gt;&gt; 3 ** 2
9
</code></pre>
</li>
<li>
<p>浮点数(float)</p>
<pre><code class="language-python"># 将任意两个数相除，结果总是浮点数，即便这两个数都是整数且能整除：
&gt;&gt;&gt; 4/2
2.0
# 在 Python 中，⽆论是哪种运算，只要有操作数是浮点数，默认得到的就总是浮点数，即便结果原本为整数。
&gt;&gt;&gt; 1 + 2.0
3.0
&gt;&gt;&gt; 2 * 3.0
6.0
&gt;&gt;&gt; 3.0 ** 2
9.0
</code></pre>
</li>
<li>
<p>数中的下划线</p>
<pre><code class="language-python"># 为在存储这种数时，Python 会忽略其中的下划线。在对数字位分组时，即便不是将每三位分成⼀组，也不会影响最终的值。
&gt;&gt;&gt; universe_age = 14_000_000_000
&gt;&gt;&gt; print(universe_age)
14000000000
# 这种表⽰法既适⽤于整数，也适⽤于浮点数。
</code></pre>
</li>
<li>
<p>常数(constant)：是在程序的整个⽣命周期内都保持不变的变量。其变量名全⼤写。</p>
<pre><code class="language-python">MAX_CONNECTIONS = 5000
</code></pre>
</li>
</ul>
<h3>注释</h3>
<ul>
<li>注释(comment)：注释⽤井号（#）标识。批量注释CTRL + /</li>
</ul>
<h2>3 列表简介</h2>
<h3>列表</h3>
<ul>
<li>
<p>列表(list)：由⼀系列按特定顺序排列的元素组成。在 Python 中，⽤⽅括号（[]）表⽰列表，⽤逗号分隔其中的元素。</p>
<ul>
<li>
<p>Python 为访问最后⼀个列表元素提供了⼀种特殊语法。通过将索引指定为-1，可让 Python 返回最后⼀个列表元素。</p>
<pre><code class="language-python">bicycles = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;]
print(bicycles[-1])
# 这些代码返回 &#x27;specialized&#x27;。
</code></pre>
</li>
<li>
<p>这种语法很有⽤，因为你经常需要在不知道列表⻓度的情况下访问最后的元素。这种约定也适⽤于其他负数索引，例如，索引 -2 返回倒数第⼆个列表元素，索引 -3 返回倒数第三个列表元素，依此类推。</p>
</li>
</ul>
</li>
<li>
<p>修改、添加和删除元素</p>
<ul>
<li>
<p>修改列表元素</p>
<pre><code class="language-python">motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]
print(motorcycles)
motorcycles[0] = &#x27;ducati&#x27;
print(motorcycles)
</code></pre>
</li>
<li>
<p>在列表中添加元素</p>
<ul>
<li>
<p>在列表末尾添加元素</p>
<pre><code class="language-python"># 在列表中添加新元素时，最简单的⽅式是将元素追加（append）到列表末尾。
motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]
print(motorcycles)
motorcycles.append(&#x27;ducati&#x27;)
print(motorcycles)
# append() ⽅法让动态地创建列表易如反掌。例如，你可以先创建⼀个空列表，再使⽤⼀系列函数调⽤ append() 添加元素。
motorcycles = []
motorcycles.append(&#x27;honda&#x27;)
motorcycles.append(&#x27;yamaha&#x27;)
motorcycles.append(&#x27;suzuki&#x27;)
print(motorcycles)
</code></pre>
</li>
<li>
<p>在列表中插⼊元素</p>
<pre><code class="language-python"># 使⽤ insert() ⽅法可在列表的任意位置添加新元素。
motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]
motorcycles.insert(0, &#x27;ducati&#x27;)
print(motorcycles)
#这种操作将列表中的每个既有元素都右移⼀个位置。
[&#x27;ducati&#x27;, &#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]
</code></pre>
</li>
</ul>
</li>
<li>
<p>从列表中删除元素</p>
<ul>
<li>
<p>使⽤ del 语句删除元素</p>
<pre><code class="language-python">#如果知道要删除的元素在列表中的位置，可使⽤ del 语句
#使⽤ del 可删除任意位置的列表元素，只需要知道其索引即可。
motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]
print(motorcycles)
del motorcycles[1]
print(motorcycles)
</code></pre>
</li>
<li>
<p>使⽤ pop() ⽅法删除元素</p>
<pre><code class="language-python"># pop() ⽅法删除列表末尾的元素，并让你能够接着使⽤它。每当你使⽤ pop() 时，被弹出的元素就不再在列表中了。
motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]
print(motorcycles)
popped_motorcycle = motorcycles.pop()
print(motorcycles)
print(popped_motorcycle)
# 输出表明，列表末尾的值 &#x27;suzuki&#x27; 已删除，它现在被赋给了变量popped_motorcycle
[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]
[&#x27;honda&#x27;, &#x27;yamaha&#x27;]
suzuki
</code></pre>
</li>
<li>
<p>删除列表中任意位置的元素</p>
<pre><code class="language-python"># 也可以使⽤ pop() 删除列表中任意位置的元素，只需要在括号中指定要删除的元素的索引即可。
motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]
first_owned = motorcycles.pop(0)
print(f&quot;The first motorcycle I owned was a {first_owned.title()}.&quot;)
# ⾸先弹出列表中的第⼀款摩托⻋，然后打印⼀条有关这辆摩托⻋的消息。
The first motorcycle I owned was a Honda.
</code></pre>
<p>如果不确定该使⽤ del 语句还是 pop() ⽅法，下⾯是⼀个简单的判断标准：如果要从列表中删除⼀个元素，且不再以任何⽅式使⽤它，就使⽤ del 语句；如果要在删除元素后继续使⽤它，就使⽤ pop() ⽅法。</p>
</li>
<li>
<p>根据值删除元素</p>
<pre><code class="language-python"># 有时候，你不知道要从列表中删除的值在哪个位置。如果只知道要删除的元素的值，可使⽤ remove() ⽅法。
motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;, &#x27;ducati&#x27;]
print(motorcycles)
motorcycles.remove(&#x27;ducati&#x27;)
print(motorcycles)
# remove() ⽅法让 Python 确定 &#x27;ducati&#x27; 出现在列表的什么地⽅，并将该元素删除：
[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;, &#x27;ducati&#x27;]
[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]
# 注意：remove() ⽅法只删除第⼀个指定的值。如果要删除的值可能在列表中出现多次，就需要使⽤循环，确保将每个值都删除。这将在第 7 章介绍。
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>管理列表 ( sort() , sorted() , len() )</h3>
<ul>
<li>
<p>使⽤ sort() ⽅法对列表进⾏永久排序</p>
<pre><code class="language-python">cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]
cars.sort()
print(cars)
# sort() ⽅法能永久地修改列表元素的排列顺序。现在，汽⻋是按字⺟顺序排列的，再也⽆法恢复到原来的排列顺序：
[&#x27;audi&#x27;, &#x27;bmw&#x27;, &#x27;subaru&#x27;, &#x27;toyota&#x27;]
# 还可以按与字⺟顺序相反的顺序排列列表元素，只需向 sort() ⽅法传递参数 reverse=True 即可。下⾯的⽰例将汽⻋列表按与字⺟顺序相反的顺序排列：
cars.sort(reverse=True)
# 同样，对列表元素排列顺序的修改也是永久的：
[&#x27;toyota&#x27;, &#x27;subaru&#x27;, &#x27;bmw&#x27;, &#x27;audi&#x27;]
</code></pre>
</li>
<li>
<p>使⽤ sorted() 函数对列表进⾏临时排序</p>
<pre><code class="language-python"># 要保留列表元素原来的排列顺序，并以特定的顺序呈现它们，可使⽤sorted() 函数。
cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]
❶ print(&quot;Here is the original list:&quot;)
print(cars)
❷ print(&quot;\nHere is the sorted list:&quot;)
print(sorted(cars))
❸ print(&quot;\nHere is the original list again:&quot;)
print(cars)
# 注意，在调⽤ sorted() 函数后，列表元素的排列顺序并没有变:
Here is the original list:
[&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]
Here is the sorted list:
[&#x27;audi&#x27;, &#x27;bmw&#x27;, &#x27;subaru&#x27;, &#x27;toyota&#x27;]
Here is the original list again:
[&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]
# 如果要按与字⺟顺序相反的顺序显⽰列表，也可向 sorted() 函数传递参数 reverse=True。
# 注意：在并⾮所有的值都是全⼩写的时，按字⺟顺序排列列表要复杂⼀些。在确定排列顺序时，有多种解读⼤写字⺟的⽅式，此时要指定准确的排列顺序，可能会⽐这⾥所做的更加复杂。然⽽，⼤多数排序⽅式是以本节介绍的知识为基础的。
</code></pre>
</li>
<li>
<p>反向打印列表</p>
<pre><code class="language-python"># 要反转列表元素的排列顺序，可使⽤ reverse() ⽅法。
cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]
print(cars)
cars.reverse()
print(cars)
#请注意，reverse() 不是按与字⺟顺序相反的顺序排列列表元素，只是反转列表元素的排列顺序：
[&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]
[&#x27;subaru&#x27;, &#x27;toyota&#x27;, &#x27;audi&#x27;, &#x27;bmw&#x27;]
# reverse() ⽅法会永久地修改列表元素的排列顺序，但可随时恢复到原来的排列顺序，只需对列表再次调⽤ reverse() 即可。
</code></pre>
</li>
<li>
<p>确定列表的⻓度</p>
<pre><code class="language-python"># 使⽤ len() 函数可快速获悉列表的⻓度。
&gt;&gt;&gt; cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]
&gt;&gt;&gt; len(cars)
4
# 注意：Python 在计算列表元素数时从 1 开始，因此你在确定列表⻓度时应该不会遇到差⼀错误。
</code></pre>
</li>
</ul>
<h3>使⽤列表时避免索引错误</h3>
<ul>
<li>仅当列表为空时，这种访问最后⼀个元素的⽅式才会导致错误：</li>
</ul>
<pre><code class="language-python">motorcycles = []
print(motorcycles[-1])
# 列表 motorcycles 不包含任何元素，因此 Python 返回⼀条索引错误消息：
Traceback (most recent call last):
  File &quot;motorcyles.py&quot;, line 3, in &lt;module&gt;
    print(motorcycles[-1])
          ~~~~~~~~~~~^^^^
IndexError: list index out of range
</code></pre>
<ul>
<li><em>注意</em>：在发⽣索引错误却找不到解决办法时，请尝试将列表或其⻓度打印出来。列表可能与你以为的截然不同，在程序对其进⾏了动态处理时尤其如此。查看列表或其包含的元素数，可帮助你排查这种逻辑错误。</li>
</ul>
<h2>4 操作列表</h2>
<h3>遍历整个列表（for）</h3>
<ul>
<li>
<p>for循环。在 for 循环中，想包含多少⾏代码都可以。在代码⾏ for magician inmagicians 后⾯，每⾏缩进的代码都是循环的⼀部分，将针对列表中的每个值执⾏⼀次。因此，可对列表中的每个值执⾏任意多的操作。</p>
<pre><code class="language-python">magicians = [&#x27;alice&#x27;, &#x27;david&#x27;, &#x27;carolina&#x27;]
for magician in magicians:
    print(f&quot;{magician.title()}, that was a great trick!&quot;)
    print(f&quot;I can&#x27;t wait to see your next trick,{magician.title()}.\n&quot;)

print(&quot;Thank you, everyone. That was a great magic show!&quot;)
</code></pre>
</li>
<li>
<p>在for 循环后⾯，没有缩进的代码都只执⾏⼀次，不会重复执⾏。</p>
</li>
</ul>
<h3>避免缩进错误</h3>
<ul>
<li>位于 for 语句后⾯且属于循环组成部分的代码⾏，⼀定要缩进。为避免意外的缩进错误，请只缩进需要缩进的代码。</li>
<li>不要遗漏<em>冒号</em>。for 语句末尾的冒号告诉 Python，下⼀⾏是循环的第⼀⾏。</li>
</ul>
<h3>创建数值列表 ( list ( range() ) )</h3>
<ul>
<li>
<p>range() 函数。Python 函数 range() 能⽣成⼀系列的数。可以传一个参数、两个参数、三个参数。</p>
<pre><code class="language-python">for value in range(1, 3):
    print(value)
# range() 函数让 Python 从指定的第⼀个值开始数，并在到达指定的第⼆个值时停⽌，因此输出不包含第⼆个值（这⾥为 3）。
1
2
# 在使⽤ range() 时，如果输出不符合预期，请尝试将指定的值加 1 或减 1。
#在调⽤ range() 函数时，也可只指定⼀个参数，这样它将从 0 开始，例如，range(6) 返回数 0〜5（含）。
</code></pre>
</li>
<li>
<p>使⽤ range() 创建数值列表  </p>
<p>要创建数值列表，可使⽤ list() 函数将 range() 的结果直接转换为列表。如果将 range() 作为 list() 的参数，输出将是⼀个数值列表。</p>
<pre><code class="language-python">numbers = list(range(1, 6))
print(numbers)
# 结果如下：
[1, 2, 3, 4, 5]
# 在使⽤ range() 函数时，还可指定步⻓。为此，可以给这个函数指定第三个参数，Python 将根据这个步⻓来⽣成数。
# 例如，下⾯的代码打印 1〜10 的偶数：
even_numbers = list(range(2, 11, 2))
print(even_numbers)
# 在这个⽰例中，range() 函数从 2 开始数，然后不断地加 2，直到达到或超过终值（11）。因此输出如下：
[2, 4, 6, 8, 10]
# 如何将前 10 个整数的平⽅加⼊⼀个列表：
squares = []
for value in range(1,11):
    squares.append(value**2)
print(squares)
</code></pre>
</li>
<li>
<p>对数值列表执⾏简单的统计计算  </p>
<p>max(),min(),sum(),找出数值列表中的最⼤值、最⼩值和总和.</p>
<pre><code class="language-python">&gt;&gt;&gt; digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
&gt;&gt;&gt; min(digits)
0
&gt;&gt;&gt; max(digits)
9
&gt;&gt;&gt; sum(digits)
45
</code></pre>
</li>
<li>
<p>列表推导式（list comprehension）  </p>
<p>列表推导式将 for 循环和创建新元素的代码合并成⼀⾏，并⾃动追加新元素。<br />
要使⽤这种语法，⾸先指定⼀个描述性的列表名，如 squares。然后指定⼀个左⽅括号，并定义⼀个表达式，⽤于⽣成要存储到列表中的值。在这个⽰例中，表达式为 value** 2，它计算平⽅值。接下来，编写⼀个 for循环，⽤于给表达式提供值，再加上右⽅括号。在这个⽰例中，for 循环为 for value in range(1,11)，它将值1〜10 提供给表达式value * * 2。请注意，这⾥的 for 语句末尾没有冒号。</p>
<pre><code class="language-python">squares = [value**2 for value in range(1, 11)]
print(squares)
# 结果:
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</code></pre>
</li>
</ul>
<h3>使用列表的一部分（切片）</h3>
<ul>
<li>
<p>切片（slice）  </p>
<p>切片就是列表中的部分元素。要创建切⽚，可指定要使⽤的第⼀个元素和最后⼀个元素的索引。与range() 函数⼀样，Python 在到达指定的第⼆个索引之前的元素时停⽌。要输出列表中的前三个元素，需要指定索引 0 和 3，这将返回索引分别为0、1 和 2 的元素。</p>
<pre><code class="language-python">players = [&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]
print(players[0:3])
# 这些代码打印该列表的⼀个切⽚。输出也是⼀个列表，其中包含前三名队员：
[&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;]
# 可以⽣成列表的任意⼦集。例如，如果要提取列表的第⼆、第三和第四个元素，可将起始索引指定为 1，并将终⽌索引指定为 4：
players = [&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]
print(players[1:4])
# 在⽣成的切⽚中，第⼀个元素为 &#x27;martina&#x27;，最后⼀个元素为&#x27;florence&#x27;：
[&#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;]
# 如果没有指定第⼀个索引，Python 将⾃动从列表开头开始：
players = [&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]
print(players[:4])
# 由于没有指定起始索引，Python 从列表开头开始提取：
[&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;]
# 要让切⽚终⽌于列表末尾，也可使⽤类似的语法。例如，如果要提取从第三个元素到列表末尾的所有元素，可将起始索引指定为 2，并省略终⽌索引：
players = [&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]
print(players[2:])
# Python 返回从第三个元素到列表末尾的所有元素：
[&#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]
# 负数索引返回与列表末尾有相应距离的元素，因此可以输出列表末尾的任意切⽚。如果要输出名单上最后三名队员的名字，可使⽤切⽚ players[-3:]：
players = [&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]
print(players[-3:])
</code></pre>
<p>注意：可在表⽰切⽚的⽅括号内指定第三个值。这个值告诉 Python 在指定范围内每隔多少元素提取⼀个。</p>
</li>
<li>
<p>遍历切片  </p>
<p>如果要遍历列表的部分元素，可在 for 循环中使⽤切⽚。</p>
<pre><code class="language-python">players = [&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]
print(&quot;Here are the first three players on my team:&quot;)
❶for player in players[:3]:
    print(player.title())
# ❶处的代码没有遍历整个队员列表，只遍历前三名队员：
Here are the first three players on my team:
Charles
Martina
Michael
</code></pre>
</li>
<li>
<p>复制列表  </p>
<p>要复制列表，可以创建⼀个包含整个列表的切⽚，⽅法是同时省略起始索引和终⽌索引（[:]）。这让 Python 创建⼀个起始于第⼀个元素、终⽌于最后⼀个元素的切⽚，即复制整个列表。</p>
<pre><code class="language-python">my_foods = [&#x27;pizza&#x27;, &#x27;falafel&#x27;, &#x27;carrot cake&#x27;]
❶ friend_foods = my_foods[:]
❷ my_foods.append(&#x27;cannoli&#x27;)
❸ friend_foods.append(&#x27;ice cream&#x27;)
###########################################
# 这是⾏不通的：
friend_foods = my_foods
my_foods.append(&#x27;cannoli&#x27;)
friend_foods.append(&#x27;ice cream&#x27;)
# 上面❶将my_foods的切片赋给friend_foods，所以❷修改的是my_foods列表，❸修改的是friend_foods列表即my_foods的切片。
# 而不使用切片，直接将my_foods赋值给friend_foods，意味着friend_foods和my_foods一起关联my_foods列表，因此这两个变量指向同⼀个列表。
</code></pre>
</li>
</ul>
<h3>元组</h3>
<ul>
<li>
<p>元组（tuple）  </p>
<p>Python将不能修改的值称为不可变的，⽽不可变的列表称为元组（tuple）。如果需要存储⼀组在程序的整个⽣命周期内都不变的值，就可以使⽤元组。<br />
元组看起来很像列表，但使⽤<em>圆括号</em>⽽不是⽅括号来标识。定义元组后，就可使⽤索引来访问其元素，就像访问列表元素⼀样。</p>
<pre><code class="language-python">dimensions = (200, 50)
print(dimensions[0])
print(dimensions[1])
# ⾸先定义元组 dimensions，为此使⽤了圆括号⽽不是⽅括号。接下来，分别打印该元组的各个元素，使⽤的语法与访问列表元素时使⽤的语法相同
</code></pre>
<p>试图修改元组的操作是被禁⽌的,一旦修改将导致Python 返回类型错误的消息。</p>
<pre><code class="language-python">dimensions = (200, 50)
dimensions[0] = 250
# 在代码试图修改矩形的尺⼨时，Python 会报错。
</code></pre>
<p><em>注意</em>：严格地说，元组是由逗号标识的，圆括号只是让元组看起来更整洁、更清晰。如果你要定义只包含⼀个元素的元组，必须在这个元素后⾯加上逗号：</p>
<pre><code class="language-python">my_t = (3,)
# 创建只包含⼀个元素的元组通常没有意义，但⾃动⽣成的元组有可能只有⼀个元素。
</code></pre>
</li>
<li>
<p>fot循环遍历元组中的所有值</p>
<pre><code class="language-python">dimensions = (200, 50)
for dimension in dimensions:
    print(dimension)
</code></pre>
</li>
<li>
<p>修改元组变量  </p>
<p>虽然不能修改元组的元素，但可以给表⽰元组的变量赋值。例如，要修改前述矩形的尺⼨，可重新定义整个元组：</p>
<pre><code class="language-python">dimensions = (200, 50)
dimensions = (400, 100)
# 将⼀个新元组关联到变量 dimensions,Python 没有引发任何错误，因为给元组变量重新赋值是合法的
</code></pre>
</li>
</ul>
<h3>设置代码格式</h3>
<ul>
<li>
<p>Python Enhancement Proposal，PEP(Python 增强提案)  </p>
</li>
<li>
<p>缩进  </p>
<p>PEP 8 建议每级缩进都使⽤ 4 个空格。在编写Python代码时，混用Tab键和空格可能会导致错误。如果混合使⽤了制表符和空格，可将⽂件中的所有制表符都转换为空格，⼤多数编辑器提供了这样的功能。</p>
</li>
<li>
<p>行长  </p>
<p>建议每⾏不超过 80 个字符。注释的⾏⻓不超过 72 个字符。</p>
</li>
<li>
<p>空行  </p>
<p>将程序的不同部分分开，可使⽤空⾏。</p>
</li>
</ul>
<h2>5 if 语句</h2>
<h3>条件测试（布尔表达式）</h3>
<ul>
<li>布尔表达式的结果要么为 True，要么为 False。  </li>
<li>
检查是否相等 ==<ul>
<li>在 Python 中检查是否相等时是区分⼤⼩写的。</li>
</ul>
</li>
<li>检查是否不等 !=</li>
<li>数值⽐较 == / != / &lt; / &lt;= / &gt; / &gt;=</li>
<li>检查多个条件时的且或 and / or</li>
<li>检查特定的值是否在列表中 in</li>
<li>检查特定的值是否不在列表中 not in</li>
</ul>
<h3>if 语句/ if-else 语句/ if-elif-else 语句</h3>
<ul>
<li>
<p>if 语句/ if-else 语句/ if-elif-else 语句</p>
<ul>
<li>if-elif-else 语句中可以使⽤多个 elif 代码块</li>
<li>Python 并不要求 if-elif 结构后⾯必须有 else 代码块。可省略 else 代码块。</li>
</ul>
<pre><code class="language-python">age = 12
if age &lt; 4:
price = 0
elif age &lt; 18:
price = 25
else:
price = 40
print(f&quot;Your admission cost is ${price}.&quot;)
</code></pre>
</li>
</ul>
<h3>使⽤ if 语句处理列表</h3>
<ul>
<li>
<p>检查特殊元素</p>
<pre><code class="language-python">requested_toppings = [&#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;]
for requested_topping in requested_toppings:
    if requested_topping == &#x27;green peppers&#x27;:
        print(&quot;Sorry, we are out of green peppers right now.&quot;)
    else:
        print(f&quot;Adding {requested_topping}.&quot;)
</code></pre>
</li>
<li>
<p>确定列表⾮空</p>
<pre><code class="language-python">requested_toppings = []
if requested_toppings:
    for requested_topping in requested_toppings:
        print(f&quot;Adding {requested_topping}.&quot;)
    print(&quot;\nFinished making your pizza!&quot;)
else:
    print(&quot;Are you sure you want a plain pizza?&quot;)
# 这⾥的列表为空，因此输出如下——询问顾客是否确实要点原味⽐萨：
Are you sure you want a plain pizza?
</code></pre>
<ul>
<li>在 if 语句中将列表名⽤作条件表达式时，Python将在列表⾄少包含⼀个元素时返回 True，在列表为空时返回 False 。</li>
<li><strong>对于数值 0、空值 None、单引号空字符串 ''、双引号空字符串 &quot;&quot;、空列表 []、空元组 ()、空字典 {}，Python 都会返回 False。</strong></li>
</ul>
</li>
<li>
<p>使⽤多个列表</p>
<pre><code class="language-python">available_toppings = [&#x27;mushrooms&#x27;, &#x27;olives&#x27;, &#x27;green peppers&#x27;,&#x27;pepperoni&#x27;, &#x27;pineapple&#x27;, &#x27;extra cheese&#x27;]
requested_toppings = [&#x27;mushrooms&#x27;, &#x27;french fries&#x27;, &#x27;extra cheese&#x27;]

for requested_topping in requested_toppings:
    if requested_topping in available_toppings:
       print(f&quot;Adding {requested_topping}.&quot;)
    else:
       print(f&quot;Sorry, we don&#x27;t have {requested_topping}.&quot;)
print(&quot;\nFinished making your pizza!&quot;)
# 输出
Adding mushrooms.
Sorry, we don&#x27;t have french fries.
Adding extra cheese.
Finished making your pizza!
</code></pre>
</li>
</ul>
<h2>6 字典</h2>
<h3>字典定义（ { key : value , key : value } ）</h3>
<ul>
<li>在 Python 中，字典（dictionary）是⼀系列<strong>键值对</strong>。每个<strong>键</strong>都与⼀个值关联，可以使⽤键来访问与之关联的值。与键相关联的值可以是数、字符串、列表乃⾄字典。事实上，可将任意 Python 对象⽤作字典中的值。</li>
<li>在 Python 中，字典⽤放在<strong>花括号</strong>（{}）中的⼀系列键值对表⽰。</li>
<li><strong>键值对</strong>包含两个相互关联的值。当你指定键时，Python 将返回与之关联的值。键和值之间⽤<strong>冒号</strong>分隔，⽽键值对之间⽤<strong>逗号</strong>分隔。在字典中，你想存储多少个键值对都可以。</li>
</ul>
<pre><code class="language-python">alien_0 = {&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5}
</code></pre>
<h3>使⽤字典</h3>
<ul>
<li>
<p>访问字典中的值</p>
<pre><code class="language-python"># 要获取与键关联的值，可指定字典名并把键放在后⾯的⽅括号内，如下所⽰：
alien_0 = {&#x27;color&#x27;: &#x27;green&#x27;}
print(alien_0[&#x27;color&#x27;])
green
</code></pre>
</li>
<li>
<p>添加键值对</p>
<pre><code class="language-python"># 字典是⼀种动态结构，可随时在其中添加键值对。要添加键值对，可依次指定字典名、⽤⽅括号括起来的键和与该键关联的值。
alien_0 = {&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5}
print(alien_0)
alien_0[&#x27;x_position&#x27;] = 0
alien_0[&#x27;y_position&#x27;] = 25
print(alien_0)
# 字典会保留定义时的元素排列顺序。如果将字典打印出来或遍历其元素，将发现元素的排列顺序与其添加顺序相同。
{&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5}
{&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5, &#x27;x_position&#x27;: 0, &#x27;y_position&#x27;: 25}
</code></pre>
</li>
<li>
<p>创建⼀个空字典</p>
<pre><code class="language-python">alien_0 = {}
alien_0[&#x27;color&#x27;] = &#x27;green&#x27;
alien_0[&#x27;points&#x27;] = 5
</code></pre>
</li>
<li>
<p>修改字典中的值</p>
<pre><code class="language-python"># 要修改字典中的值，可依次指定字典名、⽤⽅括号括起来的键和与该键关联的新值。
alien_0 = {&#x27;color&#x27;: &#x27;green&#x27;}
alien_0[&#x27;color&#x27;] = &#x27;yellow&#x27;
</code></pre>
</li>
<li>
<p>删除键值对</p>
<pre><code class="language-python">#对于字典中不再需要的信息，可使⽤ del 语句将相应的键值对彻底删除。在使⽤ del 语句时，必须指定字典名和要删除的键。
alien_0 = {&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5}
del alien_0[&#x27;points&#x27;]
print(alien_0)
# 注意：删除的键值对永远消失了。
{&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5}
{&#x27;color&#x27;: &#x27;green&#x27;}
</code></pre>
</li>
<li>
<p>由类似的对象组成的字典</p>
<pre><code class="language-python"># 当确定需要使⽤多⾏来定义字典时，先在输⼊左花括号后按回⻋键，再在下⼀⾏缩进 4 个空格，指定第⼀个键值对，并在它后⾯加上⼀个逗号。
favorite_languages = {
    &#x27;jen&#x27;: &#x27;python&#x27;,
    &#x27;sarah&#x27;: &#x27;c&#x27;,
    &#x27;edward&#x27;: &#x27;rust&#x27;,
    &#x27;phil&#x27;: &#x27;python&#x27;,
    }
# 定义好字典后，在最后⼀个键值对的下⼀⾏添加⼀个右花括号，并且也缩进 4 个空格，使其与字典中的键对⻬。
# ⼀种不错的做法是，在最后⼀个键值对后⾯也加上逗号，为以后添加键值对做好准备。
</code></pre>
</li>
<li>
<p>使⽤ get() 来访问值</p>
<ul>
<li>
<p>如果指定的键有可能不存在，应考虑使⽤ get() ⽅法，⽽不要使⽤⽅括号表⽰法，因为会报错。</p>
</li>
<li>
<p>get() ⽅法在指定的键不存在时返回⼀个默认值。get() ⽅法的第⼀个参数⽤于指定键，是必不可少的；第⼆个参数为当指定的键不存在时要返回的值，是可选的。</p>
</li>
<li>
<p>注意：在调⽤ get() 时，如果没有指定第⼆个参数且指定的键不存在，Python 将返回值 None，这个特殊的值表⽰没有相应的值。这并⾮错误，None 只是⼀个表⽰所需值不存在的特殊值，第 8 章将介绍它的其他⽤途。</p>
<pre><code class="language-python">alien_0 = {&#x27;color&#x27;: &#x27;green&#x27;, &#x27;speed&#x27;: &#x27;slow&#x27;}
point_value = alien_0.get(&#x27;points&#x27;, &#x27;No point value assigned.&#x27;)
print(point_value)
# 如果字典中有键 &#x27;points&#x27;，将获得与之关联的值；如果没有，将获得指定的默认值。虽然这⾥没有键 &#x27;points&#x27;，但是我们将获得⼀条清晰的消息，不会引发错误：
No point value assigned.
</code></pre>
</li>
</ul>
</li>
</ul>
<h3>遍历字典</h3>
<ul>
<li>
<p>遍历所有的键值对 ( items() )<br />
字典名.items()，这个⽅法返回⼀个键值对列表。  </p>
<pre><code class="language-python">favorite_languages = {
    &#x27;jen&#x27;: &#x27;python&#x27;,
    &#x27;sarah&#x27;: &#x27;c&#x27;,
    &#x27;edward&#x27;: &#x27;rust&#x27;,
    &#x27;phil&#x27;: &#x27;python&#x27;,
    }
for name, language in favorite_languages.items():
    print(f&quot;{name.title()}&#x27;s favorite language is {language.title()}.&quot;)
# 这些代码让 Python 遍历字典中的每个键值对，并将键赋给变量 name，将值赋给变量 language。
Jen&#x27;s favorite language is Python.
Sarah&#x27;s favorite language is C.
Edward&#x27;s favorite language is Rust.
Phil&#x27;s favorite language is Python.
</code></pre>
</li>
<li>
<p>遍历字典中的所有键 ( keys() )</p>
<pre><code class="language-python">favorite_languages = {
    &#x27;jen&#x27;: &#x27;python&#x27;,
    &#x27;sarah&#x27;: &#x27;c&#x27;,
    &#x27;edward&#x27;: &#x27;rust&#x27;,
    &#x27;phil&#x27;: &#x27;python&#x27;,
    }
for name in favorite_languages.keys():
    print(name.title())
# keys() ⽅法并⾮只能⽤于遍历：实际上，它会返回⼀个列表，其中包含字典中的所有键。
if &#x27;erin&#x27; not in favorite_languages.keys():
    print(&quot;Erin, please take our poll!&quot;)
# 输出
Erin, please take our poll!
</code></pre>
</li>
<li>
<p>按特定的顺序遍历字典中的所有键 ( sorted() )</p>
<pre><code class="language-python">favorite_languages = {
      &#x27;jen&#x27;: &#x27;python&#x27;,
      &#x27;sarah&#x27;: &#x27;c&#x27;,
      &#x27;edward&#x27;: &#x27;rust&#x27;,
      &#x27;phil&#x27;: &#x27;python&#x27;,
      }
for name in sorted(favorite_languages.keys()):
    print(f&quot;{name.title()}, thank you for taking the poll.&quot;)
# 对⽅法 dictionary.keys() 的结果调⽤了 sorted() 函数。这让 Python 获取字典中的所有键，并在遍历前对这个列表进⾏排序。输出表明，按字⺟顺序显⽰了所有被调查者的名字：
Edward, thank you for taking the poll.
Jen, thank you for taking the poll.
Phil, thank you for taking the poll.
Sarah, thank you for taking the poll.
</code></pre>
</li>
<li>
<p>遍历字典中的所有值 ( values() ，set() )</p>
<pre><code class="language-python">favorite_languages = {
    &#x27;jen&#x27;: &#x27;python&#x27;,
    &#x27;sarah&#x27;: &#x27;c&#x27;,
    &#x27;edward&#x27;: &#x27;rust&#x27;,
    &#x27;phil&#x27;: &#x27;python&#x27;,
    }
for language in favorite_languages.values():
    print(language.title())
# 这条 for 语句提取字典中的每个值，并将它们依次赋给变量 language。
Python
C
Rust
Python
# 这种做法提取字典中所有的值，⽽没有考虑值是否有重复。这种做法提取字典中所有的值，⽽没有考虑值是否有重复。
for language in set(favorite_languages.values()):
    print(language.title())
# 通过将包含重复元素的列表传⼊ set()，可让 Python 找出列表中独⼀⽆⼆的元素，并使⽤这些元素来创建⼀个集合。
Python
C
Rust
</code></pre>
<ul>
<li>
<p>注意：可以使⽤⼀对花括号直接创建集合，并在其中⽤逗号分隔元素：</p>
<pre><code class="language-python">&gt;&gt;&gt; languages = {&#x27;python&#x27;, &#x27;rust&#x27;, &#x27;python&#x27;, &#x27;c&#x27;}
&gt;&gt;&gt; languages
{&#x27;rust&#x27;, &#x27;python&#x27;, &#x27;c&#x27;}
</code></pre>
</li>
<li>
<p>集合和字典很容易混淆，因为它们都是⽤⼀对花括号定义的。当花括号内没有键值对时，定义的很可能是集合。</p>
</li>
<li>
<p>不同于列表和字典，集合不会以特定的顺序存储元素（集合本质上是无序的）。</p>
</li>
</ul>
</li>
</ul>
<h3>嵌套</h3>
<ul>
<li>
<p>字典列表</p>
<pre><code class="language-python"># 创建⼀个⽤于存储外星⼈的空列表
aliens = []
# 创建 30 个绿⾊的外星⼈
# range() 函数返回⼀个数字序列，告诉 Python 要重复这个循环多少次。
for alien_number in range(30):
    new_alien = {&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5, &#x27;speed&#x27;: &#x27;slow&#x27;}
    aliens.append(new_alien)
# 使⽤⼀个切⽚来打印前 5 个外星⼈。
for alien in aliens[:5]:
    print(alien)
# 显⽰创建了多少个外星⼈
print(f&quot;Total number of aliens: {len(aliens)}&quot;)
</code></pre>
</li>
<li>
<p>在字典中存储列表  </p>
<p>每当需要在字典中将⼀个键关联到多个值时，都可以在字典中嵌套⼀个列表。</p>
<pre><code class="language-python"># 在这⾥，与每个名字关联的值都是⼀个列表。请注意，有些⼈喜欢的语⾔只有⼀种，⽽有些⼈喜欢的不⽌⼀种。
favorite_languages = {
    &#x27;jen&#x27;: [&#x27;python&#x27;, &#x27;rust&#x27;],
    &#x27;sarah&#x27;: [&#x27;c&#x27;],
    &#x27;edward&#x27;: [&#x27;rust&#x27;, &#x27;go&#x27;],
    &#x27;phil&#x27;: [&#x27;python&#x27;, &#x27;haskell&#x27;],
    }
for name, languages in favorite_languages.items():
    print(f&quot;\n{name.title()}&#x27;s favorite languages are:&quot;)
    for language in languages:
        print(f&quot;\t{language.title()}&quot;)
# 注意：列表和字典的嵌套层级不应太多。
</code></pre>
</li>
<li>
<p>在字典中存储字典</p>
<pre><code class="language-python">users = {
    &#x27;aeinstein&#x27;: {
        &#x27;first&#x27;: &#x27;albert&#x27;,
        &#x27;last&#x27;: &#x27;einstein&#x27;,
        &#x27;location&#x27;: &#x27;princeton&#x27;,
        },
    &#x27;mcurie&#x27;: {
        &#x27;first&#x27;: &#x27;marie&#x27;,
        &#x27;last&#x27;: &#x27;curie&#x27;,
        &#x27;location&#x27;: &#x27;paris&#x27;,
        },
    }
for username, user_info in users.items():
    print(f&quot;\nUsername: {username}&quot;)
    full_name = f&quot;{user_info[&#x27;first&#x27;]} {user_info[&#x27;last&#x27;]}&quot;
    location = user_info[&#x27;location&#x27;]
    print(f&quot;\tFull name: {full_name.title()}&quot;)
    print(f&quot;\tLocation: {location.title()}&quot;)
# 输出

Username: aeinstein
    Full name: Albert Einstein
    Location: Princeton

Username: mcurie
    Full name: Marie Curie
    Location: Paris
# ⾸先定义⼀个名为 users 的字典，其中包含两个键：⽤户名&#x27;aeinstein&#x27; 和 &#x27;mcurie&#x27;。与每个键关联的值都是⼀个字典，其中包含⽤户的名、姓和居住地。然后，遍历字典 users，让 Python 依次将每个键赋给变量 username，并依次将与当前键相关联的字典赋给变量 user_info。在循环内部，将⽤户名打印出来了。接下来，开始访问内部的字典。变量user_info 包含⽤户信息字典，⽽该字典包含三个键：&#x27;first&#x27;、&#x27;last&#x27; 和 &#x27;location&#x27;。对于每个⽤户，都使⽤这些键来⽣成整洁的姓名和居住地，然后打印有关⽤户的简要信息
</code></pre>
</li>
</ul>
<h2>7 ⽤户输⼊和 while 循环</h2>
<h3>使⽤ input() 来让⽤户提供信息</h3>
<ul>
<li>
<p>input() 函数让程序暂停运⾏，等待⽤户输⼊⼀些⽂本。获取⽤户输⼊后，Python 将其赋给⼀个变量，以便使⽤。</p>
<pre><code class="language-python">message = input(&quot;Tell me something, and I will repeat it back to you: &quot;)
print(message)
# input() 函数接受⼀个参数，即要向⽤户显⽰的提⽰（prompt），让⽤户知道该输⼊什么样的信息。
</code></pre>
</li>
<li>
<p>使⽤ int() 来获取数值输⼊（如何处理⽂本和数的输⼊）</p>
<p>在使⽤ input() 函数时，Python 会将⽤户输⼊解读为字符串。<br />
在将数值输⼊⽤于计算和⽐较前，务必将其转换为数值表⽰。</p>
<pre><code class="language-python">height = input(&quot;How tall are you, in inches? &quot;)
height = int(height)
if height &gt;= 48:
 print(&quot;\nYou&#x27;re tall enough to ride!&quot;)
else:
 print(&quot;\nYou&#x27;ll be able to ride when you&#x27;re a little older.&quot;)
# 在⽐较前，height = int(height) 将输⼊转换成了数值表⽰。
# 如果输⼊的数⼤于或等于 48，就指出⽤户满⾜⾝⾼条件：
How tall are you, in inches? 71
You&#x27;re tall enough to ride!
</code></pre>
</li>
<li>
<p>求模运算符 ( % )  </p>
<p>它将两个数相除并返回余数。求模运算符不会指出⼀个数是另⼀个数的多少倍，只指出余数是多少。</p>
<pre><code class="language-python">&gt;&gt;&gt; 4 % 3
1
&gt;&gt;&gt; 5 % 3
2
&gt;&gt;&gt; 6 % 3
0
&gt;&gt;&gt; 7 % 3
1
</code></pre>
<p>如果⼀个数可被另⼀个数整除，余数就为 0，因此求模运算将返回 0。可利⽤这⼀点来判断⼀个数是奇数还是偶数：</p>
<pre><code class="language-python">number = input(&quot;Enter a number, and I&#x27;ll tell you if it&#x27;s even or odd: &quot;)
number = int(number)
if number % 2 == 0:
    print(f&quot;\nThe number {number} is even.&quot;)
else:
    print(f&quot;\nThe number {number} is odd.&quot;)

</code></pre>
</li>
</ul>
<h3>控制 while 循环流程的⽅式</h3>
<ul>
<li>
<p>使⽤标志（flag）</p>
<p><strong>注意：python 中 True 和 False 要开头大写</strong></p>
<pre><code class="language-python"># 这个变量称为标志（flag），充当程序的交通信号灯。可以让程序在标志为 True 时继续运⾏，并在任何事件导致标志的值为 False 时让程序停⽌运⾏。
prompt = &quot;\nTell me something, and I will repeat it back to you:&quot;
prompt += &quot;\nEnter &#x27;quit&#x27; to end the program. &quot;
active = True
while active:
    message = input(prompt)
    if message == &#x27;quit&#x27;:
        active = False
    else:
        print(message)
</code></pre>
</li>
<li>
<p>使⽤ break 退出循环</p>
<pre><code class="language-python"># 在所有 Python 循环中都可使⽤ break 语句。例如，可使⽤break 语句来退出遍历列表或字典的 for 循环。
prompt = &quot;\nPlease enter the name of a city you have visited:&quot;
prompt += &quot;\n(Enter &#x27;quit&#x27; when you are finished.) &quot;
while True:
    city = input(prompt)
    if city == &#x27;quit&#x27;:
        break
    else:
        print(f&quot;I&#x27;d love to go to {city.title()}!&quot;)

</code></pre>
</li>
<li>
<p>在循环中使⽤ continue</p>
<pre><code class="language-python"># 执⾏ continue 语句，让 Python 忽略余下的代码，并返回循环的开头。
# 打印1-10奇数
current_number = 0
while current_number &lt; 10:
    current_number += 1
    if current_number % 2 == 0:
        continue
    print(current_number)
</code></pre>
</li>
</ul>
<h3>使⽤ while 循环处理列表和字典</h3>
<ul>
<li>
<p>for 循环是⼀种遍历列表的有效⽅式，但不应该在 for 循环中修改列表，否则将导致 Python 难以跟踪其中的元素。要在遍历列表的同时修改它，可使⽤ while 循环。</p>
<pre><code class="language-python"># 错误操作一
a = [1, 2, 4, 4, 5]
for i, v in enumerate(a):
    if v == 4:
        del a[i]
# 结果为 
a = [1, 2, 4, 5]
# 这是因为 Python 的 for 循环存在自动填充，即在循环中自动填充列表中的下一个元素，如果在循环中修改列表的值，可能会引发错误。
# 由于在遍历的过程中，删除了其中一个元素，导致后面的元素整体前移，导致有个元素成了漏网之鱼。
a  0 1 2 3 4   --&gt;     0 1 2 3
   1 2 4 4 5   --&gt;     1 2 4 5
</code></pre>
<pre><code class="language-python"># 错误操作二
a = [1, 2, 4, 4, 5]
for i in range(len(a)):
    if a[i] == 4:
        del a[i]
# 直接报错
IndexError: list index out of range
i 最大取值为4，但删除操作后的列表长度为4，最大下标为3，所以报错 list index out of range
</code></pre>
<pre><code class="language-python"># 正确操作
a = [1, 2, 4, 4, 5]
i = 0
while i &lt; len(a):
    if a[i] == 4:
        del a[i]
    else:
        i += 1
</code></pre>
</li>
<li>
<p>在列表之间移动元素</p>
<pre><code class="language-python"># ⾸先，创建⼀个待验证⽤户列表
# 和⼀个⽤于存储已验证⽤户的空列表
unconfirmed_users = [&#x27;alice&#x27;, &#x27;brian&#x27;, &#x27;candace&#x27;]
confirmed_users = []
# 验证每个⽤户，直到没有未验证⽤户为⽌
# 将每个经过验证的⽤户都移到已验证⽤户列表中
# while 循环将不断地运⾏，直到列表 unconfirmed_users 变成空的。
while unconfirmed_users:
    current_user = unconfirmed_users.pop()
    print(f&quot;Verifying user: {current_user.title()}&quot;)
    confirmed_users.append(current_user)
# 显⽰所有的已验证⽤户
print(&quot;\nThe following users have been confirmed:&quot;)
for confirmed_user in confirmed_users:
    print(confirmed_user.title())
# 输出
Verifying user: Candace
Verifying user: Brian
Verifying user: Alice
The following users have been confirmed:
Candace
Brian
Alice
</code></pre>
</li>
<li>
<p>删除为特定值的所有列表元素</p>
<pre><code class="language-python">pets = [&#x27;dog&#x27;, &#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;goldfish&#x27;, &#x27;cat&#x27;, &#x27;rabbit&#x27;, &#x27;cat&#x27;]
print(pets)
while &#x27;cat&#x27; in pets:
    pets.remove(&#x27;cat&#x27;)
print(pets)
# 输出
[&#x27;dog&#x27;, &#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;goldfish&#x27;, &#x27;cat&#x27;, &#x27;rabbit&#x27;, &#x27;cat&#x27;]
[&#x27;dog&#x27;, &#x27;dog&#x27;, &#x27;goldfish&#x27;, &#x27;rabbit&#x27;]
</code></pre>
</li>
<li>
<p>使⽤⽤户输⼊填充字典</p>
<pre><code class="language-python"># 可以使⽤ while 循环提⽰⽤户输⼊任意多的信息。下⾯创建⼀个调查程序，其中的循环在每次执⾏时都提⽰输⼊被调查者的名字和回答。我们将收集到的数据存储在⼀个字典中，以便将回答与被调查者关联起来：
responses = {}
# 设置⼀个标志，指出调查是否继续
polling_active = True
while polling_active:
    # 提⽰输⼊被调查者的名字和回答
    name = input(&quot;\nWhat is your name? &quot;)
    response = input(&quot;Which mountain would you like to climb someday? &quot;)
    # 将回答存储在字典中
    responses[name] = response
    # 看看是否还有⼈要参与调查
    repeat = input(&quot;Would you like to let another person respond? (yes/no) &quot;)
    if repeat == &#x27;no&#x27;:
        polling_active = False
# 调查结束，显⽰结果
print(&quot;\n--- Poll Results ---&quot;)
for name, response in responses.items():
    print(f&quot;{name} would like to climb {response}.&quot;)
# 输出

What is your name? Eric
Which mountain would you like to climb someday? Denali
Would you like to let another person respond? (yes/no) yes
What is your name? Lynn
Which mountain would you like to climb someday? Devil&#x27;s Thumb
Would you like to let another person respond? (yes/no) no
--- Poll Results ---
Eric would like to climb Denali.
Lynn would like to climb Devil&#x27;s Thumb.
</code></pre>
</li>
</ul>
<h2>8 函数</h2>
<h3>定义函数、实参形参</h3>
<ul>
<li>
<p>函数（function）是带名字的代码块，⽤于完成具体的⼯作。要执⾏函数定义的特定任务，可调⽤（call）该函数。</p>
</li>
<li>
<p>使⽤关键字 def 定义函数。这是函数定义，向 Python 指出了函数名，还可以在括号内指出函数为完成任务需要什么样的信息。最后，定义以冒号结尾。</p>
</li>
<li>
<p>紧跟在 def greet_user(): 后⾯的所有缩进⾏构成了函数体。第⼆⾏的⽂本是称为⽂档字符串（docstring）的注释，描述了函数是做什么的。Python 在为程序中的函数⽣成⽂档时，会查找紧跟在函数定义后的字符串。这些字符串通常前后分别⽤三个双引号引起，能够包含多⾏。</p>
</li>
<li>
<p>函数调⽤让 Python 执⾏函数中的代码。要调⽤函数，可依次指定函数名以及⽤括号括起的必要信息。</p>
<pre><code class="language-python">def greet_user(username):
    &quot;&quot;&quot;显⽰简单的问候语&quot;&quot;&quot;
    print(f&quot;Hello, {username.title()}!&quot;)
greet_user(&#x27;jesse&#x27;)
# 输出
Hello, Jesse!
</code></pre>
</li>
<li>
<p>在 greet_user() 函数的定义中，变量 username 是⼀个形参（parameter），即函数完成⼯作所需的信息。在代码greet_user('jesse') 中，值 'jesse' 是⼀个实参（argument），即在调⽤函数时传递给函数的信息。</p>
</li>
</ul>
<h3>如何传递实参</h3>
<ul>
<li>
<p>位置实参</p>
<pre><code class="language-python">def describe_pet(animal_type, pet_name):
    &quot;&quot;&quot;显⽰宠物的信息&quot;&quot;&quot;
    print(f&quot;\nI have a {animal_type}.&quot;)
    print(f&quot;My {animal_type}&#x27;s name is {pet_name. title()}.&quot;)
describe_pet(&#x27;hamster&#x27;, &#x27;harry&#x27;)
describe_pet(&#x27;dog&#x27;, &#x27;willie&#x27;)
# 位置实参的顺序很重要
</code></pre>
</li>
<li>
<p>关键字实参</p>
<pre><code class="language-python">def describe_pet(animal_type, pet_name):
    &quot;&quot;&quot;显⽰宠物的信息&quot;&quot;&quot;
    print(f&quot;\nI have a {animal_type}.&quot;)
    print(f&quot;My {animal_type}&#x27;s name is {pet_name.title()}.&quot;)
# 下⾯两个函数调⽤是等效的 
describe_pet(animal_type=&#x27;hamster&#x27;, pet_name=&#x27;harry&#x27;)
describe_pet(pet_name=&#x27;harry&#x27;, animal_type=&#x27;hamster&#x27;)
# 注意：在使⽤关键字实参时，务必准确地指定函数定义中的形参名。
</code></pre>
</li>
<li>
<p>默认值</p>
<p>在编写函数时，可以给每个形参指定默认值。如果在调⽤函数中给形参提供了实参，Python 将使⽤指定的实参值；否则，将使⽤形参的默认值。因此，给形参指定默认值后，可在函数调⽤中省略相应的实参。使⽤默认值不仅能简化函数调⽤，还能清楚地指出函数的典型⽤法。</p>
<pre><code class="language-python">def describe_pet(pet_name, animal_type=&#x27;dog&#x27;):
 &quot;&quot;&quot;显⽰宠物的信息&quot;&quot;&quot;
 print(f&quot;\nI have a {animal_type}.&quot;)
 print(f&quot;My {animal_type}&#x27;s name is {pet_name.title()}.&quot;)
describe_pet(pet_name=&#x27;willie&#x27;)
describe_pet(&#x27;willie&#x27;)
describe_pet(pet_name=&#x27;harry&#x27;, animal_type=&#x27;hamster&#x27;)
</code></pre>
<p>注意：当使⽤默认值时，必须在形参列表中先列出没有默认值的形参，再列出有默认值的形参。这让 Python 依然能够正确地解读位置实参。</p>
</li>
<li>
<p>等效的函数调⽤</p>
<pre><code class="language-python">def describe_pet(pet_name, animal_type=&#x27;dog&#x27;):
# 下⾯对这个函数的所有调⽤都可⾏：

# ⼀条名为 Willie 的⼩狗
describe_pet(&#x27;willie&#x27;)
describe_pet(pet_name=&#x27;willie&#x27;)
# ⼀只名为 Harry 的仓⿏
describe_pet(&#x27;harry&#x27;, &#x27;hamster&#x27;)
describe_pet(pet_name=&#x27;harry&#x27;, animal_type=&#x27;hamster&#x27;)
describe_pet(animal_type=&#x27;hamster&#x27;, pet_name=&#x27;harry&#x27;)
</code></pre>
</li>
</ul>
<h3>返回值</h3>
<ul>
<li>
<p>返回简单的值</p>
<pre><code class="language-python">def get_formatted_name(first_name, last_name):
    &quot;&quot;&quot;返回标准格式的姓名&quot;&quot;&quot;
    full_name = f&quot;{first_name} {last_name}&quot;
    return full_name.title()
musician = get_formatted_name(&#x27;jimi&#x27;, &#x27;hendrix&#x27;)
print(musician)
</code></pre>
</li>
<li>
<p>让实参变成可选的</p>
<p>可以使⽤默认值来让实参变成可选的。</p>
<pre><code class="language-python">def get_formatted_name(first_name, last_name, middle_name=&#x27;&#x27;):
    &quot;&quot;&quot;返回标准格式的姓名&quot;&quot;&quot;
    if middle_name:  # Python 将⾮空字符串解读为 True
        full_name = f&quot;{first_name} {middle_name} {last_name}&quot;
    else:
        full_name = f&quot;{first_name} {last_name}&quot;
    return full_name.title()

musician = get_formatted_name(&#x27;jimi&#x27;, &#x27;hendrix&#x27;)
print(musician)
musician = get_formatted_name(&#x27;john&#x27;, &#x27;hooker&#x27;, &#x27;lee&#x27;)
print(musician)
</code></pre>
</li>
<li>
<p>返回字典</p>
<pre><code class="language-python">def build_person(first_name, last_name, age=None):
    &quot;&quot;&quot;返回⼀个字典，其中包含有关⼀个⼈的信息&quot;&quot;&quot;
    person = {&#x27;first&#x27;: first_name, &#x27;last&#x27;: last_name}
    if age:
        person[&#x27;age&#x27;] = age
    return person

musician = build_person(&#x27;jimi&#x27;, &#x27;hendrix&#x27;, age=27)
print(musician)
</code></pre>
<ul>
<li>在函数定义中，新增了⼀个可选形参 age，其默认值被设置为特殊值 None（表⽰变量没有值）。可将 None 视为占位值。在条件测试中，None 相当于 False.</li>
</ul>
</li>
</ul>
<h3>传递列表</h3>
<ul>
<li>
<p>在函数中修改列表</p>
<pre><code class="language-python">def print_models(unprinted_designs, completed_models):
    &quot;&quot;&quot;
    模拟打印每个设计，直到没有未打印的设计为⽌
    打印每个设计后，都将其移到列表 completed_models 中
    &quot;&quot;&quot;
    while unprinted_designs:
        current_design = unprinted_designs.pop()
        print(f&quot;Printing model: {current_design}&quot;)
        completed_models.append(current_design)

def show_completed_models(completed_models):
    &quot;&quot;&quot;显⽰打印好的所有模型&quot;&quot;&quot;
    print(&quot;\nThe following models have been printed:&quot;)
    for completed_model in completed_models:
        print(completed_model)

unprinted_designs = [&#x27;phone case&#x27;, &#x27;robot pendant&#x27;, &#x27;dodecahedron&#x27;]
completed_models = []

print_models(unprinted_designs, completed_models)
show_completed_models(completed_models)
</code></pre>
</li>
<li>
<p>禁⽌函数修改列表（ 切片 [ : ] ）</p>
<p>有时候，需要禁⽌函数修改列表。可向函数传递列表的副本⽽不是原始列表。这样，函数所做的任何修改都只影响副本，⽽丝毫不影响原始列表。</p>
<pre><code class="language-python"># 要将列表的副本传递给函数，可以像下⾯这样做：
function_name(list_name[:])
# 切⽚表⽰法 [:] 创建列表的副本。
print_models(unprinted_designs[:], completed_models)
# 在上面的例子中，如果不想清空未打印的设计列表，可像下⾯这样调⽤ print_models()
</code></pre>
<p>虽然向函数传递列表的副本可保留原始列表的内容，但除⾮有充分的理由，否则还是应该将原始列表传递给函数。这是因为，让函数使⽤现成的列表可避免花时间和内存创建副本，从⽽提⾼效率，在处理⼤型列表时尤其如此。</p>
</li>
</ul>
<h3>传递任意数量的实参 （*形参 / **形参）</h3>
<pre><code class="language-python"># 下⾯的函数只有⼀个形参 *toppings，不管调⽤语句提供了多少实参，这个形参都会将其收⼊囊中。
def make_pizza(*toppings):
    &quot;&quot;&quot;打印顾客点的所有配料&quot;&quot;&quot;
    print(toppings)
make_pizza(&#x27;pepperoni&#x27;)
make_pizza(&#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)
# 形参名 *toppings 中的星号让 Python 创建⼀个名为 toppings 的元组，该元组包含函数收到的所有值。

</code></pre>
<ul>
<li>
<p>结合使⽤位置实参和任意数量的实参  </p>
<p>如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python 先匹配位置实参和关键字实参，再将余下的实参都收集到最后⼀个形参中。</p>
<pre><code class="language-python">def make_pizza(size, *toppings):
    &quot;&quot;&quot;概述要制作的⽐萨&quot;&quot;&quot;
    print(f&quot;\nMaking a {size}-inch pizza with the following toppings:&quot;)
    for topping in toppings:
        print(f&quot;- {topping}&quot;)

make_pizza(16, &#x27;pepperoni&#x27;)
make_pizza(12, &#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)
</code></pre>
<p>注意：你经常会看到通⽤形参名 *args，它也这样收集任意数量的位置实参。</p>
</li>
<li>
<p>使⽤任意数量的关键字实参</p>
<pre><code class="language-python">def build_profile(first, last, **user_info):
    &quot;&quot;&quot;创建⼀个字典，其中包含我们知道的有关⽤户的⼀切&quot;&quot;&quot;
  ❶ user_info[&#x27;first_name&#x27;] = first
    user_info[&#x27;last_name&#x27;] = last
    return user_info
user_profile = build_profile(&#x27;albert&#x27;, &#x27;einstein&#x27;,
                             location=&#x27;princeton&#x27;,
                             field=&#x27;physics&#x27;)
print(user_profile)
# 输出
{&#x27;location&#x27;: &#x27;princeton&#x27;, &#x27;field&#x27;: &#x27;physics&#x27;,
&#x27;first_name&#x27;: &#x27;albert&#x27;, &#x27;last_name&#x27;: &#x27;einstein&#x27;}
</code></pre>
<p>你需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键值对——调⽤语句提供了多少就接受多少。  </p>
<p>形参 **user_info 中的两个星号让 Python 创建⼀个名为 user_info 的字典，该字典包含函数收到的其他所有名对。</p>
<p>注意：你经常会看到形参名 **kwargs，它⽤于收集任意数量的关键字实参。</p>
</li>
</ul>
<h3>将函数存储在模块中，再将模块导⼊主程序</h3>
<ul>
<li>
<p>导⼊整个模块  </p>
<p>只需编写⼀条 import 语句并在其中指定模块名，就可在程序中使⽤该模块中的所有函数。如果使⽤这种 import 语句导⼊了名为 module_name.py 的整个模块，就可使⽤下⾯的语法来使⽤其中的任意⼀个函数。</p>
<pre><code class="language-python">import module_name
module_name.function_name()
</code></pre>
<p>要让函数是可导⼊的，得先创建模块。模块是扩展名为 .py 的⽂件，包含要导⼊程序的代码。下⾯来创建⼀个包含 make_pizza() 函数的模块。</p>
<p>pizza.py</p>
<pre><code class="language-python">def make_pizza(size, *toppings):
    &quot;&quot;&quot;概述要制作的⽐萨&quot;&quot;&quot;
    print(f&quot;\nMaking a {size}-inch pizza with the following toppings:&quot;)
    for topping in toppings:
        print(f&quot;- {topping}&quot;)
</code></pre>
<p>making_pizzas.py</p>
<pre><code class="language-python">import pizza

pizza.make_pizza(16, &#x27;pepperoni&#x27;)
pizza.make_pizza(12, &#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)

</code></pre>
<p>当 Python 读取这个⽂件时，代码⾏ import pizza 会让 Python 打开⽂件pizza.py，并将其中的所有函数都复制到这个程序中。</p>
</li>
<li>
<p>导⼊模块中的特定函数</p>
<pre><code class="language-python">from module_name import function_name
</code></pre>
<p>⽤逗号分隔函数名，可根据需要从模块中导⼊任意数量的函数：</p>
<pre><code class="language-python">from module_name import function_0, function_1, function_2
</code></pre>
<pre><code class="language-python">from pizza import make_pizza
make_pizza(16, &#x27;pepperoni&#x27;)
make_pizza(12, &#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)
</code></pre>
<p>如果使⽤这种语法，在调⽤函数时则⽆须使⽤句点。由于在 import 语句中显式地导⼊了 make_pizza() 函数，因此在调⽤时只需指定其名称即可。</p>
</li>
<li>
<p>使⽤ as 给函数指定别名（alias）</p>
<pre><code class="language-python">from module_name import function_name as fn
</code></pre>
<p>如果要导⼊的函数的名称太⻓或者可能与程序中既有的名称冲突，可指定简短⽽独⼀⽆⼆的别名。</p>
<pre><code class="language-python">from pizza import make_pizza as mp
mp(16, &#x27;pepperoni&#x27;)
mp(12, &#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)
</code></pre>
</li>
<li>
<p>使⽤ as 给模块指定别名</p>
<pre><code class="language-python">import module_name as mn
</code></pre>
<pre><code class="language-python">import pizza as p
p.make_pizza(16, &#x27;pepperoni&#x27;)
p.make_pizza(12, &#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)
</code></pre>
</li>
<li>
<p>导⼊模块中的所有函数（ * ）</p>
<pre><code class="language-python">from pizza import *
make_pizza(16, &#x27;pepperoni&#x27;)
make_pizza(12, &#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)
</code></pre>
<p>import 语句中的星号让 Python 将模块 pizza 中的每个函数都复制到这个程序⽂件中。由于导⼊了每个函数，可通过名称来调⽤每个函数，⽆须使⽤点号（dot notation）。<br />
最好不要用这种发放导入。最佳的做法是，要么只导⼊需要使⽤的函数，要么导⼊整个模块并使⽤点号。</p>
</li>
</ul>
<h3>函数编写指南</h3>
<ul>
<li>
<p>应给函数指定描述性名称，且只使⽤⼩写字⺟和下划线。。在给模块命名时也应遵循上述约定。</p>
</li>
<li>
<p>每个函数都应包含简要阐述其功能的注释。该注释应紧跟在函数定义后⾯，并采⽤⽂档字符串的格式。</p>
</li>
<li>
<p>在给形参指定默认值时，等号两边不要有空格：</p>
<pre><code class="language-python">def function_name(parameter_0, parameter_1=&#x27;default value&#x27;)

</code></pre>
</li>
<li>
<p>函数调⽤中的关键字实参也应遵循这种约定：</p>
<pre><code class="language-python">function_name(value_0, parameter_1=&#x27;value&#x27;)
</code></pre>
</li>
<li>
<p>如果形参很多，导致函数定义的⻓度超过了 79 个
字符，可在函数定义中输⼊左括号后按回⻋键，并在下⼀⾏连按两次制表符键，从⽽将形参列表和只缩进⼀层的函数体区分开来。</p>
<pre><code class="language-python">def function_name(
        parameter_0, parameter_1, parameter_2,
        parameter_3, parameter_4, parameter_5):
    function body...
</code></pre>
</li>
<li>
<p>如果程序或模块包含多个函数，可使⽤两个空⾏将相邻的函数分开。</p>
</li>
<li>
<p>所有的 import 语句都应放在⽂件开头。</p>
</li>
</ul>
<h2>9 类</h2>
<h3>创建和使⽤类创建实例</h3>
<pre><code class="language-python"># 使⽤属性在类中存储信息，编写⽅法让类具备所需的⾏为
class Dog:
    &quot;&quot;&quot;⼀次模拟⼩狗的简单尝试&quot;&quot;&quot;
    def __init__(self, name, age):
    &quot;&quot;&quot;初始化属性 name 和 age&quot;&quot;&quot;
        self.name = name
        self.age = age
    def sit(self):
    &quot;&quot;&quot;模拟⼩狗收到命令时坐下&quot;&quot;&quot;
        print(f&quot;{self.name} is now sitting.&quot;)
    def roll_over(self):
    &quot;&quot;&quot;模拟⼩狗收到命令时打滚&quot;&quot;&quot;
        print(f&quot;{self.name} rolled over!&quot;)

# 创建实例
my_dog = Dog(&#x27;Willie&#x27;, 6)
# 访问属性 my_dog.name
print(f&quot;My dog&#x27;s name is {my_dog.name}.&quot;)
print(f&quot;My dog is {my_dog.age} years old.&quot;)
# 调⽤⽅法
my_dog.sit()
my_dog.roll_over()
# 创建多个实例
my_dog = Dog(&#x27;Willie&#x27;, 6)
your_dog = Dog(&#x27;Lucy&#x27;, 3)
</code></pre>
<pre><code class="language-python">__init__() ⽅法  

1.  __init__() 是⼀个特殊⽅法，每当你根据 Dog 类创建新实例时，Python 都会⾃动运⾏它。  
2.  在这个⽅法的名称中，开头和末尾各有两个下划线。  
3.  这个⽅法的定义中，形参 self 必不可少，⽽且必须位于其他形参的前⾯。  
4.  当 Python 调⽤这个⽅法来创建 Dog 实例时，将⾃动传⼊实参 self。每个与实例相关联的⽅法调⽤都会⾃动传递实参 self，该实参是⼀个指向实例本⾝的引⽤，让实例能够访问类中的属性和⽅法。  
5.  在 __init__() ⽅法内定义的两个变量都有前缀 self 。以self 为前缀的变量可供类中的所有⽅法使⽤，可以通过类的任意实例来访问。像这样可通过实例访问的变量称为属性（attribute）。
</code></pre>
<h3>给类的属性指定默认值，修改实例的属性的值</h3>
<ul>
<li>
<p>给属性指定默认值</p>
<pre><code class="language-python"># 有些属性⽆须通过形参来定义，可以在 __init__() ⽅法中为其指定默认值
class Car:
    def __init__(self, make, model, year):
    &quot;&quot;&quot;初始化描述汽⻋的属性&quot;&quot;&quot;
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0
</code></pre>
</li>
<li>
<p>修改实例的属性的值</p>
<ul>
<li>
<p>直接修改属性的值</p>
<pre><code class="language-python">class Car:
    --snip--

my_new_car = Car(&#x27;audi&#x27;, &#x27;a4&#x27;, 2024)

my_new_car.odometer_reading = 23
</code></pre>
</li>
<li>
<p>通过⽅法修改属性的值</p>
<pre><code class="language-python">class Car:
    --snip--
    def update_odometer(self, mileage):
        &quot;&quot;&quot;将⾥程表读数设置为指定的值&quot;&quot;&quot;
        self.odometer_reading = mileage

my_new_car = Car(&#x27;audi&#x27;, &#x27;a4&#x27;, 2024)
my_new_car.update_odometer(23)
</code></pre>
</li>
<li>
<p>通过⽅法让属性的值递增</p>
<pre><code class="language-python">class Car:
    --snip--
    def update_odometer(self, mileage):
    --snip--
    def increment_odometer(self, miles):
        &quot;&quot;&quot;让⾥程表读数增加指定的量&quot;&quot;&quot;
        self.odometer_reading += miles
</code></pre>
</li>
</ul>
</li>
</ul>
<h3>继承</h3>
<p>当⼀个类继承（inheritance）另⼀个类时，将⾃动获得后者的所有属性和⽅法。原有的类称为⽗类（parent class），⽽新类称为⼦类（child class）。⼦类不仅继承了⽗类的所有属性和⽅法，还可定义⾃⼰的属性和⽅法</p>
<ul>
<li>
<p>⼦类的 init() ⽅法</p>
<pre><code class="language-python">class Car:
    &quot;&quot;&quot;⼀次模拟汽⻋的简单尝试&quot;&quot;&quot;

    def __init__(self, make, model, year):
        &quot;&quot;&quot;初始化描述汽⻋的属性&quot;&quot;&quot;
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_descriptive_name(self):
        &quot;&quot;&quot;返回格式规范的描述性名称&quot;&quot;&quot;
        long_name = f&quot;{self.year} {self.make} {self.model}&quot;
        return long_name.title()

    def read_odometer(self):
        &quot;&quot;&quot;打印⼀个句⼦，指出汽⻋的⾏驶⾥程&quot;&quot;&quot;
        print(f&quot;This car has {self.odometer_reading} miles on it.&quot;)

    def update_odometer(self, mileage):
        &quot;&quot;&quot;将⾥程表读数设置为给定的值&quot;&quot;&quot;
        if mileage &gt;= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print(&quot;You can&#x27;t roll back an odometer!&quot;)

    def increment_odometer(self, miles):
        &quot;&quot;&quot;让⾥程表读数增加给定的量&quot;&quot;&quot;
        self.odometer_reading += miles

class ElectricCar(Car):
    &quot;&quot;&quot;电动汽⻋的独特之处&quot;&quot;&quot;

    def __init__(self, make, model, year):
        &quot;&quot;&quot;初始化⽗类的属性&quot;&quot;&quot;
        super().__init__(make, model, year)

my_leaf = ElectricCar(&#x27;nissan&#x27;, &#x27;leaf&#x27;, 2024)
print(my_leaf.get_descriptive_name()) 
</code></pre>
<ul>
<li>在创建⼦类时，⽗类必须包含在当前⽂件中，且位于⼦类前⾯。</li>
<li>定义⼦类 ElectricCar。在定义⼦类时，必须在括号内指定⽗类的名称。</li>
<li>super() 是⼀个特殊的函数，让你能够调⽤⽗类的⽅法.⽗类也称为超类（superclass）。</li>
</ul>
</li>
<li>
<p>给⼦类定义属性和⽅法</p>
<pre><code class="language-python"># 下⾯添加⼀个电动汽⻋特有的属性（电池）
class Car:
    --snip--

class ElectricCar(Car):
    &quot;&quot;&quot;电动汽⻋的独特之处&quot;&quot;&quot;
    def __init__(self, make, model, year):
        &quot;&quot;&quot;
        先初始化⽗类的属性，再初始化电动汽⻋特有的属性
        &quot;&quot;&quot;
        super().__init__(make, model, year)
        self.battery_size = 40

    def describe_battery(self):
        &quot;&quot;&quot;打印⼀条描述电池容量的消息&quot;&quot;&quot;
        print(f&quot;This car has a {self.battery_size}-kWh battery.&quot;)

my_leaf = ElectricCar(&#x27;nissan&#x27;, &#x27;leaf&#x27;, 2024)
print(my_leaf.get_descriptive_name())
my_leaf.describe_battery()
</code></pre>
</li>
<li>
<p>重写⽗类中的⽅法</p>
<ul>
<li>在⼦类中定义⼀个与要重写的⽗类⽅法同名的⽅法。这样，Python 将忽略这个⽗类⽅法，只关注你在⼦类中定义的相应⽅法。</li>
</ul>
</li>
<li>
<p>将⼀个类的实例⽤作另⼀个类的属性</p>
<pre><code class="language-python">class Car:
    --snip--

class Battery:
    &quot;&quot;&quot;⼀次模拟电动汽⻋电池的简单尝试&quot;&quot;&quot;
❶    def __init__(self, battery_size=40):
          &quot;&quot;&quot;初始化电池的属性&quot;&quot;&quot;
          self.battery_size = battery_size

❷     def describe_battery(self):
          &quot;&quot;&quot;打印⼀条描述电池容量的消息&quot;&quot;&quot;
          print(f&quot;This car has a {self.battery_size}-kWh battery.&quot;)

class ElectricCar(Car):
    &quot;&quot;&quot;电动汽⻋的独特之处&quot;&quot;&quot;
    def __init__(self, make, model, year):
        &quot;&quot;&quot;
        先初始化⽗类的属性，再初始化电动汽⻋特有的属性
        &quot;&quot;&quot;
        super().__init__(make, model, year)
❸       self.battery = Battery()

 my_leaf = ElectricCar(&#x27;nissan&#x27;, &#x27;leaf&#x27;, 2024)
 print(my_leaf.get_descriptive_name())
 my_leaf.battery.describe_battery()
</code></pre>
<ul>
<li>将⼤型类拆分成多个协同⼯作的⼩类，这种⽅法称为组合（composition）。</li>
<li>在 ElectricCar 类中，添加⼀个名为 self.battery 的属性（⻅❸）。这⾏代码让 Python 创建⼀个新的 Battery 实例（因为没有指定容量，所以为默认值 40），并将该实例赋给属性 self.battery。</li>
<li>每当__init__() ⽅法被调⽤时，都将执⾏该操作，因此现在每个ElectricCar 实例都包含⼀个⾃动创建的 Battery 实例。</li>
</ul>
<pre><code class="language-python">my_leaf.battery.describe_battery()
</code></pre>
<ul>
<li>这⾏代码让 Python 在实例 my_leaf 中查找属性 battery，并对存储在该属性中的 Battery 实例调⽤ describe_battery() ⽅法。</li>
</ul>
</li>
</ul>
<h3>导⼊类</h3>
<ul>
<li>
<p>导⼊单个类</p>
<p>my_car.py</p>
<pre><code class="language-python">from car import Car

my_new_car = Car(&#x27;audi&#x27;, &#x27;a4&#x27;, 2024)
print(my_new_car.get_descriptive_name())

my_new_car.odometer_reading = 23
my_new_car.read_odometer()
</code></pre>
</li>
<li>
<p>从⼀个模块中导⼊多个类  </p>
<p>在⼀个模块中能存储多个类，可根据需要导入所需的类。</p>
<pre><code class="language-python"> from car import Car, ElectricCar
</code></pre>
</li>
<li>
<p>导⼊整个模块  </p>
<p>还可以先导⼊整个模块，再使⽤点号访问需要的类。<br />
由于创建类实例的代码都包含模块名，因此不会与当前⽂件使⽤的任何名称发⽣冲突。</p>
<pre><code class="language-python">import car
# 使⽤语法module_name.classname 访问需要的类
my_mustang = car.Car(&#x27;ford&#x27;, &#x27;mustang&#x27;, 2024)
print(my_mustang.get_descriptive_name())

my_leaf = car.ElectricCar(&#x27;nissan&#x27;, &#x27;leaf&#x27;, 2024)
print(my_leaf.get_descriptive_name())
</code></pre>
</li>
<li>
<p>导⼊模块中的所有类</p>
<pre><code class="language-python"># 不推荐这种导⼊⽅式
from module_name import *
</code></pre>
</li>
<li>
<p>在⼀个模块中导⼊另⼀个模块</p>
<p>在将类存储在多个模块中时，你可能会发现⼀个模块中的类依赖于另⼀个模块中的类。在这种情况下，可在前⼀个模块中导⼊必要的类。</p>
<p>car.py</p>
<pre><code class="language-python">&quot;&quot;&quot;⼀个可⽤于表⽰汽⻋的类&quot;&quot;&quot;
class Car:
    --snip--
</code></pre>
<p>electric_car.py</p>
<pre><code class="language-python">&quot;&quot;&quot;⼀组可⽤于表⽰电动汽⻋的类&quot;&quot;&quot;
from car import Car
class Battery:
    --snip--
class ElectricCar(Car):
    --snip--
# ElectricCar 类需要访问其⽗类 Car，因此直接将 Car 类导⼊该模块。
</code></pre>
<p>my_cars.py</p>
<pre><code class="language-python">from car import Car
from electric_car import ElectricCar

my_mustang = Car(&#x27;ford&#x27;, &#x27;mustang&#x27;, 2024)
print(my_mustang.get_descriptive_name())

my_leaf = ElectricCar(&#x27;nissan&#x27;, &#x27;leaf&#x27;, 2024)
print(my_leaf.get_descriptive_name())
# 输出
2024 Ford Mustang
2024 Nissan Leaf
</code></pre>
</li>
<li>
<p>使⽤别名</p>
<pre><code class="language-python"># 给类指定别名。
from electric_car import ElectricCar as EC

my_leaf = EC(&#x27;nissan&#x27;, &#x27;leaf&#x27;, 2024)
</code></pre>
<pre><code class="language-python"># 给模块指定别名。
import electric_car as ec

my_leaf = ec.ElectricCar(&#x27;nissan&#x27;, &#x27;leaf&#x27;, 2024)
</code></pre>
</li>
</ul>
<h3>Python 标准库</h3>
<p>Python 标准库是⼀组模块，在安装 Python 时已经包含在内。你可以使⽤标准库中的任何函数和类，只需在程序开头添加⼀条简单的 import 语句即可。</p>
<h3>类的编程⻛格</h3>
<ul>
<li>类名应采⽤驼峰命名法，即将类名中的每个单词的⾸字⺟都⼤写，并且不使⽤下划线。</li>
<li>实例名和模块名都采⽤全⼩写格式，并在单词之间加上下划线。</li>
<li>在类中，可以使⽤⼀个空⾏来分隔⽅法；⽽在模块中，可以使⽤两个空⾏来分隔类。</li>
</ul>
<h2>10 ⽂件和异常</h2>
<h3>读取⽂件（ path对象 . read_text() ）</h3>
<pre><code class="language-python"># 读取⽂件的全部内容
from pathlib import Path

path = Path(&#x27;pi_digits.txt&#x27;)
contents = path.read_text()
print(contents)
# 相⽐于原始⽂件，该输出唯⼀不同的地⽅是末尾多了⼀个空⾏。因为 read_text() 在到达⽂件末尾时会返回⼀个空字符串，⽽这个空字符串会被显⽰为⼀个空⾏。
# 要删除这个多出来的空⾏，可对字符串变量 contents 调⽤ rstrip()：
contents = path.read_text().rstrip()
# 这⾏代码先让 Python 对当前处理的⽂件调⽤ read_text() ⽅法，再对read_text() 返回的字符串调⽤ rstrip() ⽅法，然后将整理好的字符串赋给变量 contents。这种做法称为⽅法链式调⽤（method chaining）
</code></pre>
<ul>
<li>
<p>相对⽂件路径让 Python 到相对于当前运⾏的程序所在⽬录的指定位置去查找。</p>
<pre><code class="language-python"># 由于⽂件夹 text_files 位于⽂件夹 python_work 中，因此需要创建⼀个以 text_files 打头并以⽂件名结尾的路径，如下所⽰：
path = Path(&#x27;text_files/filename.txt&#x27;)
# 绝对路径通常⽐相对路径⻓，因为它们以系统的根⽂件夹为起点
path = Path(&#x27;/home/eric/data_files/text_files/filename.txt&#x27;)
</code></pre>
</li>
<li>
<p>访问⽂件中的各⾏</p>
<p>使⽤ splitlines() ⽅法返回⼀个列表，其中包含⽂件中所有的⾏，再使⽤for 循环以每次⼀⾏的⽅式检查⽂件中的各⾏。</p>
<pre><code class="language-python">from pathlib import Path

path = Path(&#x27;pi_digits.txt&#x27;)
contents = path.read_text()
lines = contents.splitlines()
for line in lines:
    print(line)
</code></pre>
</li>
<li>
<p>使⽤⽂件的内容</p>
<pre><code class="language-python">from pathlib import Path

path = Path(&#x27;pi_digits.txt&#x27;)
contents = path.read_text()

lines = contents.splitlines()
pi_string = &#x27;&#x27;
for line in lines:
    pi_string += line

print(pi_string)
print(len(pi_string))
</code></pre>
<ul>
<li>注意：在读取⽂本⽂件时，Python 将其中的所有⽂本都解释为字符串。如果读取的是数，并且要将其作为数值使⽤，就必须使⽤ int()函数将其转换为整数，或者使⽤ float() 函数将其转换为浮点数。</li>
</ul>
</li>
</ul>
<h3>写⼊⽂件（ path对象 . write_text() ）</h3>
<ul>
<li>
<p>写⼊⼀⾏</p>
<pre><code class="language-python">from pathlib import Path
# write_text() ⽅法接受单个实参，即要写⼊⽂件的字符串。
path = Path(&#x27;programming.txt&#x27;)
path.write_text(&quot;I love programming.&quot;)
</code></pre>
<ul>
<li>注意：Python 只能将字符串写⼊⽂本⽂件。如果要将数值数据存储到⽂本⽂件中，必须先使⽤函数 str() 将其转换为字符串格式。</li>
</ul>
</li>
<li>
<p>写⼊多⾏</p>
<pre><code class="language-python">from pathlib import Path
# 可以通过添加空格、制表符和空⾏来设置输出的格式
contents = &quot;I love programming.\n&quot;
contents += &quot;I love creating new games.\n&quot;
contents += &quot;I also love working with data.\n&quot;

path = Path(&#x27;programming.txt&#x27;)
path.write_text(contents)

# 文本文件内容：
I love programming.
I love creating new games.
I also love working with data.
</code></pre>
<ul>
<li>注意：在对 path 对象调⽤ write_text() ⽅法时，务必谨慎。如果指定的⽂件已存在， write_text() 将删除其内容，并将指定的内容写⼊其中。本章后⾯将介绍如何使⽤ pathlib 检查指定的⽂件是否存在。</li>
</ul>
</li>
</ul>
<h3>异常</h3>
<ul>
<li>
<p>Python 使⽤称为异常（exception）的特殊对象来管理程序执⾏期间发⽣的错误。</p>
</li>
<li>
<p>每当发⽣让 Python 不知所措的错误时，它都会创建⼀个异常对象。如果你编写了处理该异常的代码，程序将继续运⾏；如果你未对异常进⾏处理，程序将停⽌，并显⽰⼀个 traceback，其中包含有关异常的报告。</p>
</li>
<li>
<p>异常是使⽤ try-except 代码块处理的。</p>
</li>
<li>
<p>try-except 代码块让 Python执⾏指定的操作，同时告诉 Python 在发⽣异常时应该怎么办。在使⽤try-except 代码块时，即便出现异常，程序也将继续运⾏：显⽰你编写的友好的错误消息，⽽不是令⽤户迷惑的 traceback。</p>
</li>
</ul>
<h4>使⽤ try-except 代码块</h4>
<p>只有可能引发异常的代码才需要放在 try 语句中。except 代码块告诉 Python，如果在尝试运⾏ try 代码块中的代码时引发了指定的异常该怎么办。</p>
<pre><code class="language-python">try:
    print(5/0)
except ZeroDivisionError:
    print(&quot;You can&#x27;t divide by zero!&quot;)
# 这⾥将导致错误的代码⾏ print(5/0) 放在⼀个 try 代码块中。
#如果 try 代码块中的代码运⾏起来没有问题，Python 将跳过 except 代码块；
#如果try 代码块中的代码导致错误，Python 将查找与之匹配的 except 代码块并运⾏其中的代码。
</code></pre>
<h4>else 代码块</h4>
<p>只有 try代码块成功执⾏才需要继续执⾏的代码，都应放到 else 代码块中。</p>
<pre><code class="language-python">--snip--
while True:
    --snip--
    if second_number == &#x27;q&#x27;:
        break
    try:
        answer = int(first_number) / int(second_number)
    except ZeroDivisionError:
        print(&quot;You can&#x27;t divide by 0!&quot;)
    else:
        print(answer)
</code></pre>
<ul>
<li>
<p>静默失败 （ pass ）</p>
<p>出现异常时，虽然仍将执⾏except 代码块中的代码，但什么都不会发⽣。。当这种错误发⽣时，既不会出现 traceback，也没有任何输出。</p>
<pre><code class="language-python">def count_words(path):
    &quot;&quot;&quot;计算⼀个⽂件⼤致包含多少个单词&quot;&quot;&quot;
    try:
        --snip--
    except FileNotFoundError:
        pass
    else:
        --snip--
</code></pre>
</li>
</ul>
<h4>常见的异常类型有</h4>
<ul>
<li>StopIteration - 迭代器没有更多的值</li>
<li>ImportError - 导入模块失败</li>
<li>IndexError - 序列中找不到给定的索引</li>
<li>KeyError - 映射中找不到给定的键</li>
<li>ValueError - 传入无效的参数</li>
<li>TypeError - 对类型无效的操作</li>
<li>FileNotFoundError - 未找到文件</li>
<li>KeyboardInterrupt - 用户中断执行</li>
</ul>
<h3>使⽤模块 json 来存储数据</h3>
<ul>
<li>
<p>模块 json 让你能够将简单的 Python 数据结构转换为 JSON 格式的字符串，并在程序再次运⾏时从⽂件中加载数据。</p>
</li>
<li>
<p>使⽤ json.dumps() 和 json.loads()</p>
<p>number_writer.py</p>
<pre><code class="language-python"># json.dumps() 函数接受⼀个实参，即要转换为 JSON 格式的数据。这个函数返回⼀个字符串，这样你就可将其写⼊数据⽂件了
from pathlib import Path
import json

numbers = [2, 3, 5, 7, 11, 13]

path = Path(&#x27;numbers.json&#x27;)
contents = json.dumps(numbers)
path.write_text(contents)
#输出
[2, 3, 5, 7, 11, 13]
</code></pre>
<p>number_reader.py</p>
</li>
</ul>
<pre><code class="language-python">from pathlib import Path
import json

path = Path(&#x27;numbers.json&#x27;)
contents = path.read_text()
numbers = json.loads(contents)

print(numbers)
#输出
[2, 3, 5, 7, 11, 13]
</code></pre>
<h3>重构</h3>
<p>remember_me.py</p>
<pre><code class="language-python">from pathlib import Path
import json

def greet_user():
    &quot;&quot;&quot;问候⽤户，并指出其名字&quot;&quot;&quot;
    path = Path(&#x27;username.json&#x27;)
    if path.exists():
        contents = path.read_text()
        username = json.loads(contents)
        print(f&quot;Welcome back, {username}!&quot;)
    else:
        username = input(&quot;What is your name? &quot;)
        contents = json.dumps(username)
        path.write_text(contents)
        print(f&quot;We&#x27;ll remember you when you come back, {username}!&quot;)

greet_user()
</code></pre>
<p>remember_me.py 最终版（每个函数都执⾏单⼀⽽清晰的任务）</p>
<pre><code class="language-python">from pathlib import Path
import json

def get_stored_username(path):
    &quot;&quot;&quot;如果存储了⽤户名，就获取它&quot;&quot;&quot;
    --snip--

def get_new_username(path):
    &quot;&quot;&quot;提⽰⽤户输⼊⽤户名&quot;&quot;&quot;
    username = input(&quot;What is your name? &quot;)
    contents = json.dumps(username)
    path.write_text(contents)
    return username

def greet_user():
    &quot;&quot;&quot;问候⽤户，并指出其名字&quot;&quot;&quot;
    path = Path(&#x27;username.json&#x27;)
    username = get_stored_username(path)
    if username:
        print(f&quot;Welcome back, {username}!&quot;)
    else:
        username = get_new_username(path)
        print(f&quot;We&#x27;ll remember you when you come back, {username}!&quot;)

 greet_user()
</code></pre>
<h2>11 使⽤ pytest 工具库测试代码</h2>
<h3>使⽤ pip 安装 pytest</h3>
<ul>
<li>
<p>更新 pip</p>
<pre><code class="language-python">python -m pip install --upgrade pip
# 这个命令的第⼀部分（python -m pip）让 Python 运⾏ pip 模块；
#第⼆部分（install --upgrade）让 pip 更新⼀个已安装的包；
#⽽最后⼀部分（pip）指定要更新哪个第三⽅包。
</code></pre>
<p>可使⽤下⾯的命令更新系统中安装的任何包：</p>
<pre><code class="language-python"> python -m pip install --upgrade package_name
</code></pre>
</li>
<li>
<p>安装 pytest</p>
<pre><code class="language-python">python -m pip install --user pytest
# --user 这个标志让 Python 只为当前⽤户安装指定的包。
</code></pre>
<p>可使⽤下⾯的命令安装众多的第三⽅包：</p>
<pre><code class="language-python"> python -m pip install --user package_name
</code></pre>
<p>注意：如果在执⾏这个命令时遇到⿇烦，可尝试在不指定标志 --user 的情况下再次执⾏它。</p>
</li>
</ul>
<h3>测试函数</h3>
<p>name_function.py</p>
<pre><code class="language-python">def get_formatted_name(first, last):
    &quot;&quot;&quot;⽣成格式规范的姓名&quot;&quot;&quot;
    full_name = f&quot;{first} {last}&quot;
    return full_name.title()
</code></pre>
<p>names.py</p>
<pre><code class="language-python">from name_function import get_formatted_name

print(&quot;Enter &#x27;q&#x27; at any time to quit.&quot;)
while True:
    first = input(&quot;\nPlease give me a first name: &quot;)
    if first == &#x27;q&#x27;:
        break
    last = input(&quot;Please give me a last name: &quot;)
    if last == &#x27;q&#x27;:
        break
    formatted_name = get_formatted_name(first, last)
    print(f&quot;\tNeatly formatted name: {formatted_name}.&quot;)
</code></pre>
<p>测试⽤例（test case）是⼀组单元测试（unit test）。<br />
全覆盖（full coverage）测试⽤例包含⼀整套单元测试，涵盖了各种可能的函数使⽤⽅式。</p>
<p>test_name_function.py（测试）</p>
<pre><code class="language-python"># 编写⼀个测试函数，它会调⽤要测试的函数，并做出有关返回值的断⾔。
# 如果断⾔正确，表⽰测试通过；如果断⾔不正确，表⽰测试未通过。
from name_function import get_formatted_name

def test_first_last_name():
    &quot;&quot;&quot;能够正确地处理像 Janis Joplin 这样的姓名吗？&quot;&quot;&quot;
    formatted_name = get_formatted_name(&#x27;janis&#x27;, &#x27;joplin&#x27;)
    assert formatted_name == &#x27;Janis Joplin&#x27;
</code></pre>
<ul>
<li>测试⽂件的名称很重要，必须以test_打头。当你让 pytest 运⾏测试时，它将查找以 test_打头的⽂件，并运⾏其中的所有测试。</li>
<li>测试函数必须以 test_打头。在测试过程中，pytest 将找出并运⾏所有以 test_ 打头的函数。且函数名要具有描述性。</li>
</ul>
<h3>运⾏测试</h3>
<p>打开⼀个终端窗⼝，并切换到这个测试⽂件所在的⽂件夹。如果你使⽤的是 VS Code，可打开测试⽂件所在的⽂件夹，并使⽤该编辑器内嵌的终端。在终端窗⼝中执⾏命令 pytest，你将看到如下输出：</p>
<pre><code class="language-python">$ pytest
 ========================= test session starts
=========================
❶ platform darwin -- Python 3.x.x, pytest-7.x.x, pluggy-1.x.x
❷ rootdir: /.../python_work/chapter_11
❸ collected 1 item
❹ test_name_function.py . 
[100%]
 ========================== 1 passed in 0.00s
==========================
</code></pre>
<h3>测试类</h3>
<ul>
<li>
<p>测试中常⽤的断⾔语句</p>
<table>
<thead>
<tr>
<th>断⾔</th>
<th>⽤途</th>
</tr>
</thead>
<tbody>
<tr>
<td>assert a == b</td>
<td>断⾔两个值相等</td>
</tr>
<tr>
<td>assert a != b</td>
<td>断⾔两个值不等</td>
</tr>
<tr>
<td>assert a</td>
<td>断⾔ a 的布尔求值为 True</td>
</tr>
<tr>
<td>assert not a</td>
<td>断⾔ a 的布尔求值为 False</td>
</tr>
<tr>
<td>assert element in list</td>
<td>断⾔元素在列表中</td>
</tr>
<tr>
<td>assert element not in list</td>
<td>断⾔元素不在列表中</td>
</tr>
</tbody></table></li>
</ul>
<p>survey.py</p>
<pre><code class="language-python">class AnonymousSurvey:
    &quot;&quot;&quot;收集匿名调查问卷的答案&quot;&quot;&quot;

    def __init__(self, question):
        &quot;&quot;&quot;存储⼀个问题，并为存储答案做准备&quot;&quot;&quot;
        self.question = question
        self.responses = []

    def show_question(self):
        &quot;&quot;&quot;显⽰调查问卷&quot;&quot;&quot;
        print(self.question)

    def store_response(self, new_response):
        &quot;&quot;&quot;存储单份调查答卷&quot;&quot;&quot;
        self.responses.append(new_response)

    def show_results(self):
        &quot;&quot;&quot;显⽰收集到的所有答卷&quot;&quot;&quot;
        print(&quot;Survey results:&quot;)
        for response in self.responses:
        print(f&quot;- {response}&quot;)
</code></pre>
<p>test_survey.py</p>
<pre><code class="language-python">from survey import AnonymousSurvey

def test_store_single_response():
    &quot;&quot;&quot;测试单个答案会被妥善地存储&quot;&quot;&quot;
    question = &quot;What language did you first learn to speak?&quot;
    language_survey = AnonymousSurvey(question)
    language_survey.store_response(&#x27;English&#x27;)
    assert &#x27;English&#x27; in language_survey.responses

def test_store_three_responses():
    &quot;&quot;&quot;测试三个答案会被妥善地存储&quot;&quot;&quot;
    question = &quot;What language did you first learn to speak?&quot;
    language_survey = AnonymousSurvey(question)
    responses = [&#x27;English&#x27;, &#x27;Spanish&#x27;, &#x27;Mandarin&#x27;]

    for response in responses:
        language_survey.store_response(response)

    for response in responses:
        assert response in language_survey.responses
</code></pre>
<p>如果在执⾏命令 pytest 时没有指定任何参数，pytest 将运⾏它在当前⽬录中找到的所有测试。为了专注于⼀个测试⽂件，可将该测试⽂件的名称作为参数传递给 pytest。</p>
<pre><code class="language-python">$ pytest test_survey.py
========================= test session starts =========================
--snip--
test_survey.py .. [100%]
========================== 2 passed in 0.01s ==========================
</code></pre>
<h3>使⽤夹具</h3>
<pre><code class="language-python">import pytest
from survey import AnonymousSurvey

@pytest.fixture
def language_survey():
    &quot;&quot;&quot;⼀个可供所有测试函数使⽤的 AnonymousSurvey 实例&quot;&quot;&quot;
    question = &quot;What language did you first learn to speak?&quot;
    language_survey = AnonymousSurvey(question)
    return language_survey

def test_store_single_response(language_survey):
    &quot;&quot;&quot;测试单个答案会被妥善地存储&quot;&quot;&quot;
    language_survey.store_response(&#x27;English&#x27;)
    assert &#x27;English&#x27; in language_survey.responses

def test_store_three_responses(language_survey):
    &quot;&quot;&quot;测试三个答案会被妥善地存储&quot;&quot;&quot;
    responses = [&#x27;English&#x27;, &#x27;Spanish&#x27;, &#x27;Mandarin&#x27;]
    for response in responses:
        language_survey.store_response(response)

    for response in responses:
        assert response in language_survey.responses
</code></pre>
<ul>
<li>在测试中，夹具（fixture）可帮助我们搭建测试环境。这通常意味着创建供多个测试使⽤的资源。</li>
<li>在 pytest 中，要创建夹具，可编写⼀个使⽤装饰器 @pytest.fixture 装饰的函数。装饰器（decorator）是放在函数定义前⾯的指令。在运⾏函数前，Python 将该指令应⽤于函数，以修改函数代码的⾏为。</li>
<li>当测试函数的⼀个形参与应⽤了装饰器 @pytest.fixture 的函数（夹具）同名时，将⾃动运⾏夹具，并将夹具返回的值传递给测试函数。</li>
<li>在这个⽰例中，language_survey() 函数向 test_store_single_response() 和 test_store_three_responses() 提供了⼀个 language_survey 实例。</li>
<li>在想要使⽤夹具时，可编写⼀个函数来⽣成供多个测试函数使⽤的资源，再对这个函数应⽤装饰器 @pytest.fixture，并让使⽤该资源的每个测试函数都接受⼀个与该函数同名的形参。这样，测试将更简洁，编写和维护起来也将更容易。</li>
</ul>
]]></content><link href="https://github.com/hadleysu/gitblog/issues/4"/><category term="技术相关"/><published>2023-09-14T08:20:32+00:00</published></entry><entry><id>https://github.com/hadleysu/gitblog/issues/3</id><title>Markdown相关</title><updated>2024-09-01T15:08:35.874253+00:00</updated><content type="html"><![CDATA[<p>资料：</p>
<ul>
<li><a href="https://github.com/google/styleguide/blob/gh-pages/docguide/style.md">Google Markdown  Style Guide</a></li>
<li><a href="https://cirosantilli.com/markdown-style-guide/">Markdown  Style Guide</a></li>
</ul>
<p>VS Code 安装 Extensions:</p>
<ul>
<li>Markdown All in One</li>
<li>markdownlint</li>
</ul>
<p>Markdown All in One 生成TOC:</p>
<ul>
<li>CTRL + shift + p --&gt; Create Table of Contents</li>
<li>生成目录后，每次更新保存后将自动更新目录。</li>
<li>测试</li>
</ul>
]]></content><link href="https://github.com/hadleysu/gitblog/issues/3"/><category term="技术相关"/><published>2023-09-12T13:49:32+00:00</published></entry><entry><id>https://github.com/hadleysu/gitblog/issues/2</id><title>感谢yihong老师的gitblog项目</title><updated>2024-09-01T15:08:35.947134+00:00</updated><content type="html"><![CDATA[<p>感谢yihong老师的gitblog项目，我可以开启我的写issue博客之旅了。</p>
<p><a href="https://github.com/yihong0618/gitblog">yihong老师的gitblog项目</a>
<a href="https://github.com/yihong0618/gitblog/issues/177">这个博客开源了</a></p>
]]></content><link href="https://github.com/hadleysu/gitblog/issues/2"/><category term="一些记录"/><published>2023-09-10T13:21:29+00:00</published></entry></feed>